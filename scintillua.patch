diff -r ffde119d297e gtk/makefile
--- scintilla/gtk/makefile	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/gtk/makefile	Tue Aug 17 00:13:24 2010 -0400
@@ -28,7 +28,7 @@
 vpath %.h ../src ../include ../lexlib
 vpath %.cxx ../src ../lexlib ../lexers
 
-INCLUDEDIRS=-I ../include -I ../src -I ../lexlib
+INCLUDEDIRS=-I ../include -I ../src -I ../lexlib -I ../../scite/lua/include # modified by Mitchell
 CXXBASEFLAGS=-Wall -Wno-missing-braces -Wno-char-subscripts -Wno-long-long -pedantic -DGTK -DSCI_LEXER $(INCLUDEDIRS)
 
 ifdef NOTHREADS
@@ -51,7 +51,7 @@
 .c.o:
 	$(CCOMP) $(CONFIGFLAGS) $(CXXFLAGS) -w -c $<
 
-LEXOBJS:=$(addsuffix .o,$(basename $(notdir $(wildcard ../lexers/Lex*.cxx))))
+LEXOBJS:=$(addsuffix .o,$(basename $(notdir $(wildcard ../lexers/LexLPeg.cxx)))) # modified by Mitchell
 
 all: $(COMPLIB)
 
diff -r ffde119d297e include/SciLexer.h
--- scintilla/include/SciLexer.h	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/include/SciLexer.h	Tue Aug 17 00:13:24 2010 -0400
@@ -16,6 +16,8 @@
 /* ++Autogenerated -- start of section automatically generated from Scintilla.iface */
 #define SCLEX_CONTAINER 0
 #define SCLEX_NULL 1
+#define SCLEX_LPEG 2
+#if 0 // added by Mitchell
 #define SCLEX_PYTHON 2
 #define SCLEX_CPP 3
 #define SCLEX_HTML 4
@@ -112,7 +114,9 @@
 #define SCLEX_SML 97
 #define SCLEX_MARKDOWN 98
 #define SCLEX_TXT2TAGS 99
+#endif // added by Mitchell
 #define SCLEX_AUTOMATIC 1000
+#if 0 // added by Mitchell
 #define SCE_P_DEFAULT 0
 #define SCE_P_COMMENTLINE 1
 #define SCE_P_NUMBER 2
@@ -1415,6 +1419,7 @@
 #define SCE_TXT2TAGS_OPTION 23
 #define SCE_TXT2TAGS_PREPROC 24
 #define SCE_TXT2TAGS_POSTPROC 25
+#endif // added by Mitchell
 /* --Autogenerated -- end of section automatically generated from Scintilla.iface */
 
 #endif
diff -r ffde119d297e include/Scintilla.iface
--- scintilla/include/Scintilla.iface	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/include/Scintilla.iface	Tue Aug 17 00:13:24 2010 -0400
@@ -2142,7 +2142,7 @@
 get int GetLexerLanguage=4012(, stringresult text)
 
 # For private communication between an application and a known lexer.
-fun int PrivateLexerCall=4013(int operation, int pointer)
+fun int PrivateLexerCall=4013(int operation, stringresult val) # modified by Mitchell
 
 # Retrieve a '\n' separated list of properties understood by the current lexer.
 fun int PropertyNames=4014(, stringresult names)
@@ -2234,1586 +2234,13 @@
 enu Lexer=SCLEX_
 val SCLEX_CONTAINER=0
 val SCLEX_NULL=1
-val SCLEX_PYTHON=2
-val SCLEX_CPP=3
-val SCLEX_HTML=4
-val SCLEX_XML=5
-val SCLEX_PERL=6
-val SCLEX_SQL=7
-val SCLEX_VB=8
-val SCLEX_PROPERTIES=9
-val SCLEX_ERRORLIST=10
-val SCLEX_MAKEFILE=11
-val SCLEX_BATCH=12
-val SCLEX_XCODE=13
-val SCLEX_LATEX=14
-val SCLEX_LUA=15
-val SCLEX_DIFF=16
-val SCLEX_CONF=17
-val SCLEX_PASCAL=18
-val SCLEX_AVE=19
-val SCLEX_ADA=20
-val SCLEX_LISP=21
-val SCLEX_RUBY=22
-val SCLEX_EIFFEL=23
-val SCLEX_EIFFELKW=24
-val SCLEX_TCL=25
-val SCLEX_NNCRONTAB=26
-val SCLEX_BULLANT=27
-val SCLEX_VBSCRIPT=28
-val SCLEX_BAAN=31
-val SCLEX_MATLAB=32
-val SCLEX_SCRIPTOL=33
-val SCLEX_ASM=34
-val SCLEX_CPPNOCASE=35
-val SCLEX_FORTRAN=36
-val SCLEX_F77=37
-val SCLEX_CSS=38
-val SCLEX_POV=39
-val SCLEX_LOUT=40
-val SCLEX_ESCRIPT=41
-val SCLEX_PS=42
-val SCLEX_NSIS=43
-val SCLEX_MMIXAL=44
-val SCLEX_CLW=45
-val SCLEX_CLWNOCASE=46
-val SCLEX_LOT=47
-val SCLEX_YAML=48
-val SCLEX_TEX=49
-val SCLEX_METAPOST=50
-val SCLEX_POWERBASIC=51
-val SCLEX_FORTH=52
-val SCLEX_ERLANG=53
-val SCLEX_OCTAVE=54
-val SCLEX_MSSQL=55
-val SCLEX_VERILOG=56
-val SCLEX_KIX=57
-val SCLEX_GUI4CLI=58
-val SCLEX_SPECMAN=59
-val SCLEX_AU3=60
-val SCLEX_APDL=61
-val SCLEX_BASH=62
-val SCLEX_ASN1=63
-val SCLEX_VHDL=64
-val SCLEX_CAML=65
-val SCLEX_BLITZBASIC=66
-val SCLEX_PUREBASIC=67
-val SCLEX_HASKELL=68
-val SCLEX_PHPSCRIPT=69
-val SCLEX_TADS3=70
-val SCLEX_REBOL=71
-val SCLEX_SMALLTALK=72
-val SCLEX_FLAGSHIP=73
-val SCLEX_CSOUND=74
-val SCLEX_FREEBASIC=75
-val SCLEX_INNOSETUP=76
-val SCLEX_OPAL=77
-val SCLEX_SPICE=78
-val SCLEX_D=79
-val SCLEX_CMAKE=80
-val SCLEX_GAP=81
-val SCLEX_PLM=82
-val SCLEX_PROGRESS=83
-val SCLEX_ABAQUS=84
-val SCLEX_ASYMPTOTE=85
-val SCLEX_R=86
-val SCLEX_MAGIK=87
-val SCLEX_POWERSHELL=88
-val SCLEX_MYSQL=89
-val SCLEX_PO=90
-val SCLEX_TAL=91
-val SCLEX_COBOL=92
-val SCLEX_TACL=93
-val SCLEX_SORCUS=94
-val SCLEX_POWERPRO=95
-val SCLEX_NIMROD=96
-val SCLEX_SML=97
-val SCLEX_MARKDOWN=98
-val SCLEX_TXT2TAGS=99
+val SCLEX_LPEG=2
 
 # When a lexer specifies its language as SCLEX_AUTOMATIC it receives a
 # value assigned in sequence from SCLEX_AUTOMATIC+1.
 val SCLEX_AUTOMATIC=1000
-# Lexical states for SCLEX_PYTHON
-lex Python=SCLEX_PYTHON SCE_P_
-lex Nimrod=SCLEX_NIMROD SCE_P_
-val SCE_P_DEFAULT=0
-val SCE_P_COMMENTLINE=1
-val SCE_P_NUMBER=2
-val SCE_P_STRING=3
-val SCE_P_CHARACTER=4
-val SCE_P_WORD=5
-val SCE_P_TRIPLE=6
-val SCE_P_TRIPLEDOUBLE=7
-val SCE_P_CLASSNAME=8
-val SCE_P_DEFNAME=9
-val SCE_P_OPERATOR=10
-val SCE_P_IDENTIFIER=11
-val SCE_P_COMMENTBLOCK=12
-val SCE_P_STRINGEOL=13
-val SCE_P_WORD2=14
-val SCE_P_DECORATOR=15
-# Lexical states for SCLEX_CPP
-lex Cpp=SCLEX_CPP SCE_C_
-lex BullAnt=SCLEX_BULLANT SCE_C_
-val SCE_C_DEFAULT=0
-val SCE_C_COMMENT=1
-val SCE_C_COMMENTLINE=2
-val SCE_C_COMMENTDOC=3
-val SCE_C_NUMBER=4
-val SCE_C_WORD=5
-val SCE_C_STRING=6
-val SCE_C_CHARACTER=7
-val SCE_C_UUID=8
-val SCE_C_PREPROCESSOR=9
-val SCE_C_OPERATOR=10
-val SCE_C_IDENTIFIER=11
-val SCE_C_STRINGEOL=12
-val SCE_C_VERBATIM=13
-val SCE_C_REGEX=14
-val SCE_C_COMMENTLINEDOC=15
-val SCE_C_WORD2=16
-val SCE_C_COMMENTDOCKEYWORD=17
-val SCE_C_COMMENTDOCKEYWORDERROR=18
-val SCE_C_GLOBALCLASS=19
-# Lexical states for SCLEX_D
-lex D=SCLEX_D SCE_D_
-val SCE_D_DEFAULT=0
-val SCE_D_COMMENT=1
-val SCE_D_COMMENTLINE=2
-val SCE_D_COMMENTDOC=3
-val SCE_D_COMMENTNESTED=4
-val SCE_D_NUMBER=5
-val SCE_D_WORD=6
-val SCE_D_WORD2=7
-val SCE_D_WORD3=8
-val SCE_D_TYPEDEF=9
-val SCE_D_STRING=10
-val SCE_D_STRINGEOL=11
-val SCE_D_CHARACTER=12
-val SCE_D_OPERATOR=13
-val SCE_D_IDENTIFIER=14
-val SCE_D_COMMENTLINEDOC=15
-val SCE_D_COMMENTDOCKEYWORD=16
-val SCE_D_COMMENTDOCKEYWORDERROR=17
-val SCE_D_STRINGB=18
-val SCE_D_STRINGR=19
-val SCE_D_WORD5=20
-val SCE_D_WORD6=21
-val SCE_D_WORD7=22
-# Lexical states for SCLEX_TCL
-lex TCL=SCLEX_TCL SCE_TCL_
-val SCE_TCL_DEFAULT=0
-val SCE_TCL_COMMENT=1
-val SCE_TCL_COMMENTLINE=2
-val SCE_TCL_NUMBER=3
-val SCE_TCL_WORD_IN_QUOTE=4
-val SCE_TCL_IN_QUOTE=5
-val SCE_TCL_OPERATOR=6
-val SCE_TCL_IDENTIFIER=7
-val SCE_TCL_SUBSTITUTION=8
-val SCE_TCL_SUB_BRACE=9
-val SCE_TCL_MODIFIER=10
-val SCE_TCL_EXPAND=11
-val SCE_TCL_WORD=12
-val SCE_TCL_WORD2=13
-val SCE_TCL_WORD3=14
-val SCE_TCL_WORD4=15
-val SCE_TCL_WORD5=16
-val SCE_TCL_WORD6=17
-val SCE_TCL_WORD7=18
-val SCE_TCL_WORD8=19
-val SCE_TCL_COMMENT_BOX=20
-val SCE_TCL_BLOCK_COMMENT=21
-# Lexical states for SCLEX_HTML, SCLEX_XML
-lex HTML=SCLEX_HTML SCE_H
-lex XML=SCLEX_XML SCE_H
-lex ASP=SCLEX_ASP SCE_H
-lex PHP=SCLEX_PHP SCE_H
-val SCE_H_DEFAULT=0
-val SCE_H_TAG=1
-val SCE_H_TAGUNKNOWN=2
-val SCE_H_ATTRIBUTE=3
-val SCE_H_ATTRIBUTEUNKNOWN=4
-val SCE_H_NUMBER=5
-val SCE_H_DOUBLESTRING=6
-val SCE_H_SINGLESTRING=7
-val SCE_H_OTHER=8
-val SCE_H_COMMENT=9
-val SCE_H_ENTITY=10
-# XML and ASP
-val SCE_H_TAGEND=11
-val SCE_H_XMLSTART=12
-val SCE_H_XMLEND=13
-val SCE_H_SCRIPT=14
-val SCE_H_ASP=15
-val SCE_H_ASPAT=16
-val SCE_H_CDATA=17
-val SCE_H_QUESTION=18
-# More HTML
-val SCE_H_VALUE=19
-# X-Code
-val SCE_H_XCCOMMENT=20
-# SGML
-val SCE_H_SGML_DEFAULT=21
-val SCE_H_SGML_COMMAND=22
-val SCE_H_SGML_1ST_PARAM=23
-val SCE_H_SGML_DOUBLESTRING=24
-val SCE_H_SGML_SIMPLESTRING=25
-val SCE_H_SGML_ERROR=26
-val SCE_H_SGML_SPECIAL=27
-val SCE_H_SGML_ENTITY=28
-val SCE_H_SGML_COMMENT=29
-val SCE_H_SGML_1ST_PARAM_COMMENT=30
-val SCE_H_SGML_BLOCK_DEFAULT=31
-# Embedded Javascript
-val SCE_HJ_START=40
-val SCE_HJ_DEFAULT=41
-val SCE_HJ_COMMENT=42
-val SCE_HJ_COMMENTLINE=43
-val SCE_HJ_COMMENTDOC=44
-val SCE_HJ_NUMBER=45
-val SCE_HJ_WORD=46
-val SCE_HJ_KEYWORD=47
-val SCE_HJ_DOUBLESTRING=48
-val SCE_HJ_SINGLESTRING=49
-val SCE_HJ_SYMBOLS=50
-val SCE_HJ_STRINGEOL=51
-val SCE_HJ_REGEX=52
-# ASP Javascript
-val SCE_HJA_START=55
-val SCE_HJA_DEFAULT=56
-val SCE_HJA_COMMENT=57
-val SCE_HJA_COMMENTLINE=58
-val SCE_HJA_COMMENTDOC=59
-val SCE_HJA_NUMBER=60
-val SCE_HJA_WORD=61
-val SCE_HJA_KEYWORD=62
-val SCE_HJA_DOUBLESTRING=63
-val SCE_HJA_SINGLESTRING=64
-val SCE_HJA_SYMBOLS=65
-val SCE_HJA_STRINGEOL=66
-val SCE_HJA_REGEX=67
-# Embedded VBScript
-val SCE_HB_START=70
-val SCE_HB_DEFAULT=71
-val SCE_HB_COMMENTLINE=72
-val SCE_HB_NUMBER=73
-val SCE_HB_WORD=74
-val SCE_HB_STRING=75
-val SCE_HB_IDENTIFIER=76
-val SCE_HB_STRINGEOL=77
-# ASP VBScript
-val SCE_HBA_START=80
-val SCE_HBA_DEFAULT=81
-val SCE_HBA_COMMENTLINE=82
-val SCE_HBA_NUMBER=83
-val SCE_HBA_WORD=84
-val SCE_HBA_STRING=85
-val SCE_HBA_IDENTIFIER=86
-val SCE_HBA_STRINGEOL=87
-# Embedded Python
-val SCE_HP_START=90
-val SCE_HP_DEFAULT=91
-val SCE_HP_COMMENTLINE=92
-val SCE_HP_NUMBER=93
-val SCE_HP_STRING=94
-val SCE_HP_CHARACTER=95
-val SCE_HP_WORD=96
-val SCE_HP_TRIPLE=97
-val SCE_HP_TRIPLEDOUBLE=98
-val SCE_HP_CLASSNAME=99
-val SCE_HP_DEFNAME=100
-val SCE_HP_OPERATOR=101
-val SCE_HP_IDENTIFIER=102
-# PHP
-val SCE_HPHP_COMPLEX_VARIABLE=104
-# ASP Python
-val SCE_HPA_START=105
-val SCE_HPA_DEFAULT=106
-val SCE_HPA_COMMENTLINE=107
-val SCE_HPA_NUMBER=108
-val SCE_HPA_STRING=109
-val SCE_HPA_CHARACTER=110
-val SCE_HPA_WORD=111
-val SCE_HPA_TRIPLE=112
-val SCE_HPA_TRIPLEDOUBLE=113
-val SCE_HPA_CLASSNAME=114
-val SCE_HPA_DEFNAME=115
-val SCE_HPA_OPERATOR=116
-val SCE_HPA_IDENTIFIER=117
-# PHP
-val SCE_HPHP_DEFAULT=118
-val SCE_HPHP_HSTRING=119
-val SCE_HPHP_SIMPLESTRING=120
-val SCE_HPHP_WORD=121
-val SCE_HPHP_NUMBER=122
-val SCE_HPHP_VARIABLE=123
-val SCE_HPHP_COMMENT=124
-val SCE_HPHP_COMMENTLINE=125
-val SCE_HPHP_HSTRING_VARIABLE=126
-val SCE_HPHP_OPERATOR=127
-# Lexical states for SCLEX_PERL
-lex Perl=SCLEX_PERL SCE_PL_
-val SCE_PL_DEFAULT=0
-val SCE_PL_ERROR=1
-val SCE_PL_COMMENTLINE=2
-val SCE_PL_POD=3
-val SCE_PL_NUMBER=4
-val SCE_PL_WORD=5
-val SCE_PL_STRING=6
-val SCE_PL_CHARACTER=7
-val SCE_PL_PUNCTUATION=8
-val SCE_PL_PREPROCESSOR=9
-val SCE_PL_OPERATOR=10
-val SCE_PL_IDENTIFIER=11
-val SCE_PL_SCALAR=12
-val SCE_PL_ARRAY=13
-val SCE_PL_HASH=14
-val SCE_PL_SYMBOLTABLE=15
-val SCE_PL_VARIABLE_INDEXER=16
-val SCE_PL_REGEX=17
-val SCE_PL_REGSUBST=18
-val SCE_PL_LONGQUOTE=19
-val SCE_PL_BACKTICKS=20
-val SCE_PL_DATASECTION=21
-val SCE_PL_HERE_DELIM=22
-val SCE_PL_HERE_Q=23
-val SCE_PL_HERE_QQ=24
-val SCE_PL_HERE_QX=25
-val SCE_PL_STRING_Q=26
-val SCE_PL_STRING_QQ=27
-val SCE_PL_STRING_QX=28
-val SCE_PL_STRING_QR=29
-val SCE_PL_STRING_QW=30
-val SCE_PL_POD_VERB=31
-val SCE_PL_SUB_PROTOTYPE=40
-val SCE_PL_FORMAT_IDENT=41
-val SCE_PL_FORMAT=42
-# Lexical states for SCLEX_RUBY
-lex Ruby=SCLEX_RUBY SCE_RB_
-val SCE_RB_DEFAULT=0
-val SCE_RB_ERROR=1
-val SCE_RB_COMMENTLINE=2
-val SCE_RB_POD=3
-val SCE_RB_NUMBER=4
-val SCE_RB_WORD=5
-val SCE_RB_STRING=6
-val SCE_RB_CHARACTER=7
-val SCE_RB_CLASSNAME=8
-val SCE_RB_DEFNAME=9
-val SCE_RB_OPERATOR=10
-val SCE_RB_IDENTIFIER=11
-val SCE_RB_REGEX=12
-val SCE_RB_GLOBAL=13
-val SCE_RB_SYMBOL=14
-val SCE_RB_MODULE_NAME=15
-val SCE_RB_INSTANCE_VAR=16
-val SCE_RB_CLASS_VAR=17
-val SCE_RB_BACKTICKS=18
-val SCE_RB_DATASECTION=19
-val SCE_RB_HERE_DELIM=20
-val SCE_RB_HERE_Q=21
-val SCE_RB_HERE_QQ=22
-val SCE_RB_HERE_QX=23
-val SCE_RB_STRING_Q=24
-val SCE_RB_STRING_QQ=25
-val SCE_RB_STRING_QX=26
-val SCE_RB_STRING_QR=27
-val SCE_RB_STRING_QW=28
-val SCE_RB_WORD_DEMOTED=29
-val SCE_RB_STDIN=30
-val SCE_RB_STDOUT=31
-val SCE_RB_STDERR=40
-val SCE_RB_UPPER_BOUND=41
-# Lexical states for SCLEX_VB, SCLEX_VBSCRIPT, SCLEX_POWERBASIC
-lex VB=SCLEX_VB SCE_B_
-lex VBScript=SCLEX_VBSCRIPT SCE_B_
-lex PowerBasic=SCLEX_POWERBASIC SCE_B_
-val SCE_B_DEFAULT=0
-val SCE_B_COMMENT=1
-val SCE_B_NUMBER=2
-val SCE_B_KEYWORD=3
-val SCE_B_STRING=4
-val SCE_B_PREPROCESSOR=5
-val SCE_B_OPERATOR=6
-val SCE_B_IDENTIFIER=7
-val SCE_B_DATE=8
-val SCE_B_STRINGEOL=9
-val SCE_B_KEYWORD2=10
-val SCE_B_KEYWORD3=11
-val SCE_B_KEYWORD4=12
-val SCE_B_CONSTANT=13
-val SCE_B_ASM=14
-val SCE_B_LABEL=15
-val SCE_B_ERROR=16
-val SCE_B_HEXNUMBER=17
-val SCE_B_BINNUMBER=18
-# Lexical states for SCLEX_PROPERTIES
-lex Properties=SCLEX_PROPERTIES SCE_PROPS_
-val SCE_PROPS_DEFAULT=0
-val SCE_PROPS_COMMENT=1
-val SCE_PROPS_SECTION=2
-val SCE_PROPS_ASSIGNMENT=3
-val SCE_PROPS_DEFVAL=4
-val SCE_PROPS_KEY=5
-# Lexical states for SCLEX_LATEX
-lex LaTeX=SCLEX_LATEX SCE_L_
-val SCE_L_DEFAULT=0
-val SCE_L_COMMAND=1
-val SCE_L_TAG=2
-val SCE_L_MATH=3
-val SCE_L_COMMENT=4
-# Lexical states for SCLEX_LUA
-lex Lua=SCLEX_LUA SCE_LUA_
-val SCE_LUA_DEFAULT=0
-val SCE_LUA_COMMENT=1
-val SCE_LUA_COMMENTLINE=2
-val SCE_LUA_COMMENTDOC=3
-val SCE_LUA_NUMBER=4
-val SCE_LUA_WORD=5
-val SCE_LUA_STRING=6
-val SCE_LUA_CHARACTER=7
-val SCE_LUA_LITERALSTRING=8
-val SCE_LUA_PREPROCESSOR=9
-val SCE_LUA_OPERATOR=10
-val SCE_LUA_IDENTIFIER=11
-val SCE_LUA_STRINGEOL=12
-val SCE_LUA_WORD2=13
-val SCE_LUA_WORD3=14
-val SCE_LUA_WORD4=15
-val SCE_LUA_WORD5=16
-val SCE_LUA_WORD6=17
-val SCE_LUA_WORD7=18
-val SCE_LUA_WORD8=19
-# Lexical states for SCLEX_ERRORLIST
-lex ErrorList=SCLEX_ERRORLIST SCE_ERR_
-val SCE_ERR_DEFAULT=0
-val SCE_ERR_PYTHON=1
-val SCE_ERR_GCC=2
-val SCE_ERR_MS=3
-val SCE_ERR_CMD=4
-val SCE_ERR_BORLAND=5
-val SCE_ERR_PERL=6
-val SCE_ERR_NET=7
-val SCE_ERR_LUA=8
-val SCE_ERR_CTAG=9
-val SCE_ERR_DIFF_CHANGED=10
-val SCE_ERR_DIFF_ADDITION=11
-val SCE_ERR_DIFF_DELETION=12
-val SCE_ERR_DIFF_MESSAGE=13
-val SCE_ERR_PHP=14
-val SCE_ERR_ELF=15
-val SCE_ERR_IFC=16
-val SCE_ERR_IFORT=17
-val SCE_ERR_ABSF=18
-val SCE_ERR_TIDY=19
-val SCE_ERR_JAVA_STACK=20
-val SCE_ERR_VALUE=21
-# Lexical states for SCLEX_BATCH
-lex Batch=SCLEX_BATCH SCE_BAT_
-val SCE_BAT_DEFAULT=0
-val SCE_BAT_COMMENT=1
-val SCE_BAT_WORD=2
-val SCE_BAT_LABEL=3
-val SCE_BAT_HIDE=4
-val SCE_BAT_COMMAND=5
-val SCE_BAT_IDENTIFIER=6
-val SCE_BAT_OPERATOR=7
-# Lexical states for SCLEX_MAKEFILE
-lex MakeFile=SCLEX_MAKEFILE SCE_MAKE_
-val SCE_MAKE_DEFAULT=0
-val SCE_MAKE_COMMENT=1
-val SCE_MAKE_PREPROCESSOR=2
-val SCE_MAKE_IDENTIFIER=3
-val SCE_MAKE_OPERATOR=4
-val SCE_MAKE_TARGET=5
-val SCE_MAKE_IDEOL=9
-# Lexical states for SCLEX_DIFF
-lex Diff=SCLEX_DIFF SCE_DIFF_
-val SCE_DIFF_DEFAULT=0
-val SCE_DIFF_COMMENT=1
-val SCE_DIFF_COMMAND=2
-val SCE_DIFF_HEADER=3
-val SCE_DIFF_POSITION=4
-val SCE_DIFF_DELETED=5
-val SCE_DIFF_ADDED=6
-val SCE_DIFF_CHANGED=7
-# Lexical states for SCLEX_CONF (Apache Configuration Files Lexer)
-lex Conf=SCLEX_CONF SCE_CONF_
-val SCE_CONF_DEFAULT=0
-val SCE_CONF_COMMENT=1
-val SCE_CONF_NUMBER=2
-val SCE_CONF_IDENTIFIER=3
-val SCE_CONF_EXTENSION=4
-val SCE_CONF_PARAMETER=5
-val SCE_CONF_STRING=6
-val SCE_CONF_OPERATOR=7
-val SCE_CONF_IP=8
-val SCE_CONF_DIRECTIVE=9
-# Lexical states for SCLEX_AVE, Avenue
-lex Avenue=SCLEX_AVE SCE_AVE_
-val SCE_AVE_DEFAULT=0
-val SCE_AVE_COMMENT=1
-val SCE_AVE_NUMBER=2
-val SCE_AVE_WORD=3
-val SCE_AVE_STRING=6
-val SCE_AVE_ENUM=7
-val SCE_AVE_STRINGEOL=8
-val SCE_AVE_IDENTIFIER=9
-val SCE_AVE_OPERATOR=10
-val SCE_AVE_WORD1=11
-val SCE_AVE_WORD2=12
-val SCE_AVE_WORD3=13
-val SCE_AVE_WORD4=14
-val SCE_AVE_WORD5=15
-val SCE_AVE_WORD6=16
-# Lexical states for SCLEX_ADA
-lex Ada=SCLEX_ADA SCE_ADA_
-val SCE_ADA_DEFAULT=0
-val SCE_ADA_WORD=1
-val SCE_ADA_IDENTIFIER=2
-val SCE_ADA_NUMBER=3
-val SCE_ADA_DELIMITER=4
-val SCE_ADA_CHARACTER=5
-val SCE_ADA_CHARACTEREOL=6
-val SCE_ADA_STRING=7
-val SCE_ADA_STRINGEOL=8
-val SCE_ADA_LABEL=9
-val SCE_ADA_COMMENTLINE=10
-val SCE_ADA_ILLEGAL=11
-# Lexical states for SCLEX_BAAN
-lex Baan=SCLEX_BAAN SCE_BAAN_
-val SCE_BAAN_DEFAULT=0
-val SCE_BAAN_COMMENT=1
-val SCE_BAAN_COMMENTDOC=2
-val SCE_BAAN_NUMBER=3
-val SCE_BAAN_WORD=4
-val SCE_BAAN_STRING=5
-val SCE_BAAN_PREPROCESSOR=6
-val SCE_BAAN_OPERATOR=7
-val SCE_BAAN_IDENTIFIER=8
-val SCE_BAAN_STRINGEOL=9
-val SCE_BAAN_WORD2=10
-# Lexical states for SCLEX_LISP
-lex Lisp=SCLEX_LISP SCE_LISP_
-val SCE_LISP_DEFAULT=0
-val SCE_LISP_COMMENT=1
-val SCE_LISP_NUMBER=2
-val SCE_LISP_KEYWORD=3
-val SCE_LISP_KEYWORD_KW=4
-val SCE_LISP_SYMBOL=5
-val SCE_LISP_STRING=6
-val SCE_LISP_STRINGEOL=8
-val SCE_LISP_IDENTIFIER=9
-val SCE_LISP_OPERATOR=10
-val SCE_LISP_SPECIAL=11
-val SCE_LISP_MULTI_COMMENT=12
-# Lexical states for SCLEX_EIFFEL and SCLEX_EIFFELKW
-lex Eiffel=SCLEX_EIFFEL SCE_EIFFEL_
-lex EiffelKW=SCLEX_EIFFELKW SCE_EIFFEL_
-val SCE_EIFFEL_DEFAULT=0
-val SCE_EIFFEL_COMMENTLINE=1
-val SCE_EIFFEL_NUMBER=2
-val SCE_EIFFEL_WORD=3
-val SCE_EIFFEL_STRING=4
-val SCE_EIFFEL_CHARACTER=5
-val SCE_EIFFEL_OPERATOR=6
-val SCE_EIFFEL_IDENTIFIER=7
-val SCE_EIFFEL_STRINGEOL=8
-# Lexical states for SCLEX_NNCRONTAB (nnCron crontab Lexer)
-lex NNCronTab=SCLEX_NNCRONTAB SCE_NNCRONTAB_
-val SCE_NNCRONTAB_DEFAULT=0
-val SCE_NNCRONTAB_COMMENT=1
-val SCE_NNCRONTAB_TASK=2
-val SCE_NNCRONTAB_SECTION=3
-val SCE_NNCRONTAB_KEYWORD=4
-val SCE_NNCRONTAB_MODIFIER=5
-val SCE_NNCRONTAB_ASTERISK=6
-val SCE_NNCRONTAB_NUMBER=7
-val SCE_NNCRONTAB_STRING=8
-val SCE_NNCRONTAB_ENVIRONMENT=9
-val SCE_NNCRONTAB_IDENTIFIER=10
-# Lexical states for SCLEX_FORTH (Forth Lexer)
-lex Forth=SCLEX_FORTH SCE_FORTH_
-val SCE_FORTH_DEFAULT=0
-val SCE_FORTH_COMMENT=1
-val SCE_FORTH_COMMENT_ML=2
-val SCE_FORTH_IDENTIFIER=3
-val SCE_FORTH_CONTROL=4
-val SCE_FORTH_KEYWORD=5
-val SCE_FORTH_DEFWORD=6
-val SCE_FORTH_PREWORD1=7
-val SCE_FORTH_PREWORD2=8
-val SCE_FORTH_NUMBER=9
-val SCE_FORTH_STRING=10
-val SCE_FORTH_LOCALE=11
-# Lexical states for SCLEX_MATLAB
-lex MatLab=SCLEX_MATLAB SCE_MATLAB_
-val SCE_MATLAB_DEFAULT=0
-val SCE_MATLAB_COMMENT=1
-val SCE_MATLAB_COMMAND=2
-val SCE_MATLAB_NUMBER=3
-val SCE_MATLAB_KEYWORD=4
-# single quoted string
-val SCE_MATLAB_STRING=5
-val SCE_MATLAB_OPERATOR=6
-val SCE_MATLAB_IDENTIFIER=7
-val SCE_MATLAB_DOUBLEQUOTESTRING=8
-# Lexical states for SCLEX_SCRIPTOL
-lex Sol=SCLEX_SCRIPTOL SCE_SCRIPTOL_
-val SCE_SCRIPTOL_DEFAULT=0
-val SCE_SCRIPTOL_WHITE=1
-val SCE_SCRIPTOL_COMMENTLINE=2
-val SCE_SCRIPTOL_PERSISTENT=3
-val SCE_SCRIPTOL_CSTYLE=4
-val SCE_SCRIPTOL_COMMENTBLOCK=5
-val SCE_SCRIPTOL_NUMBER=6
-val SCE_SCRIPTOL_STRING=7
-val SCE_SCRIPTOL_CHARACTER=8
-val SCE_SCRIPTOL_STRINGEOL=9
-val SCE_SCRIPTOL_KEYWORD=10
-val SCE_SCRIPTOL_OPERATOR=11
-val SCE_SCRIPTOL_IDENTIFIER=12
-val SCE_SCRIPTOL_TRIPLE=13
-val SCE_SCRIPTOL_CLASSNAME=14
-val SCE_SCRIPTOL_PREPROCESSOR=15
-# Lexical states for SCLEX_ASM
-lex Asm=SCLEX_ASM SCE_ASM_
-val SCE_ASM_DEFAULT=0
-val SCE_ASM_COMMENT=1
-val SCE_ASM_NUMBER=2
-val SCE_ASM_STRING=3
-val SCE_ASM_OPERATOR=4
-val SCE_ASM_IDENTIFIER=5
-val SCE_ASM_CPUINSTRUCTION=6
-val SCE_ASM_MATHINSTRUCTION=7
-val SCE_ASM_REGISTER=8
-val SCE_ASM_DIRECTIVE=9
-val SCE_ASM_DIRECTIVEOPERAND=10
-val SCE_ASM_COMMENTBLOCK=11
-val SCE_ASM_CHARACTER=12
-val SCE_ASM_STRINGEOL=13
-val SCE_ASM_EXTINSTRUCTION=14
-# Lexical states for SCLEX_FORTRAN
-lex Fortran=SCLEX_FORTRAN SCE_F_
-lex F77=SCLEX_F77 SCE_F_
-val SCE_F_DEFAULT=0
-val SCE_F_COMMENT=1
-val SCE_F_NUMBER=2
-val SCE_F_STRING1=3
-val SCE_F_STRING2=4
-val SCE_F_STRINGEOL=5
-val SCE_F_OPERATOR=6
-val SCE_F_IDENTIFIER=7
-val SCE_F_WORD=8
-val SCE_F_WORD2=9
-val SCE_F_WORD3=10
-val SCE_F_PREPROCESSOR=11
-val SCE_F_OPERATOR2=12
-val SCE_F_LABEL=13
-val SCE_F_CONTINUATION=14
-# Lexical states for SCLEX_CSS
-lex CSS=SCLEX_CSS SCE_CSS_
-val SCE_CSS_DEFAULT=0
-val SCE_CSS_TAG=1
-val SCE_CSS_CLASS=2
-val SCE_CSS_PSEUDOCLASS=3
-val SCE_CSS_UNKNOWN_PSEUDOCLASS=4
-val SCE_CSS_OPERATOR=5
-val SCE_CSS_IDENTIFIER=6
-val SCE_CSS_UNKNOWN_IDENTIFIER=7
-val SCE_CSS_VALUE=8
-val SCE_CSS_COMMENT=9
-val SCE_CSS_ID=10
-val SCE_CSS_IMPORTANT=11
-val SCE_CSS_DIRECTIVE=12
-val SCE_CSS_DOUBLESTRING=13
-val SCE_CSS_SINGLESTRING=14
-val SCE_CSS_IDENTIFIER2=15
-val SCE_CSS_ATTRIBUTE=16
-val SCE_CSS_IDENTIFIER3=17
-val SCE_CSS_PSEUDOELEMENT=18
-val SCE_CSS_EXTENDED_IDENTIFIER=19
-val SCE_CSS_EXTENDED_PSEUDOCLASS=20
-val SCE_CSS_EXTENDED_PSEUDOELEMENT=21
-val SCE_CSS_MEDIA=22
-# Lexical states for SCLEX_POV
-lex POV=SCLEX_POV SCE_POV_
-val SCE_POV_DEFAULT=0
-val SCE_POV_COMMENT=1
-val SCE_POV_COMMENTLINE=2
-val SCE_POV_NUMBER=3
-val SCE_POV_OPERATOR=4
-val SCE_POV_IDENTIFIER=5
-val SCE_POV_STRING=6
-val SCE_POV_STRINGEOL=7
-val SCE_POV_DIRECTIVE=8
-val SCE_POV_BADDIRECTIVE=9
-val SCE_POV_WORD2=10
-val SCE_POV_WORD3=11
-val SCE_POV_WORD4=12
-val SCE_POV_WORD5=13
-val SCE_POV_WORD6=14
-val SCE_POV_WORD7=15
-val SCE_POV_WORD8=16
-# Lexical states for SCLEX_LOUT
-lex LOUT=SCLEX_LOUT SCE_LOUT_
-val SCE_LOUT_DEFAULT=0
-val SCE_LOUT_COMMENT=1
-val SCE_LOUT_NUMBER=2
-val SCE_LOUT_WORD=3
-val SCE_LOUT_WORD2=4
-val SCE_LOUT_WORD3=5
-val SCE_LOUT_WORD4=6
-val SCE_LOUT_STRING=7
-val SCE_LOUT_OPERATOR=8
-val SCE_LOUT_IDENTIFIER=9
-val SCE_LOUT_STRINGEOL=10
-# Lexical states for SCLEX_ESCRIPT
-lex ESCRIPT=SCLEX_ESCRIPT SCE_ESCRIPT_
-val SCE_ESCRIPT_DEFAULT=0
-val SCE_ESCRIPT_COMMENT=1
-val SCE_ESCRIPT_COMMENTLINE=2
-val SCE_ESCRIPT_COMMENTDOC=3
-val SCE_ESCRIPT_NUMBER=4
-val SCE_ESCRIPT_WORD=5
-val SCE_ESCRIPT_STRING=6
-val SCE_ESCRIPT_OPERATOR=7
-val SCE_ESCRIPT_IDENTIFIER=8
-val SCE_ESCRIPT_BRACE=9
-val SCE_ESCRIPT_WORD2=10
-val SCE_ESCRIPT_WORD3=11
-# Lexical states for SCLEX_PS
-lex PS=SCLEX_PS SCE_PS_
-val SCE_PS_DEFAULT=0
-val SCE_PS_COMMENT=1
-val SCE_PS_DSC_COMMENT=2
-val SCE_PS_DSC_VALUE=3
-val SCE_PS_NUMBER=4
-val SCE_PS_NAME=5
-val SCE_PS_KEYWORD=6
-val SCE_PS_LITERAL=7
-val SCE_PS_IMMEVAL=8
-val SCE_PS_PAREN_ARRAY=9
-val SCE_PS_PAREN_DICT=10
-val SCE_PS_PAREN_PROC=11
-val SCE_PS_TEXT=12
-val SCE_PS_HEXSTRING=13
-val SCE_PS_BASE85STRING=14
-val SCE_PS_BADSTRINGCHAR=15
-# Lexical states for SCLEX_NSIS
-lex NSIS=SCLEX_NSIS SCE_NSIS_
-val SCE_NSIS_DEFAULT=0
-val SCE_NSIS_COMMENT=1
-val SCE_NSIS_STRINGDQ=2
-val SCE_NSIS_STRINGLQ=3
-val SCE_NSIS_STRINGRQ=4
-val SCE_NSIS_FUNCTION=5
-val SCE_NSIS_VARIABLE=6
-val SCE_NSIS_LABEL=7
-val SCE_NSIS_USERDEFINED=8
-val SCE_NSIS_SECTIONDEF=9
-val SCE_NSIS_SUBSECTIONDEF=10
-val SCE_NSIS_IFDEFINEDEF=11
-val SCE_NSIS_MACRODEF=12
-val SCE_NSIS_STRINGVAR=13
-val SCE_NSIS_NUMBER=14
-val SCE_NSIS_SECTIONGROUP=15
-val SCE_NSIS_PAGEEX=16
-val SCE_NSIS_FUNCTIONDEF=17
-val SCE_NSIS_COMMENTBOX=18
-# Lexical states for SCLEX_MMIXAL
-lex MMIXAL=SCLEX_MMIXAL SCE_MMIXAL_
-val SCE_MMIXAL_LEADWS=0
-val SCE_MMIXAL_COMMENT=1
-val SCE_MMIXAL_LABEL=2
-val SCE_MMIXAL_OPCODE=3
-val SCE_MMIXAL_OPCODE_PRE=4
-val SCE_MMIXAL_OPCODE_VALID=5
-val SCE_MMIXAL_OPCODE_UNKNOWN=6
-val SCE_MMIXAL_OPCODE_POST=7
-val SCE_MMIXAL_OPERANDS=8
-val SCE_MMIXAL_NUMBER=9
-val SCE_MMIXAL_REF=10
-val SCE_MMIXAL_CHAR=11
-val SCE_MMIXAL_STRING=12
-val SCE_MMIXAL_REGISTER=13
-val SCE_MMIXAL_HEX=14
-val SCE_MMIXAL_OPERATOR=15
-val SCE_MMIXAL_SYMBOL=16
-val SCE_MMIXAL_INCLUDE=17
-# Lexical states for SCLEX_CLW
-lex Clarion=SCLEX_CLW SCE_CLW_
-val SCE_CLW_DEFAULT=0
-val SCE_CLW_LABEL=1
-val SCE_CLW_COMMENT=2
-val SCE_CLW_STRING=3
-val SCE_CLW_USER_IDENTIFIER=4
-val SCE_CLW_INTEGER_CONSTANT=5
-val SCE_CLW_REAL_CONSTANT=6
-val SCE_CLW_PICTURE_STRING=7
-val SCE_CLW_KEYWORD=8
-val SCE_CLW_COMPILER_DIRECTIVE=9
-val SCE_CLW_RUNTIME_EXPRESSIONS=10
-val SCE_CLW_BUILTIN_PROCEDURES_FUNCTION=11
-val SCE_CLW_STRUCTURE_DATA_TYPE=12
-val SCE_CLW_ATTRIBUTE=13
-val SCE_CLW_STANDARD_EQUATE=14
-val SCE_CLW_ERROR=15
-val SCE_CLW_DEPRECATED=16
-# Lexical states for SCLEX_LOT
-lex LOT=SCLEX_LOT SCE_LOT_
-val SCE_LOT_DEFAULT=0
-val SCE_LOT_HEADER=1
-val SCE_LOT_BREAK=2
-val SCE_LOT_SET=3
-val SCE_LOT_PASS=4
-val SCE_LOT_FAIL=5
-val SCE_LOT_ABORT=6
-# Lexical states for SCLEX_YAML
-lex YAML=SCLEX_YAML SCE_YAML_
-val SCE_YAML_DEFAULT=0
-val SCE_YAML_COMMENT=1
-val SCE_YAML_IDENTIFIER=2
-val SCE_YAML_KEYWORD=3
-val SCE_YAML_NUMBER=4
-val SCE_YAML_REFERENCE=5
-val SCE_YAML_DOCUMENT=6
-val SCE_YAML_TEXT=7
-val SCE_YAML_ERROR=8
-val SCE_YAML_OPERATOR=9
-# Lexical states for SCLEX_TEX
-lex TeX=SCLEX_TEX SCE_TEX_
-val SCE_TEX_DEFAULT=0
-val SCE_TEX_SPECIAL=1
-val SCE_TEX_GROUP=2
-val SCE_TEX_SYMBOL=3
-val SCE_TEX_COMMAND=4
-val SCE_TEX_TEXT=5
-lex Metapost=SCLEX_METAPOST SCE_METAPOST_
-val SCE_METAPOST_DEFAULT=0
-val SCE_METAPOST_SPECIAL=1
-val SCE_METAPOST_GROUP=2
-val SCE_METAPOST_SYMBOL=3
-val SCE_METAPOST_COMMAND=4
-val SCE_METAPOST_TEXT=5
-val SCE_METAPOST_EXTRA=6
-# Lexical states for SCLEX_ERLANG
-lex Erlang=SCLEX_ERLANG SCE_ERLANG_
-val SCE_ERLANG_DEFAULT=0
-val SCE_ERLANG_COMMENT=1
-val SCE_ERLANG_VARIABLE=2
-val SCE_ERLANG_NUMBER=3
-val SCE_ERLANG_KEYWORD=4
-val SCE_ERLANG_STRING=5
-val SCE_ERLANG_OPERATOR=6
-val SCE_ERLANG_ATOM=7
-val SCE_ERLANG_FUNCTION_NAME=8
-val SCE_ERLANG_CHARACTER=9
-val SCE_ERLANG_MACRO=10
-val SCE_ERLANG_RECORD=11
-val SCE_ERLANG_PREPROC=12
-val SCE_ERLANG_NODE_NAME=13
-val SCE_ERLANG_COMMENT_FUNCTION=14
-val SCE_ERLANG_COMMENT_MODULE=15
-val SCE_ERLANG_COMMENT_DOC=16
-val SCE_ERLANG_COMMENT_DOC_MACRO=17
-val SCE_ERLANG_ATOM_QUOTED=18
-val SCE_ERLANG_MACRO_QUOTED=19
-val SCE_ERLANG_RECORD_QUOTED=20
-val SCE_ERLANG_NODE_NAME_QUOTED=21
-val SCE_ERLANG_BIFS=22
-val SCE_ERLANG_MODULES=23
-val SCE_ERLANG_MODULES_ATT=24
-val SCE_ERLANG_UNKNOWN=31
-# Lexical states for SCLEX_OCTAVE are identical to MatLab
-lex Octave=SCLEX_OCTAVE SCE_MATLAB_
-# Lexical states for SCLEX_MSSQL
-lex MSSQL=SCLEX_MSSQL SCE_MSSQL_
-val SCE_MSSQL_DEFAULT=0
-val SCE_MSSQL_COMMENT=1
-val SCE_MSSQL_LINE_COMMENT=2
-val SCE_MSSQL_NUMBER=3
-val SCE_MSSQL_STRING=4
-val SCE_MSSQL_OPERATOR=5
-val SCE_MSSQL_IDENTIFIER=6
-val SCE_MSSQL_VARIABLE=7
-val SCE_MSSQL_COLUMN_NAME=8
-val SCE_MSSQL_STATEMENT=9
-val SCE_MSSQL_DATATYPE=10
-val SCE_MSSQL_SYSTABLE=11
-val SCE_MSSQL_GLOBAL_VARIABLE=12
-val SCE_MSSQL_FUNCTION=13
-val SCE_MSSQL_STORED_PROCEDURE=14
-val SCE_MSSQL_DEFAULT_PREF_DATATYPE=15
-val SCE_MSSQL_COLUMN_NAME_2=16
-# Lexical states for SCLEX_VERILOG
-lex Verilog=SCLEX_VERILOG SCE_V_
-val SCE_V_DEFAULT=0
-val SCE_V_COMMENT=1
-val SCE_V_COMMENTLINE=2
-val SCE_V_COMMENTLINEBANG=3
-val SCE_V_NUMBER=4
-val SCE_V_WORD=5
-val SCE_V_STRING=6
-val SCE_V_WORD2=7
-val SCE_V_WORD3=8
-val SCE_V_PREPROCESSOR=9
-val SCE_V_OPERATOR=10
-val SCE_V_IDENTIFIER=11
-val SCE_V_STRINGEOL=12
-val SCE_V_USER=19
-# Lexical states for SCLEX_KIX
-lex Kix=SCLEX_KIX SCE_KIX_
-val SCE_KIX_DEFAULT=0
-val SCE_KIX_COMMENT=1
-val SCE_KIX_STRING1=2
-val SCE_KIX_STRING2=3
-val SCE_KIX_NUMBER=4
-val SCE_KIX_VAR=5
-val SCE_KIX_MACRO=6
-val SCE_KIX_KEYWORD=7
-val SCE_KIX_FUNCTIONS=8
-val SCE_KIX_OPERATOR=9
-val SCE_KIX_IDENTIFIER=31
-# Lexical states for SCLEX_GUI4CLI
-val SCE_GC_DEFAULT=0
-val SCE_GC_COMMENTLINE=1
-val SCE_GC_COMMENTBLOCK=2
-val SCE_GC_GLOBAL=3
-val SCE_GC_EVENT=4
-val SCE_GC_ATTRIBUTE=5
-val SCE_GC_CONTROL=6
-val SCE_GC_COMMAND=7
-val SCE_GC_STRING=8
-val SCE_GC_OPERATOR=9
-# Lexical states for SCLEX_SPECMAN
-lex Specman=SCLEX_SPECMAN SCE_SN_
-val SCE_SN_DEFAULT=0
-val SCE_SN_CODE=1
-val SCE_SN_COMMENTLINE=2
-val SCE_SN_COMMENTLINEBANG=3
-val SCE_SN_NUMBER=4
-val SCE_SN_WORD=5
-val SCE_SN_STRING=6
-val SCE_SN_WORD2=7
-val SCE_SN_WORD3=8
-val SCE_SN_PREPROCESSOR=9
-val SCE_SN_OPERATOR=10
-val SCE_SN_IDENTIFIER=11
-val SCE_SN_STRINGEOL=12
-val SCE_SN_REGEXTAG=13
-val SCE_SN_SIGNAL=14
-val SCE_SN_USER=19
-# Lexical states for SCLEX_AU3
-lex Au3=SCLEX_AU3 SCE_AU3_
-val SCE_AU3_DEFAULT=0
-val SCE_AU3_COMMENT=1
-val SCE_AU3_COMMENTBLOCK=2
-val SCE_AU3_NUMBER=3
-val SCE_AU3_FUNCTION=4
-val SCE_AU3_KEYWORD=5
-val SCE_AU3_MACRO=6
-val SCE_AU3_STRING=7
-val SCE_AU3_OPERATOR=8
-val SCE_AU3_VARIABLE=9
-val SCE_AU3_SENT=10
-val SCE_AU3_PREPROCESSOR=11
-val SCE_AU3_SPECIAL=12
-val SCE_AU3_EXPAND=13
-val SCE_AU3_COMOBJ=14
-val SCE_AU3_UDF=15
-# Lexical states for SCLEX_APDL
-lex APDL=SCLEX_APDL SCE_APDL_
-val SCE_APDL_DEFAULT=0
-val SCE_APDL_COMMENT=1
-val SCE_APDL_COMMENTBLOCK=2
-val SCE_APDL_NUMBER=3
-val SCE_APDL_STRING=4
-val SCE_APDL_OPERATOR=5
-val SCE_APDL_WORD=6
-val SCE_APDL_PROCESSOR=7
-val SCE_APDL_COMMAND=8
-val SCE_APDL_SLASHCOMMAND=9
-val SCE_APDL_STARCOMMAND=10
-val SCE_APDL_ARGUMENT=11
-val SCE_APDL_FUNCTION=12
-# Lexical states for SCLEX_BASH
-lex Bash=SCLEX_BASH SCE_SH_
-val SCE_SH_DEFAULT=0
-val SCE_SH_ERROR=1
-val SCE_SH_COMMENTLINE=2
-val SCE_SH_NUMBER=3
-val SCE_SH_WORD=4
-val SCE_SH_STRING=5
-val SCE_SH_CHARACTER=6
-val SCE_SH_OPERATOR=7
-val SCE_SH_IDENTIFIER=8
-val SCE_SH_SCALAR=9
-val SCE_SH_PARAM=10
-val SCE_SH_BACKTICKS=11
-val SCE_SH_HERE_DELIM=12
-val SCE_SH_HERE_Q=13
-# Lexical states for SCLEX_ASN1
-lex Asn1=SCLEX_ASN1 SCE_ASN1_
-val SCE_ASN1_DEFAULT=0
-val SCE_ASN1_COMMENT=1
-val SCE_ASN1_IDENTIFIER=2
-val SCE_ASN1_STRING=3
-val SCE_ASN1_OID=4
-val SCE_ASN1_SCALAR=5
-val SCE_ASN1_KEYWORD=6
-val SCE_ASN1_ATTRIBUTE=7
-val SCE_ASN1_DESCRIPTOR=8
-val SCE_ASN1_TYPE=9
-val SCE_ASN1_OPERATOR=10
-# Lexical states for SCLEX_VHDL
-lex VHDL=SCLEX_VHDL SCE_VHDL_
-val SCE_VHDL_DEFAULT=0
-val SCE_VHDL_COMMENT=1
-val SCE_VHDL_COMMENTLINEBANG=2
-val SCE_VHDL_NUMBER=3
-val SCE_VHDL_STRING=4
-val SCE_VHDL_OPERATOR=5
-val SCE_VHDL_IDENTIFIER=6
-val SCE_VHDL_STRINGEOL=7
-val SCE_VHDL_KEYWORD=8
-val SCE_VHDL_STDOPERATOR=9
-val SCE_VHDL_ATTRIBUTE=10
-val SCE_VHDL_STDFUNCTION=11
-val SCE_VHDL_STDPACKAGE=12
-val SCE_VHDL_STDTYPE=13
-val SCE_VHDL_USERWORD=14
-# Lexical states for SCLEX_CAML
-lex Caml=SCLEX_CAML SCE_CAML_
-val SCE_CAML_DEFAULT=0
-val SCE_CAML_IDENTIFIER=1
-val SCE_CAML_TAGNAME=2
-val SCE_CAML_KEYWORD=3
-val SCE_CAML_KEYWORD2=4
-val SCE_CAML_KEYWORD3=5
-val SCE_CAML_LINENUM=6
-val SCE_CAML_OPERATOR=7
-val SCE_CAML_NUMBER=8
-val SCE_CAML_CHAR=9
-val SCE_CAML_WHITE=10
-val SCE_CAML_STRING=11
-val SCE_CAML_COMMENT=12
-val SCE_CAML_COMMENT1=13
-val SCE_CAML_COMMENT2=14
-val SCE_CAML_COMMENT3=15
-# Lexical states for SCLEX_HASKELL
-lex Haskell=SCLEX_HASKELL SCE_HA_
-val SCE_HA_DEFAULT=0
-val SCE_HA_IDENTIFIER=1
-val SCE_HA_KEYWORD=2
-val SCE_HA_NUMBER=3
-val SCE_HA_STRING=4
-val SCE_HA_CHARACTER=5
-val SCE_HA_CLASS=6
-val SCE_HA_MODULE=7
-val SCE_HA_CAPITAL=8
-val SCE_HA_DATA=9
-val SCE_HA_IMPORT=10
-val SCE_HA_OPERATOR=11
-val SCE_HA_INSTANCE=12
-val SCE_HA_COMMENTLINE=13
-val SCE_HA_COMMENTBLOCK=14
-val SCE_HA_COMMENTBLOCK2=15
-val SCE_HA_COMMENTBLOCK3=16
-# Lexical states of SCLEX_TADS3
-lex TADS3=SCLEX_TADS3 SCE_T3_
-val SCE_T3_DEFAULT=0
-val SCE_T3_X_DEFAULT=1
-val SCE_T3_PREPROCESSOR=2
-val SCE_T3_BLOCK_COMMENT=3
-val SCE_T3_LINE_COMMENT=4
-val SCE_T3_OPERATOR=5
-val SCE_T3_KEYWORD=6
-val SCE_T3_NUMBER=7
-val SCE_T3_IDENTIFIER=8
-val SCE_T3_S_STRING=9
-val SCE_T3_D_STRING=10
-val SCE_T3_X_STRING=11
-val SCE_T3_LIB_DIRECTIVE=12
-val SCE_T3_MSG_PARAM=13
-val SCE_T3_HTML_TAG=14
-val SCE_T3_HTML_DEFAULT=15
-val SCE_T3_HTML_STRING=16
-val SCE_T3_USER1=17
-val SCE_T3_USER2=18
-val SCE_T3_USER3=19
-val SCE_T3_BRACE=20
-# Lexical states for SCLEX_REBOL
-lex Rebol=SCLEX_REBOL SCE_REBOL_
-val SCE_REBOL_DEFAULT=0
-val SCE_REBOL_COMMENTLINE=1
-val SCE_REBOL_COMMENTBLOCK=2
-val SCE_REBOL_PREFACE=3
-val SCE_REBOL_OPERATOR=4
-val SCE_REBOL_CHARACTER=5
-val SCE_REBOL_QUOTEDSTRING=6
-val SCE_REBOL_BRACEDSTRING=7
-val SCE_REBOL_NUMBER=8
-val SCE_REBOL_PAIR=9
-val SCE_REBOL_TUPLE=10
-val SCE_REBOL_BINARY=11
-val SCE_REBOL_MONEY=12
-val SCE_REBOL_ISSUE=13
-val SCE_REBOL_TAG=14
-val SCE_REBOL_FILE=15
-val SCE_REBOL_EMAIL=16
-val SCE_REBOL_URL=17
-val SCE_REBOL_DATE=18
-val SCE_REBOL_TIME=19
-val SCE_REBOL_IDENTIFIER=20
-val SCE_REBOL_WORD=21
-val SCE_REBOL_WORD2=22
-val SCE_REBOL_WORD3=23
-val SCE_REBOL_WORD4=24
-val SCE_REBOL_WORD5=25
-val SCE_REBOL_WORD6=26
-val SCE_REBOL_WORD7=27
-val SCE_REBOL_WORD8=28
-# Lexical states for SCLEX_SQL
-lex SQL=SCLEX_SQL SCE_SQL_
-val SCE_SQL_DEFAULT=0
-val SCE_SQL_COMMENT=1
-val SCE_SQL_COMMENTLINE=2
-val SCE_SQL_COMMENTDOC=3
-val SCE_SQL_NUMBER=4
-val SCE_SQL_WORD=5
-val SCE_SQL_STRING=6
-val SCE_SQL_CHARACTER=7
-val SCE_SQL_SQLPLUS=8
-val SCE_SQL_SQLPLUS_PROMPT=9
-val SCE_SQL_OPERATOR=10
-val SCE_SQL_IDENTIFIER=11
-val SCE_SQL_SQLPLUS_COMMENT=13
-val SCE_SQL_COMMENTLINEDOC=15
-val SCE_SQL_WORD2=16
-val SCE_SQL_COMMENTDOCKEYWORD=17
-val SCE_SQL_COMMENTDOCKEYWORDERROR=18
-val SCE_SQL_USER1=19
-val SCE_SQL_USER2=20
-val SCE_SQL_USER3=21
-val SCE_SQL_USER4=22
-val SCE_SQL_QUOTEDIDENTIFIER=23
-# Lexical states for SCLEX_SMALLTALK
-lex Smalltalk=SCLEX_SMALLTALK SCE_ST_
-val SCE_ST_DEFAULT=0
-val SCE_ST_STRING=1
-val SCE_ST_NUMBER=2
-val SCE_ST_COMMENT=3
-val SCE_ST_SYMBOL=4
-val SCE_ST_BINARY=5
-val SCE_ST_BOOL=6
-val SCE_ST_SELF=7
-val SCE_ST_SUPER=8
-val SCE_ST_NIL=9
-val SCE_ST_GLOBAL=10
-val SCE_ST_RETURN=11
-val SCE_ST_SPECIAL=12
-val SCE_ST_KWSEND=13
-val SCE_ST_ASSIGN=14
-val SCE_ST_CHARACTER=15
-val SCE_ST_SPEC_SEL=16
-# Lexical states for SCLEX_FLAGSHIP (clipper)
-lex FlagShip=SCLEX_FLAGSHIP SCE_FS_
-val SCE_FS_DEFAULT=0
-val SCE_FS_COMMENT=1
-val SCE_FS_COMMENTLINE=2
-val SCE_FS_COMMENTDOC=3
-val SCE_FS_COMMENTLINEDOC=4
-val SCE_FS_COMMENTDOCKEYWORD=5
-val SCE_FS_COMMENTDOCKEYWORDERROR=6
-val SCE_FS_KEYWORD=7
-val SCE_FS_KEYWORD2=8
-val SCE_FS_KEYWORD3=9
-val SCE_FS_KEYWORD4=10
-val SCE_FS_NUMBER=11
-val SCE_FS_STRING=12
-val SCE_FS_PREPROCESSOR=13
-val SCE_FS_OPERATOR=14
-val SCE_FS_IDENTIFIER=15
-val SCE_FS_DATE=16
-val SCE_FS_STRINGEOL=17
-val SCE_FS_CONSTANT=18
-val SCE_FS_WORDOPERATOR=19
-val SCE_FS_DISABLEDCODE=20
-val SCE_FS_DEFAULT_C=21
-val SCE_FS_COMMENTDOC_C=22
-val SCE_FS_COMMENTLINEDOC_C=23
-val SCE_FS_KEYWORD_C=24
-val SCE_FS_KEYWORD2_C=25
-val SCE_FS_NUMBER_C=26
-val SCE_FS_STRING_C=27
-val SCE_FS_PREPROCESSOR_C=28
-val SCE_FS_OPERATOR_C=29
-val SCE_FS_IDENTIFIER_C=30
-val SCE_FS_STRINGEOL_C=31
-# Lexical states for SCLEX_CSOUND
-lex Csound=SCLEX_CSOUND SCE_CSOUND_
-val SCE_CSOUND_DEFAULT=0
-val SCE_CSOUND_COMMENT=1
-val SCE_CSOUND_NUMBER=2
-val SCE_CSOUND_OPERATOR=3
-val SCE_CSOUND_INSTR=4
-val SCE_CSOUND_IDENTIFIER=5
-val SCE_CSOUND_OPCODE=6
-val SCE_CSOUND_HEADERSTMT=7
-val SCE_CSOUND_USERKEYWORD=8
-val SCE_CSOUND_COMMENTBLOCK=9
-val SCE_CSOUND_PARAM=10
-val SCE_CSOUND_ARATE_VAR=11
-val SCE_CSOUND_KRATE_VAR=12
-val SCE_CSOUND_IRATE_VAR=13
-val SCE_CSOUND_GLOBAL_VAR=14
-val SCE_CSOUND_STRINGEOL=15
-# Lexical states for SCLEX_INNOSETUP
-lex Inno=SCLEX_INNOSETUP SCE_INNO_
-val SCE_INNO_DEFAULT=0
-val SCE_INNO_COMMENT=1
-val SCE_INNO_KEYWORD=2
-val SCE_INNO_PARAMETER=3
-val SCE_INNO_SECTION=4
-val SCE_INNO_PREPROC=5
-val SCE_INNO_INLINE_EXPANSION=6
-val SCE_INNO_COMMENT_PASCAL=7
-val SCE_INNO_KEYWORD_PASCAL=8
-val SCE_INNO_KEYWORD_USER=9
-val SCE_INNO_STRING_DOUBLE=10
-val SCE_INNO_STRING_SINGLE=11
-val SCE_INNO_IDENTIFIER=12
-# Lexical states for SCLEX_OPAL
-lex Opal=SCLEX_OPAL SCE_OPAL_
-val SCE_OPAL_SPACE=0
-val SCE_OPAL_COMMENT_BLOCK=1
-val SCE_OPAL_COMMENT_LINE=2
-val SCE_OPAL_INTEGER=3
-val SCE_OPAL_KEYWORD=4
-val SCE_OPAL_SORT=5
-val SCE_OPAL_STRING=6
-val SCE_OPAL_PAR=7
-val SCE_OPAL_BOOL_CONST=8
-val SCE_OPAL_DEFAULT=32
-# Lexical states for SCLEX_SPICE
-lex Spice=SCLEX_SPICE SCE_SPICE_
-val SCE_SPICE_DEFAULT=0
-val SCE_SPICE_IDENTIFIER=1
-val SCE_SPICE_KEYWORD=2
-val SCE_SPICE_KEYWORD2=3
-val SCE_SPICE_KEYWORD3=4
-val SCE_SPICE_NUMBER=5
-val SCE_SPICE_DELIMITER=6
-val SCE_SPICE_VALUE=7
-val SCE_SPICE_COMMENTLINE=8
-# Lexical states for SCLEX_CMAKE
-lex CMAKE=SCLEX_CMAKE SCE_CMAKE_
-val SCE_CMAKE_DEFAULT=0
-val SCE_CMAKE_COMMENT=1
-val SCE_CMAKE_STRINGDQ=2
-val SCE_CMAKE_STRINGLQ=3
-val SCE_CMAKE_STRINGRQ=4
-val SCE_CMAKE_COMMANDS=5
-val SCE_CMAKE_PARAMETERS=6
-val SCE_CMAKE_VARIABLE=7
-val SCE_CMAKE_USERDEFINED=8
-val SCE_CMAKE_WHILEDEF=9
-val SCE_CMAKE_FOREACHDEF=10
-val SCE_CMAKE_IFDEFINEDEF=11
-val SCE_CMAKE_MACRODEF=12
-val SCE_CMAKE_STRINGVAR=13
-val SCE_CMAKE_NUMBER=14
-# Lexical states for SCLEX_GAP
-lex Gap=SCLEX_GAP SCE_GAP_
-val SCE_GAP_DEFAULT=0
-val SCE_GAP_IDENTIFIER=1
-val SCE_GAP_KEYWORD=2
-val SCE_GAP_KEYWORD2=3
-val SCE_GAP_KEYWORD3=4
-val SCE_GAP_KEYWORD4=5
-val SCE_GAP_STRING=6
-val SCE_GAP_CHAR=7
-val SCE_GAP_OPERATOR=8
-val SCE_GAP_COMMENT=9
-val SCE_GAP_NUMBER=10
-val SCE_GAP_STRINGEOL=11
-# Lexical state for SCLEX_PLM
-lex PLM=SCLEX_PLM SCE_PLM_
-val SCE_PLM_DEFAULT=0
-val SCE_PLM_COMMENT=1
-val SCE_PLM_STRING=2
-val SCE_PLM_NUMBER=3
-val SCE_PLM_IDENTIFIER=4
-val SCE_PLM_OPERATOR=5
-val SCE_PLM_CONTROL=6
-val SCE_PLM_KEYWORD=7
-# Lexical state for SCLEX_PROGRESS
-lex Progress=SCLEX_PROGRESS SCE_4GL_
-val SCE_4GL_DEFAULT=0
-val SCE_4GL_NUMBER=1
-val SCE_4GL_WORD=2
-val SCE_4GL_STRING=3
-val SCE_4GL_CHARACTER=4
-val SCE_4GL_PREPROCESSOR=5
-val SCE_4GL_OPERATOR=6
-val SCE_4GL_IDENTIFIER=7
-val SCE_4GL_BLOCK=8
-val SCE_4GL_END=9
-val SCE_4GL_COMMENT1=10
-val SCE_4GL_COMMENT2=11
-val SCE_4GL_COMMENT3=12
-val SCE_4GL_COMMENT4=13
-val SCE_4GL_COMMENT5=14
-val SCE_4GL_COMMENT6=15
-val SCE_4GL_DEFAULT_=16
-val SCE_4GL_NUMBER_=17
-val SCE_4GL_WORD_=18
-val SCE_4GL_STRING_=19
-val SCE_4GL_CHARACTER_=20
-val SCE_4GL_PREPROCESSOR_=21
-val SCE_4GL_OPERATOR_=22
-val SCE_4GL_IDENTIFIER_=23
-val SCE_4GL_BLOCK_=24
-val SCE_4GL_END_=25
-val SCE_4GL_COMMENT1_=26
-val SCE_4GL_COMMENT2_=27
-val SCE_4GL_COMMENT3_=28
-val SCE_4GL_COMMENT4_=29
-val SCE_4GL_COMMENT5_=30
-val SCE_4GL_COMMENT6_=31
-# Lexical states for SCLEX_ABAQUS
-lex ABAQUS=SCLEX_ABAQUS SCE_ABAQUS_
-val SCE_ABAQUS_DEFAULT=0
-val SCE_ABAQUS_COMMENT=1
-val SCE_ABAQUS_COMMENTBLOCK=2
-val SCE_ABAQUS_NUMBER=3
-val SCE_ABAQUS_STRING=4
-val SCE_ABAQUS_OPERATOR=5
-val SCE_ABAQUS_WORD=6
-val SCE_ABAQUS_PROCESSOR=7
-val SCE_ABAQUS_COMMAND=8
-val SCE_ABAQUS_SLASHCOMMAND=9
-val SCE_ABAQUS_STARCOMMAND=10
-val SCE_ABAQUS_ARGUMENT=11
-val SCE_ABAQUS_FUNCTION=12
-# Lexical states for SCLEX_ASYMPTOTE
-lex Asymptote=SCLEX_ASYMPTOTE SCE_ASY_
-val SCE_ASY_DEFAULT=0
-val SCE_ASY_COMMENT=1
-val SCE_ASY_COMMENTLINE=2
-val SCE_ASY_NUMBER=3
-val SCE_ASY_WORD=4
-val SCE_ASY_STRING=5
-val SCE_ASY_CHARACTER=6
-val SCE_ASY_OPERATOR=7
-val SCE_ASY_IDENTIFIER=8
-val SCE_ASY_STRINGEOL=9
-val SCE_ASY_COMMENTLINEDOC=10
-val SCE_ASY_WORD2=11
-# Lexical states for SCLEX_R
-lex R=SCLEX_R SCE_R_
-val SCE_R_DEFAULT=0
-val SCE_R_COMMENT=1
-val SCE_R_KWORD=2
-val SCE_R_BASEKWORD=3
-val SCE_R_OTHERKWORD=4
-val SCE_R_NUMBER=5
-val SCE_R_STRING=6
-val SCE_R_STRING2=7
-val SCE_R_OPERATOR=8
-val SCE_R_IDENTIFIER=9
-val SCE_R_INFIX=10
-val SCE_R_INFIXEOL=11
-# Lexical state for SCLEX_MAGIKSF
-lex MagikSF=SCLEX_MAGIKSF SCE_MAGIK_
-val SCE_MAGIK_DEFAULT=0
-val SCE_MAGIK_COMMENT=1
-val SCE_MAGIK_HYPER_COMMENT=16
-val SCE_MAGIK_STRING=2
-val SCE_MAGIK_CHARACTER=3
-val SCE_MAGIK_NUMBER=4
-val SCE_MAGIK_IDENTIFIER=5
-val SCE_MAGIK_OPERATOR=6
-val SCE_MAGIK_FLOW=7
-val SCE_MAGIK_CONTAINER=8
-val SCE_MAGIK_BRACKET_BLOCK=9
-val SCE_MAGIK_BRACE_BLOCK=10
-val SCE_MAGIK_SQBRACKET_BLOCK=11
-val SCE_MAGIK_UNKNOWN_KEYWORD=12
-val SCE_MAGIK_KEYWORD=13
-val SCE_MAGIK_PRAGMA=14
-val SCE_MAGIK_SYMBOL=15
-# Lexical state for SCLEX_POWERSHELL
-lex PowerShell=SCLEX_POWERSHELL SCE_POWERSHELL_
-val SCE_POWERSHELL_DEFAULT=0
-val SCE_POWERSHELL_COMMENT=1
-val SCE_POWERSHELL_STRING=2
-val SCE_POWERSHELL_CHARACTER=3
-val SCE_POWERSHELL_NUMBER=4
-val SCE_POWERSHELL_VARIABLE=5
-val SCE_POWERSHELL_OPERATOR=6
-val SCE_POWERSHELL_IDENTIFIER=7
-val SCE_POWERSHELL_KEYWORD=8
-val SCE_POWERSHELL_CMDLET=9
-val SCE_POWERSHELL_ALIAS=10
-val SCE_POWERSHELL_FUNCTION=11
-val SCE_POWERSHELL_USER1=12
-val SCE_POWERSHELL_COMMENTSTREAM=13
-# Lexical state for SCLEX_MYSQL
-lex MySQL=SCLEX_MYSQL SCE_MYSQL_
-val SCE_MYSQL_DEFAULT=0
-val SCE_MYSQL_COMMENT=1
-val SCE_MYSQL_COMMENTLINE=2
-val SCE_MYSQL_VARIABLE=3
-val SCE_MYSQL_SYSTEMVARIABLE=4
-val SCE_MYSQL_KNOWNSYSTEMVARIABLE=5
-val SCE_MYSQL_NUMBER=6
-val SCE_MYSQL_MAJORKEYWORD=7
-val SCE_MYSQL_KEYWORD=8
-val SCE_MYSQL_DATABASEOBJECT=9
-val SCE_MYSQL_PROCEDUREKEYWORD=10
-val SCE_MYSQL_STRING=11
-val SCE_MYSQL_SQSTRING=12
-val SCE_MYSQL_DQSTRING=13
-val SCE_MYSQL_OPERATOR=14
-val SCE_MYSQL_FUNCTION=15
-val SCE_MYSQL_IDENTIFIER=16
-val SCE_MYSQL_QUOTEDIDENTIFIER=17
-val SCE_MYSQL_USER1=18
-val SCE_MYSQL_USER2=19
-val SCE_MYSQL_USER3=20
-val SCE_MYSQL_HIDDENCOMMAND=21
-# Lexical state for SCLEX_PO
-lex Po=SCLEX_PO SCE_PO_
-val SCE_PO_DEFAULT=0
-val SCE_PO_COMMENT=1
-val SCE_PO_MSGID=2
-val SCE_PO_MSGID_TEXT=3
-val SCE_PO_MSGSTR=4
-val SCE_PO_MSGSTR_TEXT=5
-val SCE_PO_MSGCTXT=6
-val SCE_PO_MSGCTXT_TEXT=7
-val SCE_PO_FUZZY=8
-# Lexical states for SCLEX_PASCAL
-lex Pascal=SCLEX_PASCAL SCE_PAS_
-val SCE_PAS_DEFAULT=0
-val SCE_PAS_IDENTIFIER=1
-val SCE_PAS_COMMENT=2
-val SCE_PAS_COMMENT2=3
-val SCE_PAS_COMMENTLINE=4
-val SCE_PAS_PREPROCESSOR=5
-val SCE_PAS_PREPROCESSOR2=6
-val SCE_PAS_NUMBER=7
-val SCE_PAS_HEXNUMBER=8
-val SCE_PAS_WORD=9
-val SCE_PAS_STRING=10
-val SCE_PAS_STRINGEOL=11
-val SCE_PAS_CHARACTER=12
-val SCE_PAS_OPERATOR=13
-val SCE_PAS_ASM=14
-# Lexical state for SCLEX_SORCUS
-lex SORCUS=SCLEX_SORCUS SCE_SORCUS_
-val SCE_SORCUS_DEFAULT=0
-val SCE_SORCUS_COMMAND=1
-val SCE_SORCUS_PARAMETER=2
-val SCE_SORCUS_COMMENTLINE=3
-val SCE_SORCUS_STRING=4
-val SCE_SORCUS_STRINGEOL=5
-val SCE_SORCUS_IDENTIFIER=6
-val SCE_SORCUS_OPERATOR=7
-val SCE_SORCUS_NUMBER=8
-val SCE_SORCUS_CONSTANT=9
-# Lexical state for SCLEX_POWERPRO
-lex PowerPro=SCLEX_POWERPRO SCE_POWERPRO_
-val SCE_POWERPRO_DEFAULT=0
-val SCE_POWERPRO_COMMENTBLOCK=1
-val SCE_POWERPRO_COMMENTLINE=2
-val SCE_POWERPRO_NUMBER=3
-val SCE_POWERPRO_WORD=4
-val SCE_POWERPRO_WORD2=5
-val SCE_POWERPRO_WORD3=6
-val SCE_POWERPRO_WORD4=7
-val SCE_POWERPRO_DOUBLEQUOTEDSTRING=8
-val SCE_POWERPRO_SINGLEQUOTEDSTRING=9
-val SCE_POWERPRO_LINECONTINUE=10
-val SCE_POWERPRO_OPERATOR=11
-val SCE_POWERPRO_IDENTIFIER=12
-val SCE_POWERPRO_STRINGEOL=13
-val SCE_POWERPRO_VERBATIM=14
-val SCE_POWERPRO_ALTQUOTE=15
-val SCE_POWERPRO_FUNCTION=16
-# Lexical states for SCLEX_SML
-lex SML=SCLEX_SML SCE_SML_
-val SCE_SML_DEFAULT=0
-val SCE_SML_IDENTIFIER=1
-val SCE_SML_TAGNAME=2
-val SCE_SML_KEYWORD=3
-val SCE_SML_KEYWORD2=4
-val SCE_SML_KEYWORD3=5
-val SCE_SML_LINENUM=6
-val SCE_SML_OPERATOR=7
-val SCE_SML_NUMBER=8
-val SCE_SML_CHAR=9
-val SCE_SML_STRING=11
-val SCE_SML_COMMENT=12
-val SCE_SML_COMMENT1=13
-val SCE_SML_COMMENT2=14
-val SCE_SML_COMMENT3=15
-# Lexical state for SCLEX_MARKDOWN
-lex Markdown=SCLEX_MARKDOWN SCE_MARKDOWN_
-val SCE_MARKDOWN_DEFAULT=0
-val SCE_MARKDOWN_LINE_BEGIN=1
-val SCE_MARKDOWN_STRONG1=2
-val SCE_MARKDOWN_STRONG2=3
-val SCE_MARKDOWN_EM1=4
-val SCE_MARKDOWN_EM2=5
-val SCE_MARKDOWN_HEADER1=6
-val SCE_MARKDOWN_HEADER2=7
-val SCE_MARKDOWN_HEADER3=8
-val SCE_MARKDOWN_HEADER4=9
-val SCE_MARKDOWN_HEADER5=10
-val SCE_MARKDOWN_HEADER6=11
-val SCE_MARKDOWN_PRECHAR=12
-val SCE_MARKDOWN_ULIST_ITEM=13
-val SCE_MARKDOWN_OLIST_ITEM=14
-val SCE_MARKDOWN_BLOCKQUOTE=15
-val SCE_MARKDOWN_STRIKEOUT=16
-val SCE_MARKDOWN_HRULE=17
-val SCE_MARKDOWN_LINK=18
-val SCE_MARKDOWN_CODE=19
-val SCE_MARKDOWN_CODE2=20
-val SCE_MARKDOWN_CODEBK=21
-# Lexical state for SCLEX_TXT2TAGS
-lex Txt2tags=SCLEX_TXT2TAGS SCE_TXT2TAGS_
-val SCE_TXT2TAGS_DEFAULT=0
-val SCE_TXT2TAGS_LINE_BEGIN=1
-val SCE_TXT2TAGS_STRONG1=2
-val SCE_TXT2TAGS_STRONG2=3
-val SCE_TXT2TAGS_EM1=4
-val SCE_TXT2TAGS_EM2=5
-val SCE_TXT2TAGS_HEADER1=6
-val SCE_TXT2TAGS_HEADER2=7
-val SCE_TXT2TAGS_HEADER3=8
-val SCE_TXT2TAGS_HEADER4=9
-val SCE_TXT2TAGS_HEADER5=10
-val SCE_TXT2TAGS_HEADER6=11
-val SCE_TXT2TAGS_PRECHAR=12
-val SCE_TXT2TAGS_ULIST_ITEM=13
-val SCE_TXT2TAGS_OLIST_ITEM=14
-val SCE_TXT2TAGS_BLOCKQUOTE=15
-val SCE_TXT2TAGS_STRIKEOUT=16
-val SCE_TXT2TAGS_HRULE=17
-val SCE_TXT2TAGS_LINK=18
-val SCE_TXT2TAGS_CODE=19
-val SCE_TXT2TAGS_CODE2=20
-val SCE_TXT2TAGS_CODEBK=21
-val SCE_TXT2TAGS_COMMENT=22
-val SCE_TXT2TAGS_OPTION=23
-val SCE_TXT2TAGS_PREPROC=24
-val SCE_TXT2TAGS_POSTPROC=25
+# Lexical states for SCLEX_LPEG
+lex LPEG=SCLEX_LPEG SCE_LPEG_
 
 # Events
 
diff -r ffde119d297e lexers/LexLPeg.cxx
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ scintilla/lexers/LexLPeg.cxx	Tue Aug 17 00:13:24 2010 -0400
@@ -0,0 +1,469 @@
+/*
+	Mitchell's Lua-powered dynamic lexer
+	Copyright (c) 2006-2010 Mitchell mitchell<att>caladbolg.net.
+
+	Permission to use, copy, modify, and distribute this file is granted,
+	provided credit is given to Mitchell.
+
+	Implementation:
+	Only one lexer is used: SCLEX_LPEG. Any Scintilla calls to SetLexer or
+	SetLexerLanguage create a new Lua state and pass the desired lexer name to
+	LexLPeg's InitDoc function where it is loaded. Afterwards, the Scintilla
+	styles are read and set. The dynamic lexer is now ready to style the text
+	when Scintilla calls ColouriseDoc.
+	Folding works similarly.
+	Lexer documentation can be read in /lexers/lexer.lua
+*/
+
+#include <assert.h> // for Accessor.h
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "Platform.h"
+
+#include "ILexer.h"
+#include "Scintilla.h"
+#include "SciLexer.h"
+
+#include "PropSetSimple.h"
+#include "LexAccessor.h"
+#include "Accessor.h"
+#include "LexerModule.h"
+
+extern "C" {
+#include <lua.h>
+#include <lualib.h>
+#include <lauxlib.h>
+}
+
+#if PLAT_WIN || PLAT_GTK_WIN32
+#define strcasecmp _stricmp
+#endif
+
+#define streq(s1, s2) (strcasecmp((s1), (s2)) == 0)
+
+#ifdef SCI_NAMESPACE
+using namespace Scintilla;
+#endif
+
+/**
+ * Prints a Lua error message.
+ * If an error message is not specified, the Lua error message at the top of the
+ * stack is used and the stack is subsequently cleared.
+ * @return false
+ */
+static bool l_error(lua_State *L, const char *str=NULL) {
+	Platform::DebugPrintf("Lua Error: %s.\n", str ? str : lua_tostring(L, -1));
+	lua_settop(L, 0);
+	return false;
+}
+
+/**
+ * Retrieves the style at a position.
+ * Lua interface: StyleAt(pos)
+ * @param pos The position to get the style for.
+ */
+static int lua_style_at(lua_State *L) {
+	lua_getfield(L, LUA_REGISTRYINDEX, "styler");
+	LexAccessor *styler = static_cast<LexAccessor *>(lua_touserdata(L, -1));
+	lua_pushnumber(L, styler->StyleAt(luaL_checkinteger(L, 1) - 1));
+	return 1;
+}
+
+/**
+ * Gets an integer property value.
+ * Lua interface: GetProperty(key [, default])
+ * @param key The property key.
+ * @param default Optional default value.
+ * @return integer value of the property.
+ */
+static int lua_get_property(lua_State *L) {
+	lua_getfield(L, LUA_REGISTRYINDEX, "props");
+	PropSetSimple *props = static_cast<PropSetSimple *>(lua_touserdata(L, -1));
+	lua_pushnumber(L, props->GetInt(luaL_checkstring(L, 1),
+								 (lua_gettop(L) > 1) ? luaL_checkinteger(L, 2) : 0));
+	return 1;
+}
+
+/**
+ * Gets the fold level of a line number.
+ * Lua interface: GetFoldLevel(line_number)
+ * @param line_number The line number to get the fold level of.
+ * @return the integer fold level.
+ */
+static int lua_get_fold_level(lua_State *L) {
+	lua_getfield(L, LUA_REGISTRYINDEX, "styler");
+	LexAccessor *styler = static_cast<LexAccessor *>(lua_touserdata(L, -1));
+	lua_pushnumber(L, styler->LevelAt(luaL_checkinteger(L, 1)));
+	return 1;
+}
+
+/**
+ * Gets the indent amount of text on a specified line.
+ * Lua interface: GetIndentAmount(line_number)
+ * @param line_number The line number to get the indent amount of.
+ */
+static int lua_get_indent_amount(lua_State *L) {
+	int f = 0;
+	lua_getfield(L, LUA_REGISTRYINDEX, "styler");
+	Accessor *styler = static_cast<Accessor *>(lua_touserdata(L, -1));
+	lua_pushnumber(L, styler->IndentAmount(luaL_checkinteger(L, 1), &f, NULL));
+	return 1;
+}
+
+#define l_openlib(f, s) \
+	{ lua_pushcfunction(L, f); lua_pushstring(L, s); lua_call(L, 1, 0); }
+#define l_setconst(c, s) \
+	{ lua_pushnumber(L, c); lua_setfield(L, LUA_GLOBALSINDEX, s); }
+#define SS(m, l) Platform::SendScintilla(wid, m, style_num, l)
+
+class LexerLPeg : public ILexer {
+	lua_State *L;
+	PropSetSimple props;
+	WindowID wid;
+	bool reinit;
+	bool multilang;
+private:
+	bool Init() {
+		char p1[50], p2[FILENAME_MAX], p3[FILENAME_MAX], p4[FILENAME_MAX];
+		props.GetExpanded("lexer.name", p1);
+		props.GetExpanded("lexer.lua.home", p2);
+		props.GetExpanded("lexer.lua.color.theme", p3);
+		props.GetExpanded("lexer.lua.script", p4);
+		if (*p1 == 0 || *p2 == 0 || *p3 == 0 || *p4 == 0) return false;
+
+		// Initialize or reinitialize Lua.
+		if (L) lua_close(L);
+		L = lua_open();
+		if (!L) {
+			Platform::DebugPrintf("Lua failed to initialize.\n");
+			return false;
+		}
+
+		// Set variables from properties.
+		lua_pushstring(L, p1);
+		lua_setfield(L, LUA_REGISTRYINDEX, "lexer_name");
+		lua_pushstring(L, p2);
+		lua_setglobal(L, "_LEXERHOME");
+		lua_pushstring(L, p3);
+		lua_setglobal(L, "_THEME");
+		lua_pushstring(L, p4);
+		lua_setfield(L, LUA_REGISTRYINDEX, "lexer_lua");
+
+		// Set variables from platform.
+#if PLAT_WIN || PLAT_GTK_WIN32
+		lua_pushboolean(L, 1);
+		lua_setglobal(L, "WIN32");
+#endif
+#ifdef MAC
+		lua_pushboolean(L, 1);
+		lua_setglobal(L, "MAC");
+#endif
+#if PLAT_GTK || PLAT_GTK_WIN32
+		lua_pushboolean(L, 1);
+		lua_setglobal(L, "GTK");
+#endif
+
+		// Load Lua libraries.
+		l_openlib(luaopen_base, "");
+		l_openlib(luaopen_table, LUA_TABLIBNAME);
+		l_openlib(luaopen_string, LUA_STRLIBNAME);
+		l_openlib(luaopen_package, LUA_LOADLIBNAME);
+		l_openlib(luaopen_lpeg, LUA_LPEGNAME);
+
+		// Register functions.
+		lua_register(L, "GetStyleAt", lua_style_at);
+		lua_register(L, "GetProperty", lua_get_property);
+		lua_register(L, "GetFoldLevel", lua_get_fold_level);
+		lua_register(L, "GetIndentAmount", lua_get_indent_amount);
+
+		// Register constants.
+		l_setconst(SC_FOLDLEVELBASE, "SC_FOLDLEVELBASE");
+		l_setconst(SC_FOLDLEVELWHITEFLAG, "SC_FOLDLEVELWHITEFLAG");
+		l_setconst(SC_FOLDLEVELHEADERFLAG, "SC_FOLDLEVELHEADERFLAG");
+		l_setconst(SC_FOLDLEVELNUMBERMASK, "SC_FOLDLEVELNUMBERMASK");
+
+		// Load lexer.lua.
+		lua_getfield(L, LUA_REGISTRYINDEX, "lexer_lua");
+		const char *lexer_lua = lua_tostring(L, -1);
+		lua_pop(L, 1); // lexer_lua
+		if (strlen(lexer_lua) == 0) return false;
+		if (luaL_dofile(L, lexer_lua) != 0) return l_error(L);
+
+		// Load lexer tokens, styles, etc.
+		lua_getglobal(L, "lexer");
+		lua_getfield(L, -1, "load");
+		if (lua_isfunction(L, -1)) {
+			lua_getfield(L, LUA_REGISTRYINDEX, "lexer_name");
+			if (lua_pcall(L, 1, 0, 0) != 0) return l_error(L);
+		} else return l_error(L, "lexer.load not found");
+		lua_pop(L, 1); // lexer
+
+		// Setup Scintilla styles from loaded lexer styles.
+		lua_getglobal(L, "_LEXER");
+		if (!lua_istable(L, -1)) return l_error(L, "'_LEXER' table not found");
+		lua_getfield(L, -1, "_STYLES");
+		if (!lua_istable(L, -1))
+			return l_error(L, "'_LEXER._STYLES' table not found");
+		bool cleared = false;
+		lua_pushinteger(L, 32); // style_default
+		lua_rawgeti(L, -2, 32);
+		do {
+			if (lua_isnumber(L, -2) && lua_istable(L, -1)) {
+				int style_num = lua_tointeger(L, -2); // [num] = { properties }
+				lua_pushnil(L);
+				while (lua_next(L, -2)) { // properties table
+					const char *prop = lua_tostring(L, -2);
+					if (streq(prop, "font"))
+						SS(SCI_STYLESETFONT, reinterpret_cast<long>(lua_tostring(L, -1)));
+					else if (streq(prop, "size"))
+						SS(SCI_STYLESETSIZE, static_cast<int>(lua_tointeger(L, -1)));
+					else if (streq(prop, "bold"))
+						SS(SCI_STYLESETBOLD, lua_toboolean(L, -1));
+					else if (streq(prop, "italic"))
+						SS(SCI_STYLESETITALIC, lua_toboolean(L, -1));
+					else if (streq(prop, "underline"))
+						SS(SCI_STYLESETUNDERLINE, lua_toboolean(L, -1));
+					else if (streq(prop, "fore"))
+						SS(SCI_STYLESETFORE, static_cast<int>(lua_tointeger(L, -1)));
+					else if (streq(prop, "back"))
+						SS(SCI_STYLESETBACK, static_cast<int>(lua_tointeger(L, -1)));
+					else if (streq(prop, "eolfilled"))
+						SS(SCI_STYLESETEOLFILLED, lua_toboolean(L, -1));
+					else if (streq(prop, "characterset"))
+						SS(SCI_STYLESETCHARACTERSET,
+						   static_cast<int>(lua_tointeger(L, -1)));
+					else if (streq(prop, "case"))
+						SS(SCI_STYLESETCASE, static_cast<int>(lua_tointeger(L, -1)));
+					else if (streq(prop, "visible"))
+						SS(SCI_STYLESETVISIBLE, lua_toboolean(L, -1));
+					else if (streq(prop, "changeable"))
+						SS(SCI_STYLESETCHANGEABLE, lua_toboolean(L, -1));
+					else if (streq(prop, "hotspot"))
+						SS(SCI_STYLESETHOTSPOT, lua_toboolean(L, -1));
+					lua_pop(L, 1); // value
+				}
+				if (style_num == 32 && !cleared) {
+					// Set all styles to style_default before loading individual ones.
+					Platform::SendScintilla(wid, SCI_STYLECLEARALL);
+					cleared = true;
+					lua_pushnil(L);
+					lua_replace(L, -3);
+				}
+			} lua_pop(L, 1); // value
+		} while (lua_next(L, -2)); // _STYLES table
+		lua_pop(L, 2); // _LEXER._STYLES and _LEXER
+
+		// If the lexer is a parent, it will have children in its _CHILDREN table.
+		// If the lexer is a child, it will have a parent in its _TOKENRULES table.
+		lua_getglobal(L, "_LEXER");
+		lua_getfield(L, -1, "_CHILDREN");
+		lua_getfield(L, -2, "_TOKENRULES");
+		if (lua_istable(L, -1) || lua_istable(L, -2)) multilang = true;
+		lua_pop(L, 3); // _LEXER._TOKENRULES, _LEXER._CHILDREN, and _LEXER
+
+		reinit = false;
+		return true;
+	}
+
+	void * StringResult(long lParam, const char *val) {
+		const int n = strlen(val);
+		if (lParam != 0) {
+			char *ptr = reinterpret_cast<char *>(lParam);
+			strcpy(ptr, val);
+		}
+		return reinterpret_cast<void *>(n); // Not including NUL
+	}
+
+public:
+	LexerLPeg() : reinit(true), multilang(false) { L = NULL; wid = NULL; }
+	~LexerLPeg() {}
+
+	void SCI_METHOD Release() {
+		lua_close(L);
+		L = 0;
+		delete this;
+	}
+
+	void SCI_METHOD Lex(unsigned int startPos, int lengthDoc, int initStyle,
+	                    IDocument *pAccess) {
+		if (reinit) Init();
+		if (!L) return;
+		LexAccessor styler(pAccess);
+		lua_pushlightuserdata(L, reinterpret_cast<void *>(&styler));
+		lua_setfield(L, LUA_REGISTRYINDEX, "styler");
+
+		// Start from the beginning of the current style so LPeg matches it.
+		// (Applies only to non-multilang lexers.)
+		if (!multilang && startPos > 0) {
+			int i = startPos;
+			while (i > 0 && styler.StyleAt(i - 1) == initStyle) i--;
+			lengthDoc += startPos - i;
+			startPos = i;
+		}
+
+		unsigned int startSeg = startPos, endSeg = startPos + lengthDoc;
+		int style = 0;
+		styler.StartAt(startPos, static_cast<char>(STYLE_MAX));
+		styler.StartSegment(startPos);
+		lua_getglobal(L, "lexer");
+		lua_getfield(L, -1, "lex");
+		if (lua_isfunction(L, -1)) {
+			char *buf = multilang ? styler.GetCharRange(0, styler.Length())
+			                      : styler.GetCharRange(startPos, lengthDoc);
+			lua_pushstring(L, buf);
+			delete []buf;
+			if (lua_pcall(L, 1, 1, 0) != 0) l_error(L);
+			// Style the text from the token table returned.
+			if (lua_istable(L, -1)) {
+				lua_getglobal(L, "_LEXER");
+				lua_pushstring(L, "_TOKENS");
+				lua_rawget(L, -2);
+				lua_remove(L, lua_gettop(L) - 1); // _LEXER
+				lua_pushnil(L);
+				while (lua_next(L, -3)) { // token (tokens[i])
+					if (!lua_istable(L, -1)) {
+						l_error(L, "Table of tokens expected from lexer.lex");
+						break;
+					}
+					lua_rawgeti(L, -1, 1); // token[1]
+					lua_rawget(L, -4); // _LEXER._TOKENS[token[1]]
+					style = 32;
+					if (!lua_isnil(L, -1)) style = lua_tointeger(L, -1);
+					lua_pop(L, 1); // _LEXER._TOKENS[token[1]]
+					lua_rawgeti(L, -1, 2); // token[2]
+					unsigned int position = lua_tointeger(L, -1) - 1;
+					lua_pop(L, 1); // token[2]
+					lua_pop(L, 1); // token (tokens[i])
+					if (style >= 0 && style <= STYLE_MAX) {
+						if (multilang) {
+							if (position > startSeg && position <= endSeg)
+								styler.ColourTo(position - 1, style);
+							else if (position > endSeg && styler.GetStartSegment() < endSeg)
+								styler.ColourTo(endSeg - 1, style); // style remaining length
+						} else styler.ColourTo(startSeg + position - 1, style);
+					} else l_error(L, "Bad style number");
+					if (position > endSeg) break;
+				}
+				lua_pop(L, 2); // _LEXER._TOKENS and token table returned
+			} else l_error(L, "Table of tokens expected from lexer.lex");
+		} else l_error(L, "lexer.lex not found");
+		lua_pop(L, 1); // lexer
+		styler.ColourTo(endSeg - 1, style);
+		styler.Flush();
+	}
+
+	void SCI_METHOD Fold(unsigned int startPos, int lengthDoc, int initStyle,
+	                     IDocument *pAccess) {
+		if (reinit) Init();
+		if (!L) return;
+		LexAccessor styler(pAccess);
+		lua_pushlightuserdata(L, reinterpret_cast<void *>(&styler));
+		lua_setfield(L, LUA_REGISTRYINDEX, "styler");
+		lua_pushlightuserdata(L, reinterpret_cast<void *>(&props));
+		lua_setfield(L, LUA_REGISTRYINDEX, "props");
+
+		lua_getglobal(L, "lexer");
+		lua_getfield(L, -1, "fold");
+		if (lua_isfunction(L, -1)) {
+			int currentLine = styler.GetLine(startPos);
+			char *buf = styler.GetCharRange(startPos, lengthDoc);
+			lua_pushstring(L, buf);
+			delete []buf;
+			lua_pushnumber(L, startPos);
+			lua_pushnumber(L, currentLine);
+			lua_pushnumber(L, styler.LevelAt(currentLine) & SC_FOLDLEVELNUMBERMASK);
+			if (lua_pcall(L, 4, 1, 0) != 0) l_error(L);
+			// Fold the text from the fold table returned.
+			if (lua_istable(L, -1)) {
+				lua_pushnil(L);
+				int line = 0, level = 0;
+				while (lua_next(L, -2)) { // fold (folds[i])
+					if (!lua_istable(L, -1)) {
+						l_error(L, "Table of folds expected from lexer.fold");
+						break;
+					}
+					line = lua_tointeger(L, -2);
+					lua_rawgeti(L, -1, 1); // fold[1]
+					level = lua_tointeger(L, -1);
+					lua_pop(L, 1); // fold[1]
+					if (lua_objlen(L, -1) > 1) {
+						lua_rawgeti(L, -1, 2); // fold[2]
+						int flag = lua_tointeger(L, -1);
+						level |= flag;
+						lua_pop(L, 1); // fold[2]
+					}
+					styler.SetLevel(line, level);
+					lua_pop(L, 1); // fold
+				}
+				lua_pop(L, 1); // fold table returned
+				// Mask off the level number, leaving only the previous flags.
+				int flagsNext = styler.LevelAt(line + 1);
+				flagsNext &= ~SC_FOLDLEVELNUMBERMASK;
+				styler.SetLevel(line + 1, level | flagsNext);
+			} else l_error(L, "Table of folds expected from lexer.fold");
+		} else l_error(L, "lexer.fold function not found");
+		lua_pop(L, 1); // lexer
+	}
+
+	int SCI_METHOD Version() const { return 0; }
+	const char * SCI_METHOD PropertyNames() { return ""; }
+	int SCI_METHOD PropertyType(const char *name) { return 0; }
+	const char * SCI_METHOD DescribeProperty(const char *name) { return ""; }
+	int SCI_METHOD PropertySet(const char *key, const char *val) {
+		props.Set(key, val);
+		if (reinit) Init();
+		return -1; // no need to re-lex
+	}
+	const char * SCI_METHOD DescribeWordListSets() { return ""; }
+	int SCI_METHOD WordListSet(int n, const char *wl) { return -1; }
+
+	void * SCI_METHOD PrivateCall(int code, void *arg) {
+		long lParam = reinterpret_cast<long>(arg);
+		const char *val = 0;
+		switch(code) {
+		case -2: // setting lexer language; reinit with wid
+			wid = reinterpret_cast<WindowID>(arg);
+			reinit = true;
+			return NULL;
+		case -1: // acts like SCI_GETLEXERLANGUAGE
+			val = "null";
+			if (L) {
+				lua_getfield(L, LUA_REGISTRYINDEX, "lexer_name");
+				val = lua_tostring(L, -1);
+				lua_pop(L, 1); // lexer_name
+			}
+			return StringResult(lParam, val);
+		default:  // get style name
+			val = "";
+			if (L) {
+				lua_getglobal(L, "_LEXER");
+				if (lua_istable(L, -1)) {
+					lua_getfield(L, -1, "_TOKENS");
+					if (lua_istable(L, -1)) {
+						lua_pushnil(L);
+						while (lua_next(L, -2)) {
+							// stylename = num
+							if (luaL_checkinteger(L, -1) == static_cast<int>(code)) {
+								val = lua_tostring(L, -2);
+								lua_pop(L, 2); // value and key
+								break;
+							}
+							lua_pop(L, 1); // value
+						}
+						lua_pop(L, 2); // _LEXER._TOKENS and _LEXER
+					}
+				}
+			}
+			return StringResult(lParam, strlen(val) ? val : "Not Available");
+		}
+	}
+
+	static ILexer *LexerFactoryLPeg() {
+		return new LexerLPeg();
+	}
+};
+
+LexerModule lmLPeg(SCLEX_LPEG, LexerLPeg::LexerFactoryLPeg, "llpeg");
diff -r ffde119d297e lexlib/LexAccessor.h
--- scintilla/lexlib/LexAccessor.h	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/lexlib/LexAccessor.h	Tue Aug 17 00:13:24 2010 -0400
@@ -166,6 +166,15 @@
 	void ChangeLexerState(int start, int end) {
 		pAccess->ChangeLexerState(start, end);
 	}
+
+	// added by Mitchell
+	char *GetCharRange(int position, int lengthRetrieve) {
+		char *buffer = static_cast<char *>(malloc(lengthRetrieve + 1));
+		pAccess->GetCharRange(buffer, position, lengthRetrieve);
+		buffer[lengthRetrieve] = '\0';
+		return buffer;
+	}
+	// end added by Mitchell
 };
 
 #ifdef SCI_NAMESPACE
diff -r ffde119d297e src/Catalogue.cxx
--- scintilla/src/Catalogue.cxx	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/src/Catalogue.cxx	Tue Aug 17 00:13:24 2010 -0400
@@ -79,6 +79,8 @@
 
 //++Autogenerated -- run src/LexGen.py to regenerate
 //**\(\tLINK_LEXER(\*);\n\)
+	LINK_LEXER(lmLPeg);
+#if 0 // added by Mitchell
 	LINK_LEXER(lmAbaqus);
 	LINK_LEXER(lmAda);
 	LINK_LEXER(lmAns1);
@@ -175,6 +177,7 @@
 	LINK_LEXER(lmVHDL);
 	LINK_LEXER(lmXML);
 	LINK_LEXER(lmYAML);
+#endif // added by Mitchell
 
 //--Autogenerated -- end of automatically generated section
 
diff -r ffde119d297e src/ScintillaBase.cxx
--- scintilla/src/ScintillaBase.cxx	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/src/ScintillaBase.cxx	Tue Aug 17 00:13:24 2010 -0400
@@ -477,6 +477,7 @@
 	PropSetSimple props;
 public:
 	int lexLanguage;
+	WindowID wid; // added by Mitchell
 
 	LexState(Document *pdoc_);
 	virtual ~LexState();
@@ -517,7 +518,11 @@
 	if (!pdoc->pli) {
 		pdoc->pli = new LexState(pdoc);
 	}
-	return static_cast<LexState *>(pdoc->pli);
+	// modified by Mitchell
+	LexState *state = static_cast<LexState *>(pdoc->pli);
+	state->wid = wMain.GetID();
+	return state;
+	// end modified by Mitchell
 }
 
 void LexState::SetLexerModule(const LexerModule *lex) {
@@ -534,6 +539,7 @@
 }
 
 void LexState::SetLexer(uptr_t wParam) {
+#if 0 // added by Mitchell
 	lexLanguage = wParam;
 	if (lexLanguage == SCLEX_CONTAINER) {
 		SetLexerModule(0);
@@ -543,15 +549,20 @@
 			lex = Catalogue::Find(SCLEX_NULL);
 		SetLexerModule(lex);
 	}
+#endif // added by Mitchell
 }
 
 void LexState::SetLexerLanguage(const char *languageName) {
-	const LexerModule *lex = Catalogue::Find(languageName);
+	const LexerModule *lex = Catalogue::Find(SCLEX_LPEG); // modified by Mitchell
 	if (!lex)
 		lex = Catalogue::Find(SCLEX_NULL);
 	if (lex)
 		lexLanguage = lex->GetLanguage();
 	SetLexerModule(lex);
+	// added by Mitchell
+	instance->PropertySet("lexer.name", languageName);
+	instance->PrivateCall(-2, wid); // need to reinit
+	// end added by Mitchell
 }
 
 const char *LexState::DescribeWordListSets() {
diff -r ffde119d297e win32/deps.mak
--- scintilla/win32/deps.mak	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/win32/deps.mak	Tue Aug 17 00:13:24 2010 -0400
@@ -103,6 +103,11 @@
 StyleContext.o: ../lexlib/StyleContext.cxx ../include/ILexer.h \
  ../lexlib/LexAccessor.h ../lexlib/Accessor.h ../lexlib/StyleContext.h
 WordList.o: ../lexlib/WordList.cxx ../lexlib/WordList.h
+LexLPeg.o: ../lexers/LexLPeg.cxx ../include/ILexer.h \
+ ../include/Scintilla.h ../include/SciLexer.h ../lexlib/PropSetSimple.h \
+ ../lexlib/WordList.h ../lexlib/LexAccessor.h ../lexlib/Accessor.h \
+ ../lexlib/StyleContext.h ../lexlib/CharacterSet.h \
+ ../lexlib/LexerModule.h
 LexAbaqus.o: ../lexers/LexAbaqus.cxx ../include/ILexer.h \
  ../include/Scintilla.h ../include/SciLexer.h ../lexlib/PropSetSimple.h \
  ../lexlib/WordList.h ../lexlib/LexAccessor.h ../lexlib/Accessor.h \
diff -r ffde119d297e win32/makefile
--- scintilla/win32/makefile	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/win32/makefile	Tue Aug 17 00:13:24 2010 -0400
@@ -5,9 +5,25 @@
 # be needed to use other compilers.
 
 .SUFFIXES: .cxx
+# added by Mitchell
+ifdef LINUX
+CC = i486-mingw32-g++
+DLLWRAP = i486-mingw32-dllwrap
+DEL = rm
+GCC = i486-mingw32-gcc
+RANLIB = i486-mingw32-ranlib
+WINDRES = i486-mingw32-windres
+else
+# end added by Mitchell
 CC = g++
 DLLWRAP = g++ -shared -Wl,--kill-at
 DEL = del /q
+# added by Mitchell
+GCC = gcc
+RANLIB = ranlib
+WINDRES = windres
+endif
+# end added by Mitchell
 
 COMPONENT = ../bin/Scintilla.dll
 LEXCOMPONENT = ../bin/SciLexer.dll
@@ -15,10 +31,11 @@
 
 vpath %.h ../src ../include ../lexlib
 vpath %.cxx ../src ../lexlib ../lexers
+vpath %.c ../../scite/lua/src ../../scite/lua/src/lib # added by Mitchell
 
 LDFLAGS=-mwindows -lstdc++ -limm32 -lole32 -luuid -mno-cygwin
 # Add -MMD to get dependencies
-INCLUDEDIRS=-I ../include -I ../src -I../lexlib
+INCLUDEDIRS=-I ../include -I ../src -I../lexlib -I ../../scite/lua/include # modified by Mitchell
 CXXBASEFLAGS=-Wall -Wno-missing-braces -Wno-char-subscripts -Wno-strict-overflow -pedantic $(INCLUDEDIRS) -fno-rtti -mno-cygwin
 
 ifdef DEBUG
@@ -28,9 +45,27 @@
 STRIPFLAG=-s
 endif
 
+# added by Mitchell
+LUA_CORE_OBJS = lapi.o lcode.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o \
+		lmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o \
+		ltable.o ltm.o lundump.o lvm.o lzio.o
+
+LUA_LIB_OBJS =	lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o ltablib.o \
+		lstrlib.o loadlib.o loslib.o linit.o lpeg.o
+
+LUA_OBJS = $(LUA_CORE_OBJS) $(LUA_LIB_OBJS)
+
+vpath %.c ../lua/src ../lua/src/lib
+# end added by Mitchell
+
 .cxx.o:
 	$(CC) $(CXXFLAGS) -c $<
 
+# added by Mitchell
+.c.o:
+	$(GCC) $(INCLUDEDIRS) $(THUNKFLAGS) -mno-cygwin -c $< -o $@
+# end added by Mitchell
+
 ALL:	$(COMPONENT) $(LEXCOMPONENT) $(LEXLIB) ScintillaWinS.o
 
 clean:
@@ -39,7 +74,7 @@
 deps:
 	$(CC) -MM $(CXXFLAGS) *.cxx ../src/*.cxx ../lexlib/*.cxx ../lexers/*.cxx >deps.mak
 
-LEXOBJS:=$(addsuffix .o,$(basename $(notdir $(wildcard ../lexers/Lex*.cxx))))
+LEXOBJS:=$(addsuffix .o,$(basename $(notdir $(wildcard ../lexers/LexLPeg.cxx)))) # modified by Mitchell
 
 
 BASEOBJS = \
@@ -68,7 +103,7 @@
 	ViewStyle.o \
 	XPM.o
 
-SOBJS = ScintillaWin.o ScintillaBase.o $(BASEOBJS)
+SOBJS = ScintillaWin.o ScintillaBase.o $(BASEOBJS) $(LUAOBJS) # modified by Mitchell
 
 $(COMPONENT): $(SOBJS) Scintilla.def
 	$(DLLWRAP) --add-stdcall-alias --target=i386-mingw32 -o $@ $(SOBJS) $(LDFLAGS) $(STRIPFLAG) --relocatable
@@ -85,13 +120,13 @@
 	StyleContext.o \
 	WordList.o \
 	$(BASEOBJS) \
-	$(LEXOBJS)
+	$(LEXOBJS) $(LUAOBJS) # modified by Mitchell
 $(LEXCOMPONENT): $(LOBJS) Scintilla.def
 	$(DLLWRAP) --add-stdcall-alias --target=i386-mingw32 -o $@ $(LOBJS) $(LDFLAGS) $(STRIPFLAG) --relocatable
 
 $(LEXLIB): $(LEXOBJS)
 	$(AR) rc $@ $^
-	ranlib $@
+	$(RANLIB) $@ # modified by Mitchell
 
 # Automatically generate dependencies for most files with "make deps"
 include deps.mak
@@ -139,5 +174,5 @@
 	$(CC) $(CXXFLAGS) -D SCI_LEXER -c $< -o $@
 
 ScintRes.o:	ScintRes.rc PlatformRes.h
-	windres ScintRes.rc $@
+	$(WINDRES) ScintRes.rc $@ # modified by Mitchell
 
diff -r ffde119d297e win32/scintilla.mak
--- scintilla/win32/scintilla.mak	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/win32/scintilla.mak	Tue Aug 17 00:13:24 2010 -0400
@@ -77,7 +77,7 @@
 CXXFLAGS=$(CXXFLAGS) $(CXXNDEBUG)
 !ENDIF
 
-INCLUDEDIRS=-I../include -I../src -I../lexlib
+INCLUDEDIRS=-I../include -I../src -I../lexlib -I../../scite/lua/include # modified by Mitchell
 CXXFLAGS=$(CXXFLAGS) $(INCLUDEDIRS)
 
 ALL:	$(COMPONENT) $(LEXCOMPONENT) $(DIR_O)\ScintillaWinS.obj
@@ -113,90 +113,14 @@
 	$(DIR_O)\ViewStyle.obj \
 	$(DIR_O)\XPM.obj
 
+# modified by Mitchell
 #++Autogenerated -- run src/LexGen.py to regenerate
 #**LEXOBJS=\\\n\(\t$(DIR_O)\\\*.obj \\\n\)
 LEXOBJS=\
-	$(DIR_O)\LexAbaqus.obj \
-	$(DIR_O)\LexAda.obj \
-	$(DIR_O)\LexAPDL.obj \
-	$(DIR_O)\LexAsm.obj \
-	$(DIR_O)\LexAsn1.obj \
-	$(DIR_O)\LexASY.obj \
-	$(DIR_O)\LexAU3.obj \
-	$(DIR_O)\LexAVE.obj \
-	$(DIR_O)\LexBaan.obj \
-	$(DIR_O)\LexBash.obj \
-	$(DIR_O)\LexBasic.obj \
-	$(DIR_O)\LexBullant.obj \
-	$(DIR_O)\LexCaml.obj \
-	$(DIR_O)\LexCLW.obj \
-	$(DIR_O)\LexCmake.obj \
-	$(DIR_O)\LexCOBOL.obj \
-	$(DIR_O)\LexConf.obj \
-	$(DIR_O)\LexCPP.obj \
-	$(DIR_O)\LexCrontab.obj \
-	$(DIR_O)\LexCsound.obj \
-	$(DIR_O)\LexCSS.obj \
-	$(DIR_O)\LexD.obj \
-	$(DIR_O)\LexEiffel.obj \
-	$(DIR_O)\LexErlang.obj \
-	$(DIR_O)\LexEScript.obj \
-	$(DIR_O)\LexFlagship.obj \
-	$(DIR_O)\LexForth.obj \
-	$(DIR_O)\LexFortran.obj \
-	$(DIR_O)\LexGAP.obj \
-	$(DIR_O)\LexGui4Cli.obj \
-	$(DIR_O)\LexHaskell.obj \
-	$(DIR_O)\LexHTML.obj \
-	$(DIR_O)\LexInno.obj \
-	$(DIR_O)\LexKix.obj \
-	$(DIR_O)\LexLisp.obj \
-	$(DIR_O)\LexLout.obj \
-	$(DIR_O)\LexLua.obj \
-	$(DIR_O)\LexMagik.obj \
-	$(DIR_O)\LexMarkdown.obj \
-	$(DIR_O)\LexMatlab.obj \
-	$(DIR_O)\LexMetapost.obj \
-	$(DIR_O)\LexMMIXAL.obj \
-	$(DIR_O)\LexMPT.obj \
-	$(DIR_O)\LexMSSQL.obj \
-	$(DIR_O)\LexMySQL.obj \
-	$(DIR_O)\LexNimrod.obj \
-	$(DIR_O)\LexNsis.obj \
-	$(DIR_O)\LexOpal.obj \
-	$(DIR_O)\LexOthers.obj \
-	$(DIR_O)\LexPascal.obj \
-	$(DIR_O)\LexPB.obj \
-	$(DIR_O)\LexPerl.obj \
-	$(DIR_O)\LexPLM.obj \
-	$(DIR_O)\LexPOV.obj \
-	$(DIR_O)\LexPowerPro.obj \
-	$(DIR_O)\LexPowerShell.obj \
-	$(DIR_O)\LexProgress.obj \
-	$(DIR_O)\LexPS.obj \
-	$(DIR_O)\LexPython.obj \
-	$(DIR_O)\LexR.obj \
-	$(DIR_O)\LexRebol.obj \
-	$(DIR_O)\LexRuby.obj \
-	$(DIR_O)\LexScriptol.obj \
-	$(DIR_O)\LexSmalltalk.obj \
-	$(DIR_O)\LexSML.obj \
-	$(DIR_O)\LexSorcus.obj \
-	$(DIR_O)\LexSpecman.obj \
-	$(DIR_O)\LexSpice.obj \
-	$(DIR_O)\LexSQL.obj \
-	$(DIR_O)\LexTACL.obj \
-	$(DIR_O)\LexTADS3.obj \
-	$(DIR_O)\LexTAL.obj \
-	$(DIR_O)\LexTCL.obj \
-	$(DIR_O)\LexTeX.obj \
-	$(DIR_O)\LexTxt2tags.obj \
-	$(DIR_O)\LexVB.obj \
-	$(DIR_O)\LexVerilog.obj \
-	$(DIR_O)\LexVHDL.obj \
-	$(DIR_O)\LexYAML.obj \
+	$(DIR_O)\LexLPeg.obj
 
 #--Autogenerated -- end of automatically generated section
+# end modified by Mitchell
 
 LOBJS=\
 	$(DIR_O)\Accessor.obj \
@@ -320,6 +244,8 @@
 #++Autogenerated -- run src/LexGen.py to regenerate
 #**\n\($(DIR_O)\\\*.obj: ..\\lexers\\\*.cxx $(LEX_HEADERS)\n\n\)
 
+$(DIR_O)\LexLPeg.obj: ..\lexers\LexLPeg.cxx $(LEX_HEADERS) # added by Mitchell
+
 $(DIR_O)\LexAbaqus.obj: ..\lexers\LexAbaqus.cxx $(LEX_HEADERS)
 
 $(DIR_O)\LexAda.obj: ..\lexers\LexAda.cxx $(LEX_HEADERS)
diff -r ffde119d297e win32/scintilla_vc6.mak
--- scintilla/win32/scintilla_vc6.mak	Wed Jul 28 17:54:24 2010 +1000
+++ scintilla/win32/scintilla_vc6.mak	Tue Aug 17 00:13:24 2010 -0400
@@ -79,7 +79,7 @@
 CXXFLAGS=$(CXXFLAGS) $(CXXNDEBUG)
 !ENDIF
 
-INCLUDEDIRS=-I../include -I../src -I../lexlib
+INCLUDEDIRS=-I../include -I../src -I../lexlib -I../../scite/lua/include # modified by Mitchell
 CXXFLAGS=$(CXXFLAGS) $(INCLUDEDIRS)
 
 ALL:	$(COMPONENT) $(LEXCOMPONENT) $(DIR_O)\ScintillaWinS.obj
@@ -115,90 +115,14 @@
 	$(DIR_O)\ViewStyle.obj \
 	$(DIR_O)\XPM.obj
 
+# modified by Mitchell
 #++Autogenerated -- run src/LexGen.py to regenerate
 #**LEXOBJS=\\\n\(\t$(DIR_O)\\\*.obj \\\n\)
 LEXOBJS=\
-	$(DIR_O)\LexAbaqus.obj \
-	$(DIR_O)\LexAda.obj \
-	$(DIR_O)\LexAPDL.obj \
-	$(DIR_O)\LexAsm.obj \
-	$(DIR_O)\LexAsn1.obj \
-	$(DIR_O)\LexASY.obj \
-	$(DIR_O)\LexAU3.obj \
-	$(DIR_O)\LexAVE.obj \
-	$(DIR_O)\LexBaan.obj \
-	$(DIR_O)\LexBash.obj \
-	$(DIR_O)\LexBasic.obj \
-	$(DIR_O)\LexBullant.obj \
-	$(DIR_O)\LexCaml.obj \
-	$(DIR_O)\LexCLW.obj \
-	$(DIR_O)\LexCmake.obj \
-	$(DIR_O)\LexCOBOL.obj \
-	$(DIR_O)\LexConf.obj \
-	$(DIR_O)\LexCPP.obj \
-	$(DIR_O)\LexCrontab.obj \
-	$(DIR_O)\LexCsound.obj \
-	$(DIR_O)\LexCSS.obj \
-	$(DIR_O)\LexD.obj \
-	$(DIR_O)\LexEiffel.obj \
-	$(DIR_O)\LexErlang.obj \
-	$(DIR_O)\LexEScript.obj \
-	$(DIR_O)\LexFlagship.obj \
-	$(DIR_O)\LexForth.obj \
-	$(DIR_O)\LexFortran.obj \
-	$(DIR_O)\LexGAP.obj \
-	$(DIR_O)\LexGui4Cli.obj \
-	$(DIR_O)\LexHaskell.obj \
-	$(DIR_O)\LexHTML.obj \
-	$(DIR_O)\LexInno.obj \
-	$(DIR_O)\LexKix.obj \
-	$(DIR_O)\LexLisp.obj \
-	$(DIR_O)\LexLout.obj \
-	$(DIR_O)\LexLua.obj \
-	$(DIR_O)\LexMagik.obj \
-	$(DIR_O)\LexMarkdown.obj \
-	$(DIR_O)\LexMatlab.obj \
-	$(DIR_O)\LexMetapost.obj \
-	$(DIR_O)\LexMMIXAL.obj \
-	$(DIR_O)\LexMPT.obj \
-	$(DIR_O)\LexMSSQL.obj \
-	$(DIR_O)\LexMySQL.obj \
-	$(DIR_O)\LexNimrod.obj \
-	$(DIR_O)\LexNsis.obj \
-	$(DIR_O)\LexOpal.obj \
-	$(DIR_O)\LexOthers.obj \
-	$(DIR_O)\LexPascal.obj \
-	$(DIR_O)\LexPB.obj \
-	$(DIR_O)\LexPerl.obj \
-	$(DIR_O)\LexPLM.obj \
-	$(DIR_O)\LexPOV.obj \
-	$(DIR_O)\LexPowerPro.obj \
-	$(DIR_O)\LexPowerShell.obj \
-	$(DIR_O)\LexProgress.obj \
-	$(DIR_O)\LexPS.obj \
-	$(DIR_O)\LexPython.obj \
-	$(DIR_O)\LexR.obj \
-	$(DIR_O)\LexRebol.obj \
-	$(DIR_O)\LexRuby.obj \
-	$(DIR_O)\LexScriptol.obj \
-	$(DIR_O)\LexSmalltalk.obj \
-	$(DIR_O)\LexSML.obj \
-	$(DIR_O)\LexSorcus.obj \
-	$(DIR_O)\LexSpecman.obj \
-	$(DIR_O)\LexSpice.obj \
-	$(DIR_O)\LexSQL.obj \
-	$(DIR_O)\LexTACL.obj \
-	$(DIR_O)\LexTADS3.obj \
-	$(DIR_O)\LexTAL.obj \
-	$(DIR_O)\LexTCL.obj \
-	$(DIR_O)\LexTeX.obj \
-	$(DIR_O)\LexTxt2tags.obj \
-	$(DIR_O)\LexVB.obj \
-	$(DIR_O)\LexVerilog.obj \
-	$(DIR_O)\LexVHDL.obj \
-	$(DIR_O)\LexYAML.obj \
+	$(DIR_O)\LexLPeg.obj
 
 #--Autogenerated -- end of automatically generated section
+# end modified by Mitchell
 
 LOBJS=\
 	$(DIR_O)\Accessor.obj \
@@ -322,6 +246,8 @@
 #++Autogenerated -- run src/LexGen.py to regenerate
 #**\n\($(DIR_O)\\\*.obj: ..\\lexers\\\*.cxx $(LEX_HEADERS)\n\n\)
 
+$(DIR_O)\LexLPeg.obj: ..\lexers\LexLPeg.cxx $(LEX_HEADERS) # added by Mitchell
+
 $(DIR_O)\LexAbaqus.obj: ..\lexers\LexAbaqus.cxx $(LEX_HEADERS)
 
 $(DIR_O)\LexAda.obj: ..\lexers\LexAda.cxx $(LEX_HEADERS)
diff -r 77399602f8dc boundscheck/SciTE.dsp
--- scite/boundscheck/SciTE.dsp	Wed Jul 28 10:38:18 2010 +1000
+++ scite/boundscheck/SciTE.dsp	Tue Aug 17 00:13:24 2010 -0400
@@ -219,321 +219,15 @@
 # End Source File
 # Begin Source File
 
-SOURCE=..\..\scintilla\lexers\LexAbaqus.cxx
+# modified by Mitchell
+SOURCE=..\..\scintilla\lexers\LexLPeg.cxx
 # End Source File
 # Begin Source File
 
-SOURCE=..\..\scintilla\lexers\LexAda.cxx
+SOURCE=..\lua\src\lpeg.c
 # End Source File
 # Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexAPDL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexAsm.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexAsn1.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexASY.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexAU3.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexAVE.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexBaan.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexBash.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexBasic.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexBullant.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexCaml.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexCLW.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexCmake.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexCOBOL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexConf.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexCPP.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexCrontab.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexCsound.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexCSS.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexD.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexEiffel.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexErlang.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexEScript.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexFlagship.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexForth.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexFortran.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexGAP.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexGui4Cli.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexHaskell.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexHTML.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexInno.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexKix.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexLisp.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexLout.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexLua.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexMagik.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexMarkdown.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexMatlab.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexMetapost.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexMMIXAL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexMPT.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexMSSQL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexMySQL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexNimrod.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexNsis.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexOpal.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexOthers.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexPascal.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexPB.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexPerl.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexPLM.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexPOV.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexPowerPro.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexPowerShell.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexProgress.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexPS.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexPython.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexR.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexRebol.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexRuby.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexScriptol.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexSmalltalk.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexSML.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexSorcus.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexSpecman.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexSpice.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexSQL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexTACL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexTADS3.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexTAL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexTCL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexTeX.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexTxt2tags.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexVB.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexVerilog.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexVHDL.cxx
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\scintilla\lexers\LexYAML.cxx
-# End Source File
-# Begin Source File
+# end modified by Mitchell
 
 SOURCE=..\lua\src\lfunc.c
 # End Source File
diff -r 77399602f8dc boundscheck/SciTE.vcproj
--- scite/boundscheck/SciTE.vcproj	Wed Jul 28 10:38:18 2010 +1000
+++ scite/boundscheck/SciTE.vcproj	Tue Aug 17 00:13:24 2010 -0400
@@ -243,244 +243,14 @@
 			<File
 				RelativePath="..\lua\src\ldump.c">
 			</File>
+			<!-- modified by Mitchell -->
 			<File
-				RelativePath="..\..\scintilla\lexers\LexAbaqus.cxx">
+				RelativePath="..\..\scintilla\lexers\LexLPeg.cxx">
 			</File>
 			<File
-				RelativePath="..\..\scintilla\lexers\LexAda.cxx">
+				RelativePath="..\lua\src\lpeg.c">
 			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexAPDL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexAsm.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexAsn1.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexASY.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexAU3.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexAVE.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexBaan.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexBash.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexBasic.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexBullant.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexCaml.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexCLW.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexCmake.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexCOBOL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexConf.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexCPP.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexCrontab.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexCsound.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexCSS.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexD.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexEiffel.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexErlang.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexEScript.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexFlagship.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexForth.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexFortran.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexGAP.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexGui4Cli.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexHaskell.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexHTML.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexInno.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexKix.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexLisp.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexLout.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexLua.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexMagik.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexMarkdown.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexMatlab.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexMetapost.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexMMIXAL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexMPT.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexMSSQL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexMySQL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexNimrod.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexNsis.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexOpal.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexOthers.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexPascal.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexPB.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexPerl.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexPLM.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexPOV.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexPowerPro.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexPowerShell.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexProgress.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexPS.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexPython.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexR.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexRebol.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexRuby.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexScriptol.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexSmalltalk.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexSML.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexSorcus.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexSpecman.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexSpice.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexSQL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexTACL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexTADS3.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexTAL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexTCL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexTeX.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexTxt2tags.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexVB.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexVerilog.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexVHDL.cxx">
-			</File>
-			<File
-				RelativePath="..\..\scintilla\lexers\LexYAML.cxx">
-			</File>
-
+			<!-- end modified by Mitchell -->
 			<File
 				RelativePath="..\lua\src\lfunc.c">
 			</File>
diff -r 77399602f8dc gtk/makefile
--- scite/gtk/makefile	Wed Jul 28 10:38:18 2010 +1000
+++ scite/gtk/makefile	Tue Aug 17 00:13:24 2010 -0400
@@ -55,7 +55,7 @@
 		ltable.o ltm.o lundump.o lvm.o lzio.o
 
 LUA_LIB_OBJS =	lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o ltablib.o \
-		lstrlib.o loadlib.o loslib.o linit.o
+		lstrlib.o loadlib.o loslib.o linit.o lpeg.o # modified by Mitchell
 
 LUA_OBJS = LuaExtension.o $(LUA_CORE_OBJS) $(LUA_LIB_OBJS)
 
diff -r 77399602f8dc lua/include/lualib.h
--- scite/lua/include/lualib.h	Wed Jul 28 10:38:18 2010 +1000
+++ scite/lua/include/lualib.h	Tue Aug 17 00:13:24 2010 -0400
@@ -39,6 +39,11 @@
 #define LUA_LOADLIBNAME	"package"
 LUALIB_API int (luaopen_package) (lua_State *L);
 
+// added by Mitchell
+#define LUA_LPEGNAME "lpeg"
+LUALIB_API int (luaopen_lpeg) (lua_State *L);
+// end added by Mitchell
+
 
 /* open all previous libraries */
 LUALIB_API void (luaL_openlibs) (lua_State *L); 
diff -r 77399602f8dc lua/src/lpeg.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ scite/lua/src/lpeg.c	Tue Aug 17 00:13:24 2010 -0400
@@ -0,0 +1,2260 @@
+/*
+** $Id: lpeg.c,v 1.98 2008/10/11 20:20:43 roberto Exp $
+** LPeg - PEG pattern matching for Lua
+** Copyright 2007, Lua.org & PUC-Rio  (see 'lpeg.html' for license)
+** written by Roberto Ierusalimschy
+**
+** Added to Scintillua by Mitchell
+*/
+
+
+#include <assert.h>
+#include <ctype.h>
+#include <limits.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "lua.h"
+#include "lauxlib.h"
+
+
+#define VERSION		"0.9"
+#define PATTERN_T	"pattern"
+
+/* maximum call/backtrack levels */
+#define MAXBACK		400
+
+/* initial size for capture's list */
+#define IMAXCAPTURES	600
+
+
+/* index, on Lua stack, for subject */
+#define SUBJIDX		2
+
+/* number of fixed arguments to 'match' (before capture arguments) */
+#define FIXEDARGS	3
+
+/* index, on Lua stack, for substitution value cache */
+#define subscache(cs)	((cs)->ptop + 1)
+
+/* index, on Lua stack, for capture list */
+#define caplistidx(ptop)	((ptop) + 2)
+
+/* index, on Lua stack, for pattern's fenv */
+#define penvidx(ptop)	((ptop) + 3)
+
+
+
+typedef unsigned char byte;
+
+
+#define CHARSETSIZE		((UCHAR_MAX/CHAR_BIT) + 1)
+
+
+typedef byte Charset[CHARSETSIZE];
+
+
+typedef const char *(*PattFunc) (const void *ud,
+                                 const char *o,  /* string start */
+                                 const char *s,  /* current position */
+                                 const char *e); /* string end */
+
+
+/* Virtual Machine's instructions */
+typedef enum Opcode {
+  IAny, IChar, ISet, ISpan,
+  IRet, IEnd,
+  IChoice, IJmp, ICall, IOpenCall,
+  ICommit, IPartialCommit, IBackCommit, IFailTwice, IFail, IGiveup,
+  IFunc,
+  IFullCapture, IEmptyCapture, IEmptyCaptureIdx,
+  IOpenCapture, ICloseCapture, ICloseRunTime
+} Opcode;
+
+
+#define ISJMP		1
+#define ISCHECK		(ISJMP << 1)
+#define ISNOFAIL	(ISCHECK << 1)
+#define ISCAPTURE	(ISNOFAIL << 1)
+#define ISMOVABLE	(ISCAPTURE << 1)
+#define ISFENVOFF	(ISMOVABLE << 1)
+#define HASCHARSET	(ISFENVOFF << 1)
+
+static const byte opproperties[] = {
+  /* IAny */		ISCHECK,
+  /* IChar */		ISCHECK,
+  /* ISet */		ISCHECK | HASCHARSET,
+  /* ISpan */		ISNOFAIL | HASCHARSET,
+  /* IRet */		0,
+  /* IEnd */		0,
+  /* IChoice */		ISJMP,
+  /* IJmp */		ISJMP | ISNOFAIL,
+  /* ICall */		ISJMP,
+  /* IOpenCall */	ISFENVOFF,
+  /* ICommit */		ISJMP,
+  /* IPartialCommit */	ISJMP,
+  /* IBackCommit */	ISJMP,
+  /* IFailTwice */	0,
+  /* IFail */		0,
+  /* IGiveup */		0,
+  /* IFunc */		0,
+  /* IFullCapture */	ISCAPTURE | ISNOFAIL | ISFENVOFF,
+  /* IEmptyCapture */	ISCAPTURE | ISNOFAIL | ISMOVABLE,
+  /* IEmptyCaptureIdx */ISCAPTURE | ISNOFAIL | ISMOVABLE | ISFENVOFF,
+  /* IOpenCapture */	ISCAPTURE | ISNOFAIL | ISMOVABLE | ISFENVOFF,
+  /* ICloseCapture */	ISCAPTURE | ISNOFAIL | ISMOVABLE | ISFENVOFF,
+  /* ICloseRunTime */	ISCAPTURE | ISFENVOFF
+};
+
+
+typedef union Instruction {
+  struct Inst {
+    byte code;
+    byte aux;
+    short offset;
+  } i;
+  PattFunc f;
+  byte buff[1];
+} Instruction;
+
+static const Instruction giveup = {{IGiveup, 0, 0}};
+
+#define getkind(op)	((op)->i.aux & 0xF)
+#define getoff(op)	(((op)->i.aux >> 4) & 0xF)
+
+#define dest(p,x)	((x) + ((p)+(x))->i.offset)
+
+#define MAXOFF		0xF
+
+#define isprop(op,p)	(opproperties[(op)->i.code] & (p))
+#define isjmp(op)	isprop(op, ISJMP)
+#define iscapture(op) 	isprop(op, ISCAPTURE)
+#define ischeck(op)	(isprop(op, ISCHECK) && (op)->i.offset == 0)
+#define istest(op)	(isprop(op, ISCHECK) && (op)->i.offset != 0)
+#define isnofail(op)	isprop(op, ISNOFAIL)
+#define ismovable(op)	isprop(op, ISMOVABLE)
+#define isfenvoff(op)	isprop(op, ISFENVOFF)
+#define hascharset(op)	isprop(op, HASCHARSET)
+
+
+/* kinds of captures */
+typedef enum CapKind {
+  Cclose, Cposition, Cconst, Cbackref, Carg, Csimple, Ctable, Cfunction,
+  Cquery, Cstring, Csubst, Cfold, Cruntime, Cgroup
+} CapKind;
+
+#define iscapnosize(k)	((k) == Cposition || (k) == Cconst)
+
+
+typedef struct Capture {
+  const char *s;  /* position */
+  short idx;
+  byte kind;
+  byte siz;
+} Capture;
+
+
+/* maximum size (in elements) for a pattern */
+#define MAXPATTSIZE	(SHRT_MAX - 10)
+
+
+/* size (in elements) for an instruction plus extra l bytes */
+#define instsize(l)	(((l) - 1)/sizeof(Instruction) + 2)
+
+
+/* size (in elements) for a ISet instruction */
+#define CHARSETINSTSIZE		instsize(CHARSETSIZE)
+
+
+
+#define loopset(v,b)	{ int v; for (v = 0; v < CHARSETSIZE; v++) b; }
+
+
+#define testchar(st,c)	(((int)(st)[((c) >> 3)] & (1 << ((c) & 7))))
+#define setchar(st,c)	((st)[(c) >> 3] |= (1 << ((c) & 7)))
+
+
+
+static int sizei (const Instruction *i) {
+  if (hascharset(i)) return CHARSETINSTSIZE;
+  else if (i->i.code == IFunc) return i->i.offset;
+  else return 1;
+}
+
+
+static const char *val2str (lua_State *L, int idx) {
+  const char *k = lua_tostring(L, idx);
+  if (k != NULL)
+    return lua_pushfstring(L, "rule '%s'", k);
+  else
+    return lua_pushfstring(L, "rule <a %s>", luaL_typename(L, -1));
+}
+
+
+static int getposition (lua_State *L, int t, int i) {
+  int res;
+  lua_getfenv(L, -1);
+  lua_rawgeti(L, -1, i);  /* get key from pattern's environment */
+  lua_gettable(L, t);  /* get position from positions table */
+  res = lua_tointeger(L, -1);
+  if (res == 0) {  /* key has no registered position? */
+    lua_rawgeti(L, -2, i);  /* get key again */
+    return luaL_error(L, "%s is not defined in given grammar", val2str(L, -1));
+  }
+  lua_pop(L, 2);  /* remove environment and position */
+  return res;
+}
+
+
+
+/*
+** {======================================================
+** Printing patterns
+** =======================================================
+*/
+
+
+static void printcharset (const Charset st) {
+  int i;
+  printf("[");
+  for (i = 0; i <= UCHAR_MAX; i++) {
+    int first = i;
+    while (testchar(st, i) && i <= UCHAR_MAX) i++;
+    if (i - 1 == first)  /* unary range? */
+      printf("(%02x)", first);
+    else if (i - 1 > first)  /* non-empty range? */
+      printf("(%02x-%02x)", first, i - 1);
+  }
+  printf("]");
+}
+
+
+static void printcapkind (int kind) {
+  const char *const modes[] = {
+    "close", "position", "constant", "backref",
+    "argument", "simple", "table", "function",
+    "query", "string", "substitution", "fold",
+    "runtime", "group"};
+  printf("%s", modes[kind]);
+}
+
+
+static void printjmp (const Instruction *op, const Instruction *p) {
+  printf("-> ");
+  if (p->i.offset == 0) printf("FAIL");
+  else printf("%d", (int)(dest(0, p) - op));
+}
+
+
+static void printinst (const Instruction *op, const Instruction *p) {
+  const char *const names[] = {
+    "any", "char", "set", "span",
+    "ret", "end",
+    "choice", "jmp", "call", "open_call",
+    "commit", "partial_commit", "back_commit", "failtwice", "fail", "giveup",
+     "func",
+     "fullcapture", "emptycapture", "emptycaptureidx", "opencapture",
+     "closecapture", "closeruntime"
+  };
+  printf("%02ld: %s ", (long)(p - op), names[p->i.code]);
+  switch ((Opcode)p->i.code) {
+    case IChar: {
+      printf("'%c'", p->i.aux);
+      printjmp(op, p);
+      break;
+    }
+    case IAny: {
+      printf("* %d", p->i.aux);
+      printjmp(op, p);
+      break;
+    }
+    case IFullCapture: case IOpenCapture:
+    case IEmptyCapture: case IEmptyCaptureIdx:
+    case ICloseCapture: case ICloseRunTime: {
+      printcapkind(getkind(p));
+      printf("(n = %d)  (off = %d)", getoff(p), p->i.offset);
+      break;
+    }
+    case ISet: {
+      printcharset((p+1)->buff);
+      printjmp(op, p);
+      break;
+    }
+    case ISpan: {
+      printcharset((p+1)->buff);
+      break;
+    }
+    case IOpenCall: {
+      printf("-> %d", p->i.offset);
+      break;
+    }
+    case IChoice: {
+      printjmp(op, p);
+      printf(" (%d)", p->i.aux);
+      break;
+    }
+    case IJmp: case ICall: case ICommit:
+    case IPartialCommit: case IBackCommit: {
+      printjmp(op, p);
+      break;
+    }
+    default: break;
+  }
+  printf("\n");
+}
+
+
+static void printpatt (Instruction *p) {
+  Instruction *op = p;
+  for (;;) {
+    printinst(op, p);
+    if (p->i.code == IEnd) break;
+    p += sizei(p);
+  }
+}
+
+
+static void printcap (Capture *cap) {
+  printcapkind(cap->kind);
+  printf(" (idx: %d - size: %d) -> %p\n", cap->idx, cap->siz, cap->s);
+}
+
+
+static void printcaplist (Capture *cap) {
+  for (; cap->s; cap++) printcap(cap);
+}
+
+/* }====================================================== */
+
+
+
+
+/*
+** {======================================================
+** Virtual Machine
+** =======================================================
+*/
+
+
+typedef struct Stack {
+  const char *s;
+  const Instruction *p;
+  int caplevel;
+} Stack;
+
+
+static int runtimecap (lua_State *L, Capture *close, Capture *ocap,
+                       const char *o, const char *s, int ptop);
+
+
+static Capture *doublecap (lua_State *L, Capture *cap, int captop, int ptop) {
+  Capture *newc;
+  if (captop >= INT_MAX/((int)sizeof(Capture) * 2))
+    luaL_error(L, "too many captures");
+  newc = (Capture *)lua_newuserdata(L, captop * 2 * sizeof(Capture));
+  memcpy(newc, cap, captop * sizeof(Capture));
+  lua_replace(L, caplistidx(ptop));
+  return newc;
+}
+
+
+static void adddyncaptures (const char *s, Capture *base, int n, int fd) {
+  int i;
+  assert(base[0].kind == Cruntime && base[0].siz == 0);
+  base[0].idx = fd;  /* first returned capture */
+  for (i = 1; i < n; i++) {  /* add extra captures */
+    base[i].siz = 1;  /* mark it as closed */
+    base[i].s = s;
+    base[i].kind = Cruntime;
+    base[i].idx = fd + i;  /* stack index */
+  }
+  base[n].kind = Cclose;  /* add closing entry */
+  base[n].siz = 1;
+  base[n].s = s;
+}
+
+
+#define condfailed(p)	{ int f = p->i.offset; if (f) p+=f; else goto fail; }
+
+
+static const char *match (lua_State *L,
+                          const char *o, const char *s, const char *e,
+                          Instruction *op, Capture *capture, int ptop) {
+  Stack stackbase[MAXBACK];
+  Stack *stacklimit = stackbase + MAXBACK;
+  Stack *stack = stackbase;  /* point to first empty slot in stack */
+  int capsize = IMAXCAPTURES;
+  int captop = 0;  /* point to first empty slot in captures */
+  const Instruction *p = op;
+  stack->p = &giveup; stack->s = s; stack->caplevel = 0; stack++;
+  for (;;) {
+#if defined(DEBUG)
+      printf("s: |%s| stck: %d c: %d  ", s, stack - stackbase, captop);
+      printinst(op, p);
+#endif
+    switch ((Opcode)p->i.code) {
+      case IEnd: {
+        assert(stack == stackbase + 1);
+        capture[captop].kind = Cclose;
+        capture[captop].s = NULL;
+        return s;
+      }
+      case IGiveup: {
+        assert(stack == stackbase);
+        return NULL;
+      }
+      case IRet: {
+        assert(stack > stackbase && (stack - 1)->s == NULL);
+        p = (--stack)->p;
+        continue;
+      }
+      case IAny: {
+        int n = p->i.aux;
+        if (n <= e - s) { p++; s += n; }
+        else condfailed(p);
+        continue;
+      }
+      case IChar: {
+        if ((byte)*s == p->i.aux && s < e) { p++; s++; }
+        else condfailed(p);
+        continue;
+      }
+      case ISet: {
+        int c = (byte)*s;
+        if (testchar((p+1)->buff, c) && s < e)
+          { p += CHARSETINSTSIZE; s++; }
+        else condfailed(p);
+        continue;
+      }
+      case ISpan: {
+        for (; s < e; s++) {
+          int c = (byte)*s;
+          if (!testchar((p+1)->buff, c)) break;
+        }
+        p += CHARSETINSTSIZE;
+        continue;
+      }
+      case IFunc: {
+        const char *r = (p+1)->f((p+2)->buff, o, s, e);
+        if (r == NULL) goto fail;
+        s = r;
+        p += p->i.offset;
+        continue;
+      }
+      case IJmp: {
+        p += p->i.offset;
+        continue;
+      }
+      case IChoice: {
+        if (stack >= stacklimit)
+          return (luaL_error(L, "too many pending calls/choices"), (char *)0);
+        stack->p = dest(0, p);
+        stack->s = s - p->i.aux;
+        stack->caplevel = captop;
+        stack++;
+        p++;
+        continue;
+      }
+      case ICall: {
+        if (stack >= stacklimit)
+          return (luaL_error(L, "too many pending calls/choices"), (char *)0);
+        stack->s = NULL;
+        stack->p = p + 1;  /* save return address */
+        stack++;
+        p += p->i.offset;
+        continue;
+      }
+      case ICommit: {
+        assert(stack > stackbase && (stack - 1)->s != NULL);
+        stack--;
+        p += p->i.offset;
+        continue;
+      }
+      case IPartialCommit: {
+        assert(stack > stackbase && (stack - 1)->s != NULL);
+        (stack - 1)->s = s;
+        (stack - 1)->caplevel = captop;
+        p += p->i.offset;
+        continue;
+      }
+      case IBackCommit: {
+        assert(stack > stackbase && (stack - 1)->s != NULL);
+        s = (--stack)->s;
+        p += p->i.offset;
+        continue;
+      }
+      case IFailTwice:
+        assert(stack > stackbase);
+        stack--;
+        /* go through */
+      case IFail:
+      fail: { /* pattern failed: try to backtrack */
+        do {  /* remove pending calls */
+          assert(stack > stackbase);
+          s = (--stack)->s;
+        } while (s == NULL);
+        captop = stack->caplevel;
+        p = stack->p;
+        continue;
+      }
+      case ICloseRunTime: {
+        int fr = lua_gettop(L) + 1;  /* stack index of first result */
+        int ncap = runtimecap(L, capture + captop, capture, o, s, ptop);
+        lua_Integer res = lua_tointeger(L, fr) - 1;  /* offset */
+        int n = lua_gettop(L) - fr;  /* number of new captures */
+        if (res == -1) {  /* may not be a number */
+          if (!lua_toboolean(L, fr)) {  /* false value? */
+            lua_settop(L, fr - 1);  /* remove results */
+            goto fail;  /* and fail */
+          }
+          else if (lua_isboolean(L, fr))  /* true? */
+            res = s - o;  /* keep current position */
+        }
+        if (res < s - o || res > e - o)
+          luaL_error(L, "invalid position returned by match-time capture");
+        s = o + res;  /* update current position */
+        captop -= ncap;  /* remove nested captures */
+        lua_remove(L, fr);  /* remove first result (offset) */
+        if (n > 0) {  /* captures? */
+          if ((captop += n + 1) >= capsize) {
+            capture = doublecap(L, capture, captop, ptop);
+            capsize = 2 * captop;
+          }
+          adddyncaptures(s, capture + captop - n - 1, n, fr);
+        }
+        p++;
+        continue;
+      }
+      case ICloseCapture: {
+        const char *s1 = s - getoff(p);
+        assert(captop > 0);
+        if (capture[captop - 1].siz == 0 &&
+            s1 - capture[captop - 1].s < UCHAR_MAX) {
+          capture[captop - 1].siz = s1 - capture[captop - 1].s + 1;
+          p++;
+          continue;
+        }
+        else {
+          capture[captop].siz = 1;  /* mark entry as closed */
+          goto capture;
+        }
+      }
+      case IEmptyCapture: case IEmptyCaptureIdx:
+        capture[captop].siz = 1;  /* mark entry as closed */
+        goto capture;
+      case IOpenCapture:
+        capture[captop].siz = 0;  /* mark entry as open */
+        goto capture;
+      case IFullCapture:
+        capture[captop].siz = getoff(p) + 1;  /* save capture size */
+      capture: {
+        capture[captop].s = s - getoff(p);
+        capture[captop].idx = p->i.offset;
+        capture[captop].kind = getkind(p);
+        if (++captop >= capsize) {
+          capture = doublecap(L, capture, captop, ptop);
+          capsize = 2 * captop;
+        }
+        p++;
+        continue;
+      }
+      case IOpenCall: {
+        lua_rawgeti(L, penvidx(ptop), p->i.offset);
+        luaL_error(L, "reference to %s outside a grammar", val2str(L, -1));
+      }
+      default: assert(0); return NULL;
+    }
+  }
+}
+
+/* }====================================================== */
+
+
+/*
+** {======================================================
+** Verifier
+** =======================================================
+*/
+
+
+static int verify (lua_State *L, Instruction *op, const Instruction *p,
+                   Instruction *e, int postable, int rule) {
+  static const char dummy[] = "";
+  Stack back[MAXBACK];
+  int backtop = 0;  /* point to first empty slot in back */
+  while (p != e) {
+    switch ((Opcode)p->i.code) {
+      case IRet: {
+        p = back[--backtop].p;
+        continue;
+      }
+      case IChoice: {
+        if (backtop >= MAXBACK)
+          return luaL_error(L, "too many pending calls/choices");
+        back[backtop].p = dest(0, p);
+        back[backtop++].s = dummy;
+        p++;
+        continue;
+      }
+      case ICall: {
+        assert((p + 1)->i.code != IRet);  /* no tail call */
+        if (backtop >= MAXBACK)
+          return luaL_error(L, "too many pending calls/choices");
+        back[backtop].s = NULL;
+        back[backtop++].p = p + 1;
+        goto dojmp;
+      }
+      case IOpenCall: {
+        int i;
+        if (postable == 0)  /* grammar still not fixed? */
+          goto fail;  /* to be verified later */
+        for (i = 0; i < backtop; i++) {
+          if (back[i].s == NULL && back[i].p == p + 1)
+            return luaL_error(L, "%s is left recursive", val2str(L, rule));
+        }
+        if (backtop >= MAXBACK)
+          return luaL_error(L, "too many pending calls/choices");
+        back[backtop].s = NULL;
+        back[backtop++].p = p + 1;
+        p = op + getposition(L, postable, p->i.offset);
+        continue;
+      }
+      case IBackCommit:
+      case ICommit: {
+        assert(backtop > 0 && p->i.offset > 0);
+        backtop--;
+        goto dojmp;
+      }
+      case IPartialCommit: {
+        assert(backtop > 0);
+        if (p->i.offset > 0) goto dojmp;  /* forward jump */
+        else {  /* loop will be detected when checking corresponding rule */
+          assert(postable != 0);
+          backtop--;
+          p++;  /* just go on now */
+          continue;
+        }
+      }
+      case IAny:
+      case IChar:
+      case ISet: {
+        if (p->i.offset == 0) goto fail;
+        /* else goto dojmp; go through */
+      }
+      case IJmp: 
+      dojmp: {
+        p += p->i.offset;
+        continue;
+      }
+      case IFailTwice:  /* 'not' predicate */
+        goto fail;  /* body could have failed; try to backtrack it */
+      case IFail: {
+        if (p > op && (p - 1)->i.code == IBackCommit) {  /* 'and' predicate? */
+          p++;  /* pretend it succeeded and go ahead */
+          continue;
+        }
+        /* else failed: go through */
+      }
+      fail: { /* pattern failed: try to backtrack */
+        do {
+          if (backtop-- == 0)
+            return 1;  /* no more backtracking */
+        } while (back[backtop].s == NULL);
+        p = back[backtop].p;
+        continue;
+      }
+      case ISpan:
+      case IOpenCapture: case ICloseCapture:
+      case IEmptyCapture: case IEmptyCaptureIdx:
+      case IFullCapture: {
+        p += sizei(p);
+        continue;
+      }
+      case ICloseRunTime: {
+        goto fail;  /* be liberal in this case */
+      }
+      case IFunc: {
+        const char *r = (p+1)->f((p+2)->buff, dummy, dummy, dummy);
+        if (r == NULL) goto fail;
+        p += p->i.offset;
+        continue;
+      }
+      case IEnd:  /* cannot happen (should stop before it) */
+      default: assert(0); return 0;
+    }
+  }
+  assert(backtop == 0);
+  return 0;
+}
+
+
+static void checkrule (lua_State *L, Instruction *op, int from, int to,
+                       int postable, int rule) {
+  int i;
+  int lastopen = 0;  /* more recent OpenCall seen in the code */
+  for (i = from; i < to; i += sizei(op + i)) {
+    if (op[i].i.code == IPartialCommit && op[i].i.offset < 0) {  /* loop? */
+      int start = dest(op, i);
+      assert(op[start - 1].i.code == IChoice && dest(op, start - 1) == i + 1);
+      if (start <= lastopen) {  /* loop does contain an open call? */
+        if (!verify(L, op, op + start, op + i, postable, rule)) /* check body */
+          luaL_error(L, "possible infinite loop in %s", val2str(L, rule));
+      }
+    }
+    else if (op[i].i.code == IOpenCall)
+      lastopen = i;
+  }
+  assert(op[i - 1].i.code == IRet);
+  verify(L, op, op + from, op + to - 1, postable, rule);
+}
+
+
+
+
+/* }====================================================== */
+
+
+
+
+/*
+** {======================================================
+** Building Patterns
+** =======================================================
+*/
+
+enum charsetanswer { NOINFO, ISCHARSET, VALIDSTARTS };
+
+typedef struct CharsetTag {
+  enum charsetanswer tag;
+  Charset cs;
+} CharsetTag;
+
+
+static Instruction *getpatt (lua_State *L, int idx, int *size);
+
+
+static void check2test (Instruction *p, int n) {
+  assert(ischeck(p) && n != 0);
+  p->i.offset = n;
+}
+
+
+/*
+** invert array slice p[0]-p[e] (both inclusive)
+*/
+static void invert (Instruction *p, int e) {
+  int i;
+  for (i = 0; i < e; i++, e--) {
+    Instruction temp = p[i];
+    p[i] = p[e];
+    p[e] = temp;
+  }
+}
+
+
+/*
+** rotate array slice p[0]-p[e] (both inclusive) 'n' steps
+** to the 'left'
+*/
+static void rotate (Instruction *p, int e, int n) {
+  invert(p, n - 1);
+  invert(p + n, e - n);
+  invert(p, e);
+}
+
+
+#define op_step(p)	((p)->i.code == IAny ? (p)->i.aux : 1)
+
+
+static int skipchecks (Instruction *p, int up, int *pn) {
+  int i, n = 0;
+  for (i = 0; ischeck(p + i); i += sizei(p + i)) {
+    int st = op_step(p + i);
+    if (n + st > MAXOFF - up) break;
+    n += st;
+  }
+  *pn = n;
+  return i;
+}
+
+
+#define ismovablecap(op)	(ismovable(op) && getoff(op) < MAXOFF)
+
+static void optimizecaptures (Instruction *p) {
+  int i;
+  int limit = 0;
+  for (i = 0; p[i].i.code != IEnd; i += sizei(p + i)) {
+    if (isjmp(p + i) && dest(p, i) >= limit)
+      limit = dest(p, i) + 1;  /* do not optimize jump targets */
+    else if (i >= limit && ismovablecap(p + i) && ischeck(p + i + 1)) {
+      int end, n, j;  /* found a border capture|check */
+      int maxoff = getoff(p + i);
+      int start = i;
+      /* find first capture in the group */
+      while (start > limit && ismovablecap(p + start - 1)) {
+        start--;
+        if (getoff(p + start) > maxoff) maxoff = getoff(p + start);
+      }
+      end = skipchecks(p + i + 1, maxoff, &n) + i;  /* find last check */
+      if (n == 0) continue;  /* first check is too big to move across */
+      assert(n <= MAXOFF && start <= i && i < end);
+      for (j = start; j <= i; j++)
+        p[j].i.aux += (n << 4);  /* correct offset of captures to be moved */
+      rotate(p + start, end - start, i - start + 1);  /* move them up */
+      i = end;
+      assert(ischeck(p + start) && iscapture(p + i));
+    }
+  }
+}
+
+
+static int target (Instruction *p, int i) {
+  while (p[i].i.code == IJmp)  i += p[i].i.offset;
+  return i;
+}
+
+
+static void optimizejumps (Instruction *p) {
+  int i;
+  for (i = 0; p[i].i.code != IEnd; i += sizei(p + i)) {
+    if (isjmp(p + i))
+      p[i].i.offset = target(p, dest(p, i)) - i;
+  }
+}
+
+
+static void optimizechoice (Instruction *p) {
+  assert(p->i.code == IChoice);
+  if (ischeck(p + 1)) {
+    int lc = sizei(p + 1);
+    rotate(p, lc, 1);
+    assert(ischeck(p) && (p + lc)->i.code == IChoice);
+    (p + lc)->i.aux = op_step(p);
+    check2test(p, (p + lc)->i.offset);
+    (p + lc)->i.offset -= lc;
+  }
+}
+
+
+/*
+** A 'headfail' pattern is a pattern that can only fails in its first
+** instruction, which must be a check.
+*/
+static int isheadfail (Instruction *p) {
+  if (!ischeck(p)) return 0;
+  /* check that other operations cannot fail */
+  for (p += sizei(p); p->i.code != IEnd; p += sizei(p))
+    if (!isnofail(p)) return 0;
+  return 1;
+}
+
+
+#define checkpattern(L, idx) ((Instruction *)luaL_checkudata(L, idx, PATTERN_T))
+
+
+static int jointable (lua_State *L, int p1) {
+  int n, n1, i;
+  lua_getfenv(L, p1);
+  n1 = lua_objlen(L, -1);  /* number of elements in p1's env */
+  lua_getfenv(L, -2);
+  if (n1 == 0 || lua_equal(L, -2, -1)) {
+    lua_pop(L, 2);
+    return 0;  /* no need to change anything */
+  }
+  n = lua_objlen(L, -1);  /* number of elements in p's env */
+  if (n == 0) {
+    lua_pop(L, 1);  /* removes p env */
+    lua_setfenv(L, -2);  /* p now shares p1's env */
+    return 0;  /* no need to correct anything */
+  }
+  lua_createtable(L, n + n1, 0);
+  /* stack: p; p1 env; p env; new p env */
+  for (i = 1; i <= n; i++) {
+    lua_rawgeti(L, -2, i);
+    lua_rawseti(L, -2, i);
+  }
+  for (i = 1; i <= n1; i++) {
+    lua_rawgeti(L, -3, i);
+    lua_rawseti(L, -2, n + i);
+  }
+  lua_setfenv(L, -4);  /* new table becomes p env */
+  lua_pop(L, 2);  /* remove p1 env and old p env */
+  return n;
+}
+
+
+#define copypatt(p1,p2,sz)	memcpy(p1, p2, (sz) * sizeof(Instruction));
+
+#define pattsize(L,idx)		(lua_objlen(L, idx)/sizeof(Instruction) - 1)
+
+
+static int addpatt (lua_State *L, Instruction *p, int p1idx) {
+  Instruction *p1 = (Instruction *)lua_touserdata(L, p1idx);
+  int sz = pattsize(L, p1idx);
+  int corr = jointable(L, p1idx);
+  copypatt(p, p1, sz + 1);
+  if (corr != 0) {
+    Instruction *px;
+    for (px = p; px < p + sz; px += sizei(px)) {
+      if (isfenvoff(px) && px->i.offset != 0)
+        px->i.offset += corr;
+    }
+  }
+  return sz;
+}
+
+
+static void setinstaux (Instruction *i, Opcode op, int offset, int aux) {
+  i->i.code = op;
+  i->i.offset = offset;
+  i->i.aux = aux;
+}
+
+#define setinst(i,op,off)	setinstaux(i,op,off,0)
+
+#define setinstcap(i,op,idx,k,n)  setinstaux(i,op,idx,((k) | ((n) << 4)))
+
+
+static int value2fenv (lua_State *L, int vidx) {
+  lua_createtable(L, 1, 0);
+  lua_pushvalue(L, vidx);
+  lua_rawseti(L, -2, 1);
+  lua_setfenv(L, -2);
+  return 1;
+}
+
+
+static Instruction *newpatt (lua_State *L, size_t n) {
+  Instruction *p;
+  if (n >= MAXPATTSIZE - 1)
+    luaL_error(L, "pattern too big");
+  p = (Instruction *)lua_newuserdata(L, (n + 1) * sizeof(Instruction));
+  luaL_getmetatable(L, PATTERN_T);
+  lua_setmetatable(L, -2);
+  setinst(p + n, IEnd, 0);
+  return p;
+}
+
+
+static void fillcharset (Instruction *p, Charset cs) {
+  switch (p[0].i.code) {
+    case ISet: {
+      loopset(i, cs[i] = p[1].buff[i]);
+      break;
+    }
+    case IChar: {
+      loopset(i, cs[i] = 0);
+      setchar(cs, p[0].i.aux);
+      break;
+    }
+    default: {  /* any char may start unhandled instructions */
+      loopset(i, cs[i] = 0xff);
+      break;
+    }
+  }
+}
+
+
+/*
+** Function 'tocharset' gets information about which chars may be a
+** valid start for a pattern.
+*/
+
+static enum charsetanswer tocharset (Instruction *p, CharsetTag *c) {
+  if (ischeck(p)) {
+    fillcharset(p, c->cs);
+    if ((p + sizei(p))->i.code == IEnd && op_step(p) == 1)
+      c->tag = ISCHARSET;
+    else
+      c->tag = VALIDSTARTS;
+  }
+  else
+    c->tag = NOINFO;
+  return c->tag;
+}
+
+
+static int exclusiveset (Charset c1, Charset c2) {
+  /* non-empty intersection? */
+  loopset(i, {if ((c1[i] & c2[i]) != 0) return 0;});
+  return 1;  /* no intersection */
+}
+
+
+static int exclusive (CharsetTag *c1, CharsetTag *c2) {
+  if (c1->tag == NOINFO || c2->tag == NOINFO)
+    return 0;  /* one of them is not filled */
+  else return exclusiveset(c1->cs, c2->cs);
+}
+
+
+static Instruction *newcharset (lua_State *L) {
+  Instruction *p = newpatt(L, CHARSETINSTSIZE);
+  p[0].i.code = ISet;
+  p[0].i.offset = 0;
+  loopset(i, p[1].buff[i] = 0);
+  return p;
+}
+
+
+static int set_l (lua_State *L) {
+  size_t l;
+  const char *s = luaL_checklstring(L, 1, &l);
+  if (l == 1)
+    getpatt(L, 1, NULL);  /* a unit set is equivalent to a literal */
+  else {
+    Instruction *p = newcharset(L);
+    while (l--) {
+      setchar(p[1].buff, (byte)(*s));
+      s++;
+    }
+  }
+  return 1;
+}
+
+
+static int range_l (lua_State *L) {
+  int arg;
+  int top = lua_gettop(L);
+  Instruction *p = newcharset(L);
+  for (arg = 1; arg <= top; arg++) {
+    int c;
+    size_t l;
+    const char *r = luaL_checklstring(L, arg, &l);
+    luaL_argcheck(L, l == 2, arg, "range must have two characters");
+    for (c = (byte)r[0]; c <= (byte)r[1]; c++)
+      setchar(p[1].buff, c);
+  }
+  return 1;
+}
+
+
+static int nter_l (lua_State *L) {
+  Instruction *p;
+  luaL_argcheck(L, !lua_isnoneornil(L, 1), 1, "non-nil value expected");
+  p = newpatt(L, 1);
+  setinst(p, IOpenCall, value2fenv(L, 1));
+  return 1;
+}
+
+
+
+static int testpattern (lua_State *L, int idx) {
+  if (lua_touserdata(L, idx)) {  /* value is a userdata? */
+    if (lua_getmetatable(L, idx)) {  /* does it have a metatable? */
+      luaL_getmetatable(L, PATTERN_T);
+      if (lua_rawequal(L, -1, -2)) {  /* does it have the correct mt? */
+        lua_pop(L, 2);  /* remove both metatables */
+        return 1;
+      }
+    }
+  }
+  return 0;
+}
+
+
+static Instruction *fix_l (lua_State *L, int t) {
+  Instruction *p;
+  int i;
+  int totalsize = 2;  /* include initial call and jump */
+  int n = 0;  /* number of rules */
+  int base = lua_gettop(L);
+  lua_newtable(L);  /* to store relative positions of each rule */
+  lua_pushinteger(L, 1);  /* default initial rule */
+  /* collect patterns and compute sizes */
+  lua_pushnil(L);
+  while (lua_next(L, t) != 0) {
+    int l;
+    if (lua_tonumber(L, -2) == 1 && lua_isstring(L, -1)) {
+      lua_replace(L, base + 2);  /* use this value as initial rule */
+      continue;
+    }
+    if (!testpattern(L, -1))
+      luaL_error(L, "invalid field in grammar");
+    l = pattsize(L, -1) + 1;  /* space for pattern + ret */
+    if (totalsize >= MAXPATTSIZE - l)
+      luaL_error(L, "grammar too large");
+    luaL_checkstack(L, LUA_MINSTACK, "grammar has too many rules");
+    lua_insert(L, -2);  /* put key on top */
+    lua_pushvalue(L, -1);  /* duplicate key (for lua_next) */
+    lua_pushvalue(L, -1);  /* duplicate key (to index positions table)) */
+    lua_pushinteger(L, totalsize);  /* position for this rule */
+    lua_settable(L, base + 1);  /* store key=>position in positions table */
+    totalsize += l;
+    n++;
+  }
+  luaL_argcheck(L, n > 0, t, "empty grammar");
+  p = newpatt(L, totalsize);  /* create new pattern */
+  p++;  /* save space for call */
+  setinst(p++, IJmp, totalsize - 1);  /* after call, jumps to the end */
+  for (i = 1; i <= n; i++) {  /* copy all rules into new pattern */
+    p += addpatt(L, p, base + 1 + i*2);
+    setinst(p++, IRet, 0);
+  }
+  p -= totalsize;  /* back to first position */
+  totalsize = 2;  /* go through each rule's position */
+  for (i = 1; i <= n; i++) {  /* check all rules */
+    int l = pattsize(L, base + 1 + i*2) + 1;
+    checkrule(L, p, totalsize, totalsize + l, base + 1, base + 2 + i*2);
+    totalsize += l;
+  }
+  lua_pushvalue(L, base + 2);  /* get initial rule */
+  lua_gettable(L, base + 1);  /* get its position in postions table */
+  i = lua_tonumber(L, -1);  /* convert to number */
+  lua_pop(L, 1);
+  if (i == 0)  /* is it defined? */
+    luaL_error(L, "initial rule not defined in given grammar");
+  setinst(p, ICall, i);  /* first instruction calls initial rule */
+  /* correct calls */
+  for (i = 0; i < totalsize; i += sizei(p + i)) {
+    if (p[i].i.code == IOpenCall) {
+      int pos = getposition(L, base + 1, p[i].i.offset);
+      p[i].i.code = (p[target(p, i + 1)].i.code == IRet) ? IJmp : ICall;
+      p[i].i.offset = pos - i;
+    }
+  }
+  optimizejumps(p);
+  lua_replace(L, t);  /* put new pattern in old's position */
+  lua_settop(L, base);  /* remove rules and positions table */
+  return p;
+}
+
+
+static Instruction *any (lua_State *L, int n, int extra, int *offsetp) {
+  int offset = offsetp ? *offsetp : 0;
+  Instruction *p = newpatt(L, (n - 1)/UCHAR_MAX + extra + 1);
+  Instruction *p1 = p + offset;
+  for (; n > UCHAR_MAX; n -= UCHAR_MAX)
+    setinstaux(p1++, IAny, 0, UCHAR_MAX);
+  setinstaux(p1++, IAny, 0, n);
+  if (offsetp) *offsetp = p1 - p;
+  return p;
+}
+
+
+static Instruction *getpatt (lua_State *L, int idx, int *size) {
+  Instruction *p;
+  switch (lua_type(L, idx)) {
+    case LUA_TSTRING: {
+      size_t i, len;
+      const char *s = lua_tolstring(L, idx, &len);
+      p = newpatt(L, len);
+      for (i = 0; i < len; i++)
+        setinstaux(p + i, IChar, 0, (byte)s[i]);
+      lua_replace(L, idx);
+      break;
+    }
+    case LUA_TNUMBER: {
+      int n = lua_tointeger(L, idx);
+      if (n == 0)  /* empty pattern? */
+        p = newpatt(L, 0);
+      else if (n > 0)
+        p = any(L, n, 0, NULL);
+      else if (-n <= UCHAR_MAX) {
+        p = newpatt(L, 2);
+        setinstaux(p, IAny, 2, -n);
+        setinst(p + 1, IFail, 0);
+      }
+      else {
+        int offset = 2;  /* space for ITestAny & IChoice */
+        p = any(L, -n - UCHAR_MAX, 3, &offset);
+        setinstaux(p, IAny, offset + 1, UCHAR_MAX);
+        setinstaux(p + 1, IChoice, offset, UCHAR_MAX);
+        setinst(p + offset, IFailTwice, 0);
+      }
+      lua_replace(L, idx);
+      break;
+    }
+    case LUA_TBOOLEAN: {
+      if (lua_toboolean(L, idx))  /* true? */
+        p = newpatt(L, 0);  /* empty pattern (always succeeds) */
+      else {
+        p = newpatt(L, 1);
+        setinst(p, IFail, 0);
+      }
+      lua_replace(L, idx);
+      break;
+    }
+    case LUA_TTABLE: {
+      p = fix_l(L, idx);
+      break;
+    }
+    case LUA_TFUNCTION: {
+      p = newpatt(L, 2);
+      setinstcap(p, IOpenCapture, value2fenv(L, idx), Cruntime, 0);
+      setinstcap(p + 1, ICloseRunTime, 0, Cclose, 0);
+      lua_replace(L, idx);
+      break;
+    }
+    default: {
+      p = checkpattern(L, idx);
+      break;
+    }
+  }
+  if (size) *size = pattsize(L, idx);
+  return p;
+}
+
+
+static int getpattl (lua_State *L, int idx) {
+  int size;
+  getpatt(L, idx, &size);
+  return size;
+}
+
+
+static int pattern_l (lua_State *L) {
+  lua_settop(L, 1);
+  getpatt(L, 1, NULL);
+  return 1;
+}
+
+
+#define isany(p)	((p)->i.code == IAny && ((p) + 1)->i.code == IEnd)
+#define isfail(p)	((p)->i.code == IFail)
+#define issucc(p)	((p)->i.code == IEnd)
+
+static int concat_l (lua_State *L) {
+  /* p1; p2; */
+  int l1, l2;
+  Instruction *p1 = getpatt(L, 1, &l1);
+  Instruction *p2 = getpatt(L, 2, &l2);
+  if (isfail(p1) || issucc(p2))
+    lua_pushvalue(L, 1);  /* fail * x == fail; x * true == x */
+  else if (isfail(p2) || issucc(p1))
+    lua_pushvalue(L, 2);  /* x * fail == fail; true * x == x */
+  else if (isany(p1) && isany(p2))
+    any(L, p1->i.aux + p2->i.aux, 0, NULL);
+  else {
+    Instruction *op = newpatt(L, l1 + l2);
+    Instruction *p = op + addpatt(L, op, 1);
+    addpatt(L, p, 2);
+    optimizecaptures(op);
+  }
+  return 1;
+}
+
+
+static int diff_l (lua_State *L) {
+  int l1, l2;
+  Instruction *p1 = getpatt(L, 1, &l1);
+  Instruction *p2 = getpatt(L, 2, &l2);
+  CharsetTag st1, st2;
+  if (tocharset(p1, &st1) == ISCHARSET && tocharset(p2, &st2) == ISCHARSET) {
+    Instruction *p = newcharset(L);
+    loopset(i, p[1].buff[i] = st1.cs[i] & ~st2.cs[i]);
+  }
+  else if (isheadfail(p2)) {
+    Instruction *p = newpatt(L, l2 + 1 + l1);
+    p += addpatt(L, p, 2);
+    check2test(p - l2, l2 + 1);
+    setinst(p++, IFail, 0);
+    addpatt(L, p, 1);
+  }
+  else {  /* !e2 . e1 */
+    /* !e -> choice L1; e; failtwice; L1: ... */
+    Instruction *p = newpatt(L, 1 + l2 + 1 + l1);
+    Instruction *pi = p;
+    setinst(p++, IChoice, 1 + l2 + 1);
+    p += addpatt(L, p, 2);
+    setinst(p++, IFailTwice, 0);
+    addpatt(L, p, 1);
+    optimizechoice(pi);
+  }
+  return 1;
+}
+
+
+static int unm_l (lua_State *L) {
+  Instruction *p = getpatt(L, 1, NULL);
+  if (isfail(p)) {  /* -false? */
+    newpatt(L, 0);  /* true */
+    return 1;
+  }
+  else if (issucc(p)) {  /* -true? */
+    Instruction *p1 = newpatt(L, 1);  /* false */
+    setinst(p1, IFail, 0);
+    return 1;
+  }
+  else {  /* -A == '' - A */
+    lua_pushliteral(L, "");
+    lua_insert(L, 1);
+    return diff_l(L);
+  }
+}
+
+
+static int pattand_l (lua_State *L) {
+  int l1;
+  Instruction *p1 = getpatt(L, 1, &l1);
+  CharsetTag st1;
+  if (isfail(p1) || issucc(p1))
+    lua_pushvalue(L, 1);  /* &fail == fail; &true == true */
+  else if (tocharset(p1, &st1) == ISCHARSET) {
+    Instruction *p = newpatt(L, CHARSETINSTSIZE + 1);
+    setinst(p, ISet, CHARSETINSTSIZE + 1);
+    loopset(i, p[1].buff[i] = ~st1.cs[i]);
+    setinst(p + CHARSETINSTSIZE, IFail, 0);
+  }
+  else {
+    Instruction *p = newpatt(L, 1 + l1 + 2);
+    setinst(p++, IChoice, 1 + l1 + 1);
+    p += addpatt(L, p, 1);
+    setinst(p++, IBackCommit, 2);
+    setinst(p, IFail, 0);
+  }
+  return 1;
+}
+
+
+static int firstpart (Instruction *p, int l) {
+  if (istest(p)) {
+    int e = p[0].i.offset - 1;
+    if ((p[e].i.code == IJmp || p[e].i.code == ICommit) &&
+        e + p[e].i.offset == l)
+      return e + 1;
+  }
+  else if (p[0].i.code == IChoice) {
+    int e = p[0].i.offset - 1;
+    if (p[e].i.code == ICommit && e + p[e].i.offset == l)
+      return e + 1;
+  }
+  return 0;
+}
+
+
+static Instruction *auxnew (lua_State *L, Instruction **op, int *size,
+                                         int extra) {
+  *op = newpatt(L, *size + extra);
+  jointable(L, 1);
+  *size += extra;
+  return *op + *size - extra;
+}
+
+
+static int nofail (Instruction *p, int l) {
+  int i;
+  for (i = 0; i < l; i += sizei(p + i)) {
+    if (!isnofail(p + i)) return 0;
+  }
+  return 1;
+}
+
+
+static int interfere (Instruction *p1, int l1, CharsetTag *st2) {
+  if (nofail(p1, l1))  /* p1 cannot fail? */
+    return 0;  /* nothing can intefere with it */
+  if (st2->tag == NOINFO) return 1;
+  assert(p1->i.offset != 0);
+  switch (p1->i.code) {
+    case IChar: return testchar(st2->cs, p1->i.aux);
+    case ISet: return !exclusiveset(st2->cs, (p1 + 1)->buff);
+    default: assert(p1->i.code == IAny); return 1;
+  }
+}
+
+
+static Instruction *basicUnion (lua_State *L, Instruction *p1, int l1,
+                                int l2, int *size, CharsetTag *st2) {
+  Instruction *op;
+  CharsetTag st1;
+  tocharset(p1, &st1);
+  if (st1.tag == ISCHARSET && st2->tag == ISCHARSET) {
+    Instruction *p = auxnew(L, &op, size, CHARSETINSTSIZE);
+    setinst(p, ISet, 0);
+    loopset(i, p[1].buff[i] = st1.cs[i] | st2->cs[i]);
+  }
+  else if (exclusive(&st1, st2) || isheadfail(p1)) {
+    Instruction *p = auxnew(L, &op, size, l1 + 1 + l2);
+    copypatt(p, p1, l1);
+    check2test(p, l1 + 1);
+    p += l1;
+    setinst(p++, IJmp, l2 + 1);
+    addpatt(L, p, 2);
+  }
+  else {
+    /* choice L1; e1; commit L2; L1: e2; L2: ... */
+    Instruction *p = auxnew(L, &op, size, 1 + l1 + 1 + l2);
+    setinst(p++, IChoice, 1 + l1 + 1);
+    copypatt(p, p1, l1); p += l1;
+    setinst(p++, ICommit, 1 + l2);
+    addpatt(L, p, 2);
+    optimizechoice(p - (1 + l1 + 1));
+  }
+  return op;
+}
+
+
+static Instruction *separateparts (lua_State *L, Instruction *p1, int l1,
+                                   int l2, int *size, CharsetTag *st2) {
+  int sp = firstpart(p1, l1);
+  if (sp == 0)  /* first part is entire p1? */
+    return basicUnion(L, p1, l1, l2, size, st2);
+  else if ((p1 + sp - 1)->i.code == ICommit || !interfere(p1, sp, st2)) {
+    Instruction *p;
+    int init = *size;
+    int end = init + sp;
+    *size = end;
+    p = separateparts(L, p1 + sp, l1 - sp, l2, size, st2);
+    copypatt(p + init, p1, sp);
+    (p + end - 1)->i.offset = *size - (end - 1);
+    return p;
+  }
+  else {  /* must change back to non-optimized choice */
+    Instruction *p;
+    int init = *size;
+    int end = init + sp + 1;  /* needs one extra instruction (choice) */
+    int sizefirst = sizei(p1);  /* size of p1's first instruction (the test) */
+    *size = end;
+    p = separateparts(L, p1 + sp, l1 - sp, l2, size, st2);
+    copypatt(p + init, p1, sizefirst);  /* copy the test */
+    (p + init)->i.offset++;  /* correct jump (because of new instruction) */
+    init += sizefirst;
+    setinstaux(p + init, IChoice, sp - sizefirst + 1, 1); init++;
+    copypatt(p + init, p1 + sizefirst, sp - sizefirst - 1);
+    init += sp - sizefirst - 1;
+    setinst(p + init, ICommit, *size - (end - 1));
+    return p;
+  }
+}
+
+
+static int union_l (lua_State *L) {
+  int l1, l2;
+  int size = 0;
+  Instruction *p1 = getpatt(L, 1, &l1);
+  Instruction *p2 = getpatt(L, 2, &l2);
+  CharsetTag st2;
+  if (isfail(p1))  /* check for simple identities */
+    lua_pushvalue(L, 2);  /* fail / a == a */
+  else if (isfail(p2) || issucc(p1))
+    lua_pushvalue(L, 1);  /* a / fail == a; true / a == true */
+  else {
+    tocharset(p2, &st2);
+    separateparts(L, p1, l1, l2, &size, &st2);
+  }
+  return 1;
+}
+
+
+static int repeatcharset (lua_State *L, Charset cs, int l1, int n) {
+  /* e; ...; e; span; */
+  int i;
+  Instruction *p = newpatt(L, n*l1 + CHARSETINSTSIZE);
+  for (i = 0; i < n; i++) {
+    p += addpatt(L, p, 1);
+  }
+  setinst(p, ISpan, 0);
+  loopset(k, p[1].buff[k] = cs[k]);
+  return 1;
+}
+
+
+static Instruction *repeatheadfail (lua_State *L, int l1, int n) {
+  /* e; ...; e; L2: e'(L1); jump L2; L1: ... */
+  int i;
+  Instruction *p = newpatt(L, (n + 1)*l1 + 1);
+  Instruction *op = p;
+  for (i = 0; i < n; i++) {
+    p += addpatt(L, p, 1);
+  }
+  p += addpatt(L, p, 1);
+  check2test(p - l1, l1 + 1);
+  setinst(p, IJmp, -l1);
+  return op;
+}
+
+
+static Instruction *repeats (lua_State *L, Instruction *p1, int l1, int n) {
+  /* e; ...; e; choice L1; L2: e; partialcommit L2; L1: ... */
+  int i;
+  Instruction *op = newpatt(L, (n + 1)*l1 + 2);
+  Instruction *p = op;
+  if (!verify(L, p1, p1, p1 + l1, 0, 0))
+    luaL_error(L, "loop body may accept empty string");
+  for (i = 0; i < n; i++) {
+    p += addpatt(L, p, 1);
+  }
+  setinst(p++, IChoice, 1 + l1 + 1);
+  p += addpatt(L, p, 1);
+  setinst(p, IPartialCommit, -l1);
+  return op;
+}
+
+
+static void optionalheadfail (lua_State *L, int l1, int n) {
+  Instruction *op = newpatt(L, n * l1);
+  Instruction *p = op;
+  int i;
+  for (i = 0; i < n; i++) {
+    p += addpatt(L, p, 1);
+    check2test(p - l1, (n - i)*l1);
+  }
+}
+
+
+static void optionals (lua_State *L, int l1, int n) {
+  /* choice L1; e; partialcommit L2; L2: ... e; L1: commit L3; L3: ... */
+  int i;
+  Instruction *op = newpatt(L, n*(l1 + 1) + 1);
+  Instruction *p = op;
+  setinst(p++, IChoice, 1 + n*(l1 + 1));
+  for (i = 0; i < n; i++) {
+    p += addpatt(L, p, 1);
+    setinst(p++, IPartialCommit, 1);
+  }
+  setinst(p - 1, ICommit, 1);  /* correct last commit */
+  optimizechoice(op);
+}
+
+
+static int star_l (lua_State *L) {
+  int l1;
+  int n = luaL_checkint(L, 2);
+  Instruction *p1 = getpatt(L, 1, &l1);
+  if (n >= 0) {
+    CharsetTag st;
+    Instruction *op;
+    if (tocharset(p1, &st) == ISCHARSET)
+      return repeatcharset(L, st.cs, l1, n);
+    if (isheadfail(p1))
+      op = repeatheadfail(L, l1, n);
+    else
+      op = repeats(L, p1, l1, n);
+    optimizecaptures(op);
+    optimizejumps(op);
+  }
+  else {
+    if (isheadfail(p1))
+      optionalheadfail(L, l1, -n);
+    else
+      optionals(L, l1, -n);
+  }
+  return 1;
+}
+
+
+static int getlabel (lua_State *L, int labelidx) {
+  if (labelidx == 0) return 0;
+  else return value2fenv(L, labelidx);
+}
+
+
+static int capture_aux (lua_State *L, int kind, int labelidx) {
+  int l1, n;
+  Instruction *p1 = getpatt(L, 1, &l1);
+  int lc = skipchecks(p1, 0, &n);
+  if (lc == l1) {  /* got whole pattern? */
+    /* may use a IFullCapture instruction at its end */
+    Instruction *p = newpatt(L, l1 + 1);
+    int label = getlabel(L, labelidx);
+    p += addpatt(L, p, 1);
+    setinstcap(p, IFullCapture, label, kind, n);
+  }
+  else {  /* must use open-close pair */
+    Instruction *op = newpatt(L, 1 + l1 + 1);
+    Instruction *p = op;
+    setinstcap(p++, IOpenCapture, getlabel(L, labelidx), kind, 0);
+    p += addpatt(L, p, 1);
+    setinstcap(p, ICloseCapture, 0, Cclose, 0);
+    optimizecaptures(op);
+  }
+  return 1;
+}
+
+
+static int capture_l (lua_State *L) { return capture_aux(L, Csimple, 0); }
+static int tcapture_l (lua_State *L) { return capture_aux(L, Ctable, 0); }
+static int capsubst_l (lua_State *L) { return capture_aux(L, Csubst, 0); }
+
+static int rcapture_l (lua_State *L) {
+  switch (lua_type(L, 2)) {
+    case LUA_TFUNCTION: return capture_aux(L, Cfunction, 2);
+    case LUA_TTABLE: return capture_aux(L, Cquery, 2);
+    case LUA_TSTRING: return capture_aux(L, Cstring, 2);
+    default: return luaL_argerror(L, 2, "invalid replacement value");
+  }
+}
+
+
+static int fold_l (lua_State *L) {
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  return capture_aux(L, Cfold, 2);
+}
+
+
+static int group_l (lua_State *L) {
+  if (lua_isnoneornil(L, 2))
+    return capture_aux(L, Cgroup, 0);
+  else {
+    luaL_checkstring(L, 2);
+    return capture_aux(L, Cgroup, 2);
+  }
+}
+
+
+static int position_l (lua_State *L) {
+  Instruction *p = newpatt(L, 1);
+  setinstcap(p, IEmptyCapture, 0, Cposition, 0);
+  return 1;
+}
+
+
+static int backref_l (lua_State *L) {
+  Instruction *p = newpatt(L, 1);
+  int n = getlabel(L, 1);
+  setinstcap(p, IEmptyCaptureIdx, n, Cbackref, 0);
+  return 1;
+}
+
+
+static int argcap_l (lua_State *L) {
+  int n = luaL_checkint(L, 1);
+  Instruction *p = newpatt(L, 1);
+  luaL_argcheck(L, 0 < n && n <= SHRT_MAX, 1, "invalid argument index");
+  setinstcap(p, IEmptyCapture, n, Carg, 0);
+  return 1;
+}
+
+
+static int matchtime_l (lua_State *L) {
+  int l1 = getpattl(L, 1);
+  Instruction *op = newpatt(L, 1 + l1 + 1);
+  Instruction *p = op;
+  luaL_checktype(L, 2, LUA_TFUNCTION);
+  setinstcap(p++, IOpenCapture, value2fenv(L, 2), Cruntime, 0);
+  p += addpatt(L, p, 1);
+  setinstcap(p, ICloseRunTime, 0, Cclose, 0);
+  optimizecaptures(op);
+  return 1;
+}
+
+
+static int capconst_l (lua_State *L) {
+  int i, j;
+  int n = lua_gettop(L);
+  Instruction *p = newpatt(L, n > 1 ? n + 2 : n);
+  lua_createtable(L, n, 0);  /* new environment for the new pattern */
+  if (n > 1) setinstcap(p++, IOpenCapture, 0, Cgroup, 0);
+  for (i = j = 1; i <= n; i++) {
+    if (lua_isnil(L, i))
+      setinstcap(p++, IEmptyCaptureIdx, 0, Cconst, 0);
+    else {
+      setinstcap(p++, IEmptyCaptureIdx, j, Cconst, 0);
+      lua_pushvalue(L, i);
+      lua_rawseti(L, -2, j++);
+    }
+  }
+  if (n > 1) setinstcap(p++, ICloseCapture, 0, Cclose, 0);
+  lua_setfenv(L, -2);   /* set environment */
+  return 1;
+}
+
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** User-Defined Patterns
+** =======================================================
+*/
+
+static void newpattfunc (lua_State *L, PattFunc f, const void *ud, size_t l) {
+  int n = instsize(l) + 1;
+  Instruction *p = newpatt(L, n);
+  p[0].i.code = IFunc;
+  p[0].i.offset = n;
+  p[1].f = f;
+  memcpy(p[2].buff, ud, l);
+}
+
+
+#include <ctype.h>
+
+static const char *span (const void *ud, const char *o,
+                                         const char *s,
+                                         const char *e) {
+  const char *u = (const char *)ud;
+  (void)o; (void)e;
+  return s + strspn(s, u);
+}
+
+
+static int span_l (lua_State *L) {
+  const char *s = luaL_checkstring(L, 1);
+  newpattfunc(L, span, s, strlen(s) + 1);
+  return 1;
+}
+
+/* }====================================================== */
+
+
+
+/*
+** {======================================================
+** Captures
+** =======================================================
+*/
+
+
+typedef struct CapState {
+  Capture *cap;  /* current capture */
+  Capture *ocap;  /* (original) capture list */
+  lua_State *L;
+  int ptop;  /* index of last argument to 'match' */
+  const char *s;  /* original string */
+  int valuecached;  /* value stored in cache slot */
+} CapState;
+
+
+#define captype(cap)	((cap)->kind)
+
+#define isclosecap(cap)	(captype(cap) == Cclose)
+
+#define closeaddr(c)	((c)->s + (c)->siz - 1)
+
+#define isfullcap(cap)	((cap)->siz != 0)
+
+#define getfromenv(cs,v)	lua_rawgeti((cs)->L, penvidx((cs)->ptop), v)
+#define pushluaval(cs)		getfromenv(cs, (cs)->cap->idx)
+
+#define pushsubject(cs, c) lua_pushlstring((cs)->L, (c)->s, (c)->siz - 1)
+
+
+#define updatecache(cs,v) { if ((v) != (cs)->valuecached) updatecache_(cs,v); }
+
+
+static void updatecache_ (CapState *cs, int v) {
+  getfromenv(cs, v);
+  lua_replace(cs->L, subscache(cs));
+  cs->valuecached = v;
+}
+
+
+static int pushcapture (CapState *cs);
+
+
+static Capture *findopen (Capture *cap) {
+  int n = 0;
+  for (;;) {
+    cap--;
+    if (isclosecap(cap)) n++;
+    else if (!isfullcap(cap))
+      if (n-- == 0) return cap;
+  }
+}
+
+
+static Capture *nextcap (Capture *cap) {
+  if (isfullcap(cap)) return cap + 1;
+  else {
+    int n = 0;
+    for (;;) {
+      cap++;
+      if (isclosecap(cap)) {
+        if (n-- == 0) return cap + 1;
+      }
+      else if (!isfullcap(cap)) n++;
+    } 
+  }
+}
+
+
+static int pushallvalues (CapState *cs, int addextra) {
+  Capture *co = cs->cap;
+  int n = 0;
+  if (isfullcap(cs->cap++)) {
+    pushsubject(cs, co);  /* push whole match */
+    return 1;
+  }
+  while (!isclosecap(cs->cap))
+    n += pushcapture(cs);
+  if (addextra || n == 0) {  /* need extra? */
+    lua_pushlstring(cs->L, co->s, cs->cap->s - co->s);  /* push whole match */
+    n++;
+  }
+  cs->cap++;  /* skip close entry */
+  return n;
+}
+
+
+static Capture *findback (CapState *cs, Capture *cap) {
+  lua_State *L = cs->L;
+  for (;;) {
+    if (cap == cs->ocap) {  /* not found */
+      const char *s = lua_tostring(L, -1);
+      if (s == NULL) s = lua_pushfstring(L, "(a %s)", luaL_typename(L, -1));
+      luaL_error(L, "back reference '%s' not found", s);
+    }
+    cap--;
+    if (isclosecap(cap))
+      cap = findopen(cap);
+    else if (!isfullcap(cap))
+      continue; /* opening an enclosing capture: skip and get previous */
+    if (captype(cap) == Cgroup) {
+      getfromenv(cs, cap->idx);  /* get group name */
+      if (lua_equal(L, -2, -1)) {  /* right group? */
+        lua_pop(L, 2);  /* remove reference name and group name */
+        return cap;
+      }
+      else lua_pop(L, 1);  /* remove group name */
+    }
+  }
+}
+
+
+static int backrefcap (CapState *cs) {
+  int n;
+  Capture *curr = cs->cap;
+  pushluaval(cs);  /* reference name */
+  cs->cap = findback(cs, curr);
+  n = pushallvalues(cs, 0);
+  cs->cap = curr + 1;
+  return n;
+}
+
+
+static int tablecap (CapState *cs) {
+  lua_State *L = cs->L;
+  int n = 0;
+  lua_newtable(L);
+  if (isfullcap(cs->cap++))
+    return 1;  /* table is empty */
+  while (!isclosecap(cs->cap)) {
+    if (captype(cs->cap) == Cgroup && cs->cap->idx != 0) {  /* named group? */
+      int k;
+      pushluaval(cs);  /* push group name */
+      k = pushallvalues(cs, 0);
+      if (k == 0) {  /* no value? */
+        lua_pop(L, 1);  /* remove group name */
+        continue;  /* and go on */
+      }
+      else if (k > 1)
+        lua_pop(L, k - 1);  /* keep just one value */
+      lua_settable(L, -3);
+    }
+    else {
+      int i;
+      int k = pushcapture(cs);
+      for (i = k; i > 0; i--)
+        lua_rawseti(L, -(i + 1), n + i);
+      n += k;
+    }
+  }
+  cs->cap++;  /* skip close entry */
+  return 1;
+}
+
+
+static int querycap (CapState *cs) {
+  int idx = cs->cap->idx;
+  int n = pushallvalues(cs, 0);
+  if (n > 1)  /* extra captures? */
+    lua_pop(cs->L, n - 1);  /* throw them away */
+  updatecache(cs, idx);
+  lua_gettable(cs->L, subscache(cs));
+  if (!lua_isnil(cs->L, -1))
+    return 1;
+  else {
+    lua_pop(cs->L, 1);  /* remove value */
+    return 0;
+  }
+}
+
+
+static int foldcap (CapState *cs) {
+  int n;
+  lua_State *L = cs->L;
+  int idx = cs->cap->idx;
+  if (isfullcap(cs->cap++) || isclosecap(cs->cap) || (n = pushcapture(cs)) == 0)
+    return luaL_error(L, "no initial value for fold capture");
+  if (n > 1)
+    lua_pop(L, n - 1);  /* leave only one result */
+  while (!isclosecap(cs->cap)) {
+    updatecache(cs, idx);
+    lua_pushvalue(L, subscache(cs));  /* get folding function */
+    lua_insert(L, -2);  /* put it before accumulator */
+    n = pushcapture(cs);  /* get other captures */
+    lua_call(L, n + 1, 1);  /* call folding function */
+  }
+  cs->cap++;  /* skip close entry */
+  return 1;
+}
+
+
+static int functioncap (CapState *cs) {
+  int n;
+  int top = lua_gettop(cs->L);
+  pushluaval(cs);
+  n = pushallvalues(cs, 0);
+  lua_call(cs->L, n, LUA_MULTRET);
+  return lua_gettop(cs->L) - top;
+}
+
+
+static int runtimecap (lua_State *L, Capture *close, Capture *ocap,
+                       const char *o, const char *s, int ptop) {
+  CapState cs;
+  int n;
+  Capture *open = findopen(close);
+  assert(captype(open) == Cruntime);
+  close->kind = Cclose;
+  close->s = s;
+  cs.ocap = ocap; cs.cap = open; cs.L = L;
+  cs.s = o; cs.valuecached = 0; cs.ptop = ptop;
+  luaL_checkstack(L, 4, "too many runtime captures");
+  pushluaval(&cs);
+  lua_pushvalue(L, SUBJIDX);  /* push original subject */
+  lua_pushinteger(L, s - o + 1);  /* current position */
+  n = pushallvalues(&cs, 0);
+  lua_call(L, n + 2, LUA_MULTRET);
+  return close - open;
+}
+
+
+
+typedef struct StrAux {
+  int isstring;
+  union {
+    Capture *cp;
+    struct {
+      const char *s;
+      const char *e;
+    } s;
+  } u;
+} StrAux;
+
+#define MAXSTRCAPS	10
+
+static int getstrcaps (CapState *cs, StrAux *cps, int n) {
+  int k = n++;
+  cps[k].isstring = 1;
+  cps[k].u.s.s = cs->cap->s;
+  if (!isfullcap(cs->cap++)) {
+    while (!isclosecap(cs->cap)) {
+      if (n >= MAXSTRCAPS)  /* too many captures? */
+        cs->cap = nextcap(cs->cap);  /* skip it */
+      else if (captype(cs->cap) == Csimple)
+        n = getstrcaps(cs, cps, n);
+      else {
+        cps[n].isstring = 0;
+        cps[n].u.cp = cs->cap;
+        cs->cap = nextcap(cs->cap);
+        n++;
+      }
+    }
+    cs->cap++;  /* skip close */
+  }
+  cps[k].u.s.e = closeaddr(cs->cap - 1);
+  return n;
+}
+
+
+/*
+** add next capture (which should be a string) to buffer
+*/
+static int addonestring (luaL_Buffer *b, CapState *cs, const char *what);
+
+
+static void stringcap (luaL_Buffer *b, CapState *cs) {
+  StrAux cps[MAXSTRCAPS];
+  int n;
+  size_t len, i;
+  const char *c;
+  updatecache(cs, cs->cap->idx);
+  c = lua_tolstring(cs->L, subscache(cs), &len);
+  n = getstrcaps(cs, cps, 0) - 1;
+  for (i = 0; i < len; i++) {
+    if (c[i] != '%' || c[++i] < '0' || c[i] > '9')
+      luaL_addchar(b, c[i]);
+    else {
+      int l = c[i] - '0';
+      if (l > n)
+        luaL_error(cs->L, "invalid capture index (%d)", l);
+      else if (cps[l].isstring)
+        luaL_addlstring(b, cps[l].u.s.s, cps[l].u.s.e - cps[l].u.s.s);
+      else {
+        Capture *curr = cs->cap;
+        cs->cap = cps[l].u.cp;
+        if (addonestring(b, cs, "capture") == 0)
+          luaL_error(cs->L, "no values in capture index %d", l);
+        cs->cap = curr;
+      }
+    }
+  }
+}
+
+
+static void substcap (luaL_Buffer *b, CapState *cs) {
+  const char *curr = cs->cap->s;
+  if (isfullcap(cs->cap))  /* no nested captures? */
+    luaL_addlstring(b, curr, cs->cap->siz - 1);  /* keep original text */
+  else {
+    cs->cap++;
+    while (!isclosecap(cs->cap)) {
+      const char *next = cs->cap->s;
+      luaL_addlstring(b, curr, next - curr);  /* add text up to capture */
+      if (addonestring(b, cs, "replacement") == 0)  /* no capture value? */
+        curr = next;  /* keep original text in final result */
+      else
+        curr = closeaddr(cs->cap - 1);  /* continue after match */
+    }
+    luaL_addlstring(b, curr, cs->cap->s - curr);  /* add last piece of text */
+  }
+  cs->cap++;  /* go to next capture */
+}
+
+
+static int addonestring (luaL_Buffer *b, CapState *cs, const char *what) {
+  switch (captype(cs->cap)) {
+    case Cstring:
+      stringcap(b, cs);  /* add capture directly to buffer */
+      return 1;
+    case Csubst:
+      substcap(b, cs);  /* add capture directly to buffer */
+      return 1;
+    default: {
+      lua_State *L = cs->L;
+      int n = pushcapture(cs);
+      if (n > 0) {
+        if (n > 1) lua_pop(L, n - 1);  /* only one result */
+        if (!lua_isstring(L, -1))
+          luaL_error(L, "invalid %s value (a %s)", what, luaL_typename(L, -1));
+        luaL_addvalue(b);
+      }
+      return n;
+    }
+  }
+}
+
+
+static int pushcapture (CapState *cs) {
+  luaL_checkstack(cs->L, 4, "too many captures");
+  switch (captype(cs->cap)) {
+    case Cposition: {
+      lua_pushinteger(cs->L, cs->cap->s - cs->s + 1);
+      cs->cap++;
+      return 1;
+    }
+    case Cconst: {
+      pushluaval(cs);
+      cs->cap++;
+      return 1;
+    }
+    case Carg: {
+      int arg = (cs->cap++)->idx;
+      if (arg + FIXEDARGS > cs->ptop)
+        return luaL_error(cs->L, "reference to absent argument #%d", arg);
+      lua_pushvalue(cs->L, arg + FIXEDARGS);
+      return 1;
+    }
+    case Csimple: {
+      int k = pushallvalues(cs, 1);
+      if (k > 1)
+        lua_insert(cs->L, -k);  /* whole match is first result */
+      return k;
+    }
+    case Cruntime: {
+      int n = 0;
+      while (!isclosecap(cs->cap++)) {
+        luaL_checkstack(cs->L, 4, "too many captures");
+        lua_pushvalue(cs->L, (cs->cap - 1)->idx);
+        n++;
+      }
+      return n;
+    }
+    case Cstring: {
+      luaL_Buffer b;
+      luaL_buffinit(cs->L, &b);
+      stringcap(&b, cs);
+      luaL_pushresult(&b);
+      return 1;
+    }
+    case Csubst: {
+      luaL_Buffer b;
+      luaL_buffinit(cs->L, &b);
+      substcap(&b, cs);
+      luaL_pushresult(&b);
+      return 1;
+    }
+    case Cgroup: {
+      if (cs->cap->idx == 0)  /* anonymous group? */
+        return pushallvalues(cs, 0);  /* add all nested values */
+      else {  /* named group: add no values */
+        cs->cap = nextcap(cs->cap);  /* skip capture */
+        return 0;
+      }
+    }
+    case Cbackref: return backrefcap(cs);
+    case Ctable: return tablecap(cs);
+    case Cfunction: return functioncap(cs);
+    case Cquery: return querycap(cs);
+    case Cfold: return foldcap(cs);
+    default: assert(0); return 0;
+  }
+}
+
+
+static int getcaptures (lua_State *L, const char *s, const char *r, int ptop) {
+  Capture *capture = (Capture *)lua_touserdata(L, caplistidx(ptop));
+  int n = 0;
+  if (!isclosecap(capture)) {  /* is there any capture? */
+    CapState cs;
+    cs.ocap = cs.cap = capture; cs.L = L;
+    cs.s = s; cs.valuecached = 0; cs.ptop = ptop;
+    do {  /* collect their values */
+      n += pushcapture(&cs);
+    } while (!isclosecap(cs.cap));
+  }
+  if (n == 0) {  /* no capture values? */
+    lua_pushinteger(L, r - s + 1);  /* return only end position */
+    n = 1;
+  }
+  return n;
+}
+
+/* }====================================================== */
+
+
+static int version_l (lua_State *L) {
+  lua_pushstring(L, VERSION);
+  return 1;
+}
+
+
+static int type_l (lua_State *L) {
+  if (testpattern(L, 1))
+    lua_pushliteral(L, "pattern");
+  else
+    lua_pushnil(L);
+  return 1;
+}
+
+
+static void createcat (lua_State *L, const char *catname, int (catf) (int)) {
+  Instruction *p = newcharset(L);
+  int i;
+  for (i = 0; i < CHAR_MAX; i++)
+    if (catf(i)) setchar(p[1].buff, i);
+  lua_setfield(L, -2, catname);
+}
+
+
+static int locale_l (lua_State *L) {
+  if (lua_isnoneornil(L, 1)) {
+    lua_settop(L, 0);
+    lua_createtable(L, 0, 12);
+  }
+  else
+    luaL_checktype(L, 1, LUA_TTABLE);
+  createcat(L, "alnum", isalnum);
+  createcat(L, "alpha", isalpha);
+  createcat(L, "cntrl", iscntrl);
+  createcat(L, "digit", isdigit);
+  createcat(L, "graph", isgraph);
+  createcat(L, "lower", islower);
+  createcat(L, "print", isprint);
+  createcat(L, "punct", ispunct);
+  createcat(L, "space", isspace);
+  createcat(L, "upper", isupper);
+  createcat(L, "xdigit", isxdigit);
+  return 1;
+}
+
+
+static int printpat_l (lua_State *L) {
+  Instruction *p = getpatt(L, 1, NULL);
+  int n, i;
+  lua_getfenv(L, 1);
+  n = lua_objlen(L, -1);
+  printf("[");
+  for (i = 1; i <= n; i++) {
+    printf("%d = ", i);
+    lua_rawgeti(L, -1, i);
+    if (lua_isstring(L, -1))
+      printf("%s  ", lua_tostring(L, -1));
+    else
+      printf("%s  ", lua_typename(L, lua_type(L, -1)));
+    lua_pop(L, 1);
+  }
+  printf("]\n");
+  printpatt(p);
+  return 0;
+}
+
+
+static int matchl (lua_State *L) {
+  Capture capture[IMAXCAPTURES];
+  const char *r;
+  size_t l;
+  Instruction *p = getpatt(L, 1, NULL);
+  const char *s = luaL_checklstring(L, SUBJIDX, &l);
+  int ptop = lua_gettop(L);
+  lua_Integer ii = luaL_optinteger(L, 3, 1);
+  size_t i = (ii > 0) ?
+             (((size_t)ii <= l) ? (size_t)ii - 1 : l) :
+             (((size_t)-ii <= l) ? l - ((size_t)-ii) : 0);
+  lua_pushnil(L);  /* subscache */
+  lua_pushlightuserdata(L, capture);  /* caplistidx */
+  lua_getfenv(L, 1);  /* penvidx */
+  r = match(L, s, s + i, s + l, p, capture, ptop);
+  if (r == NULL) {
+    lua_pushnil(L);
+    return 1;
+  }
+  return getcaptures(L, s, r, ptop);
+}
+
+
+static struct luaL_reg pattreg[] = {
+  {"match", matchl},
+  {"print", printpat_l},
+  {"locale", locale_l},
+  {"C", capture_l},
+  {"Cf", fold_l},
+  {"Cc", capconst_l},
+  {"Cg", group_l},
+  {"Cp", position_l},
+  {"Cb", backref_l},
+  {"Carg", argcap_l},
+  {"Cmt", matchtime_l},
+  {"Cs", capsubst_l},
+  {"Ct", tcapture_l},
+  {"P", pattern_l},
+  {"R", range_l},
+  {"S", set_l},
+  {"V", nter_l},
+  {"span", span_l},
+  {"type", type_l},
+  {"version", version_l},
+  {NULL, NULL}
+};
+
+
+static struct luaL_reg metapattreg[] = {
+  {"__add", union_l},
+  {"__pow", star_l},
+  {"__sub", diff_l},
+  {"__mul", concat_l},
+  {"__div", rcapture_l},
+  {"__unm", unm_l},
+  {"__len", pattand_l},
+  {NULL, NULL}
+};
+
+
+int luaopen_lpeg (lua_State *L);
+int luaopen_lpeg (lua_State *L) {
+  lua_newtable(L);
+  lua_replace(L, LUA_ENVIRONINDEX);  /* empty env for new patterns */
+  luaL_newmetatable(L, PATTERN_T);
+  luaL_register(L, NULL, metapattreg);
+  luaL_register(L, "lpeg", pattreg);
+  lua_pushliteral(L, "__index");
+  lua_pushvalue(L, -2);
+  lua_settable(L, -4);
+  return 1;
+}
+
diff -r 77399602f8dc src/IFaceTable.cxx
--- scite/src/IFaceTable.cxx	Wed Jul 28 10:38:18 2010 +1000
+++ scite/src/IFaceTable.cxx	Tue Aug 17 00:13:24 2010 -0400
@@ -311,1308 +311,6 @@
 	{"SCEN_CHANGE",768},
 	{"SCEN_KILLFOCUS",256},
 	{"SCEN_SETFOCUS",512},
-	{"SCE_4GL_BLOCK",8},
-	{"SCE_4GL_BLOCK_",24},
-	{"SCE_4GL_CHARACTER",4},
-	{"SCE_4GL_CHARACTER_",20},
-	{"SCE_4GL_COMMENT1",10},
-	{"SCE_4GL_COMMENT1_",26},
-	{"SCE_4GL_COMMENT2",11},
-	{"SCE_4GL_COMMENT2_",27},
-	{"SCE_4GL_COMMENT3",12},
-	{"SCE_4GL_COMMENT3_",28},
-	{"SCE_4GL_COMMENT4",13},
-	{"SCE_4GL_COMMENT4_",29},
-	{"SCE_4GL_COMMENT5",14},
-	{"SCE_4GL_COMMENT5_",30},
-	{"SCE_4GL_COMMENT6",15},
-	{"SCE_4GL_COMMENT6_",31},
-	{"SCE_4GL_DEFAULT",0},
-	{"SCE_4GL_DEFAULT_",16},
-	{"SCE_4GL_END",9},
-	{"SCE_4GL_END_",25},
-	{"SCE_4GL_IDENTIFIER",7},
-	{"SCE_4GL_IDENTIFIER_",23},
-	{"SCE_4GL_NUMBER",1},
-	{"SCE_4GL_NUMBER_",17},
-	{"SCE_4GL_OPERATOR",6},
-	{"SCE_4GL_OPERATOR_",22},
-	{"SCE_4GL_PREPROCESSOR",5},
-	{"SCE_4GL_PREPROCESSOR_",21},
-	{"SCE_4GL_STRING",3},
-	{"SCE_4GL_STRING_",19},
-	{"SCE_4GL_WORD",2},
-	{"SCE_4GL_WORD_",18},
-	{"SCE_ABAQUS_ARGUMENT",11},
-	{"SCE_ABAQUS_COMMAND",8},
-	{"SCE_ABAQUS_COMMENT",1},
-	{"SCE_ABAQUS_COMMENTBLOCK",2},
-	{"SCE_ABAQUS_DEFAULT",0},
-	{"SCE_ABAQUS_FUNCTION",12},
-	{"SCE_ABAQUS_NUMBER",3},
-	{"SCE_ABAQUS_OPERATOR",5},
-	{"SCE_ABAQUS_PROCESSOR",7},
-	{"SCE_ABAQUS_SLASHCOMMAND",9},
-	{"SCE_ABAQUS_STARCOMMAND",10},
-	{"SCE_ABAQUS_STRING",4},
-	{"SCE_ABAQUS_WORD",6},
-	{"SCE_ADA_CHARACTER",5},
-	{"SCE_ADA_CHARACTEREOL",6},
-	{"SCE_ADA_COMMENTLINE",10},
-	{"SCE_ADA_DEFAULT",0},
-	{"SCE_ADA_DELIMITER",4},
-	{"SCE_ADA_IDENTIFIER",2},
-	{"SCE_ADA_ILLEGAL",11},
-	{"SCE_ADA_LABEL",9},
-	{"SCE_ADA_NUMBER",3},
-	{"SCE_ADA_STRING",7},
-	{"SCE_ADA_STRINGEOL",8},
-	{"SCE_ADA_WORD",1},
-	{"SCE_APDL_ARGUMENT",11},
-	{"SCE_APDL_COMMAND",8},
-	{"SCE_APDL_COMMENT",1},
-	{"SCE_APDL_COMMENTBLOCK",2},
-	{"SCE_APDL_DEFAULT",0},
-	{"SCE_APDL_FUNCTION",12},
-	{"SCE_APDL_NUMBER",3},
-	{"SCE_APDL_OPERATOR",5},
-	{"SCE_APDL_PROCESSOR",7},
-	{"SCE_APDL_SLASHCOMMAND",9},
-	{"SCE_APDL_STARCOMMAND",10},
-	{"SCE_APDL_STRING",4},
-	{"SCE_APDL_WORD",6},
-	{"SCE_ASM_CHARACTER",12},
-	{"SCE_ASM_COMMENT",1},
-	{"SCE_ASM_COMMENTBLOCK",11},
-	{"SCE_ASM_CPUINSTRUCTION",6},
-	{"SCE_ASM_DEFAULT",0},
-	{"SCE_ASM_DIRECTIVE",9},
-	{"SCE_ASM_DIRECTIVEOPERAND",10},
-	{"SCE_ASM_EXTINSTRUCTION",14},
-	{"SCE_ASM_IDENTIFIER",5},
-	{"SCE_ASM_MATHINSTRUCTION",7},
-	{"SCE_ASM_NUMBER",2},
-	{"SCE_ASM_OPERATOR",4},
-	{"SCE_ASM_REGISTER",8},
-	{"SCE_ASM_STRING",3},
-	{"SCE_ASM_STRINGEOL",13},
-	{"SCE_ASN1_ATTRIBUTE",7},
-	{"SCE_ASN1_COMMENT",1},
-	{"SCE_ASN1_DEFAULT",0},
-	{"SCE_ASN1_DESCRIPTOR",8},
-	{"SCE_ASN1_IDENTIFIER",2},
-	{"SCE_ASN1_KEYWORD",6},
-	{"SCE_ASN1_OID",4},
-	{"SCE_ASN1_OPERATOR",10},
-	{"SCE_ASN1_SCALAR",5},
-	{"SCE_ASN1_STRING",3},
-	{"SCE_ASN1_TYPE",9},
-	{"SCE_ASY_CHARACTER",6},
-	{"SCE_ASY_COMMENT",1},
-	{"SCE_ASY_COMMENTLINE",2},
-	{"SCE_ASY_COMMENTLINEDOC",10},
-	{"SCE_ASY_DEFAULT",0},
-	{"SCE_ASY_IDENTIFIER",8},
-	{"SCE_ASY_NUMBER",3},
-	{"SCE_ASY_OPERATOR",7},
-	{"SCE_ASY_STRING",5},
-	{"SCE_ASY_STRINGEOL",9},
-	{"SCE_ASY_WORD",4},
-	{"SCE_ASY_WORD2",11},
-	{"SCE_AU3_COMMENT",1},
-	{"SCE_AU3_COMMENTBLOCK",2},
-	{"SCE_AU3_COMOBJ",14},
-	{"SCE_AU3_DEFAULT",0},
-	{"SCE_AU3_EXPAND",13},
-	{"SCE_AU3_FUNCTION",4},
-	{"SCE_AU3_KEYWORD",5},
-	{"SCE_AU3_MACRO",6},
-	{"SCE_AU3_NUMBER",3},
-	{"SCE_AU3_OPERATOR",8},
-	{"SCE_AU3_PREPROCESSOR",11},
-	{"SCE_AU3_SENT",10},
-	{"SCE_AU3_SPECIAL",12},
-	{"SCE_AU3_STRING",7},
-	{"SCE_AU3_UDF",15},
-	{"SCE_AU3_VARIABLE",9},
-	{"SCE_AVE_COMMENT",1},
-	{"SCE_AVE_DEFAULT",0},
-	{"SCE_AVE_ENUM",7},
-	{"SCE_AVE_IDENTIFIER",9},
-	{"SCE_AVE_NUMBER",2},
-	{"SCE_AVE_OPERATOR",10},
-	{"SCE_AVE_STRING",6},
-	{"SCE_AVE_STRINGEOL",8},
-	{"SCE_AVE_WORD",3},
-	{"SCE_AVE_WORD1",11},
-	{"SCE_AVE_WORD2",12},
-	{"SCE_AVE_WORD3",13},
-	{"SCE_AVE_WORD4",14},
-	{"SCE_AVE_WORD5",15},
-	{"SCE_AVE_WORD6",16},
-	{"SCE_BAAN_COMMENT",1},
-	{"SCE_BAAN_COMMENTDOC",2},
-	{"SCE_BAAN_DEFAULT",0},
-	{"SCE_BAAN_IDENTIFIER",8},
-	{"SCE_BAAN_NUMBER",3},
-	{"SCE_BAAN_OPERATOR",7},
-	{"SCE_BAAN_PREPROCESSOR",6},
-	{"SCE_BAAN_STRING",5},
-	{"SCE_BAAN_STRINGEOL",9},
-	{"SCE_BAAN_WORD",4},
-	{"SCE_BAAN_WORD2",10},
-	{"SCE_BAT_COMMAND",5},
-	{"SCE_BAT_COMMENT",1},
-	{"SCE_BAT_DEFAULT",0},
-	{"SCE_BAT_HIDE",4},
-	{"SCE_BAT_IDENTIFIER",6},
-	{"SCE_BAT_LABEL",3},
-	{"SCE_BAT_OPERATOR",7},
-	{"SCE_BAT_WORD",2},
-	{"SCE_B_ASM",14},
-	{"SCE_B_BINNUMBER",18},
-	{"SCE_B_COMMENT",1},
-	{"SCE_B_CONSTANT",13},
-	{"SCE_B_DATE",8},
-	{"SCE_B_DEFAULT",0},
-	{"SCE_B_ERROR",16},
-	{"SCE_B_HEXNUMBER",17},
-	{"SCE_B_IDENTIFIER",7},
-	{"SCE_B_KEYWORD",3},
-	{"SCE_B_KEYWORD2",10},
-	{"SCE_B_KEYWORD3",11},
-	{"SCE_B_KEYWORD4",12},
-	{"SCE_B_LABEL",15},
-	{"SCE_B_NUMBER",2},
-	{"SCE_B_OPERATOR",6},
-	{"SCE_B_PREPROCESSOR",5},
-	{"SCE_B_STRING",4},
-	{"SCE_B_STRINGEOL",9},
-	{"SCE_CAML_CHAR",9},
-	{"SCE_CAML_COMMENT",12},
-	{"SCE_CAML_COMMENT1",13},
-	{"SCE_CAML_COMMENT2",14},
-	{"SCE_CAML_COMMENT3",15},
-	{"SCE_CAML_DEFAULT",0},
-	{"SCE_CAML_IDENTIFIER",1},
-	{"SCE_CAML_KEYWORD",3},
-	{"SCE_CAML_KEYWORD2",4},
-	{"SCE_CAML_KEYWORD3",5},
-	{"SCE_CAML_LINENUM",6},
-	{"SCE_CAML_NUMBER",8},
-	{"SCE_CAML_OPERATOR",7},
-	{"SCE_CAML_STRING",11},
-	{"SCE_CAML_TAGNAME",2},
-	{"SCE_CAML_WHITE",10},
-	{"SCE_CLW_ATTRIBUTE",13},
-	{"SCE_CLW_BUILTIN_PROCEDURES_FUNCTION",11},
-	{"SCE_CLW_COMMENT",2},
-	{"SCE_CLW_COMPILER_DIRECTIVE",9},
-	{"SCE_CLW_DEFAULT",0},
-	{"SCE_CLW_DEPRECATED",16},
-	{"SCE_CLW_ERROR",15},
-	{"SCE_CLW_INTEGER_CONSTANT",5},
-	{"SCE_CLW_KEYWORD",8},
-	{"SCE_CLW_LABEL",1},
-	{"SCE_CLW_PICTURE_STRING",7},
-	{"SCE_CLW_REAL_CONSTANT",6},
-	{"SCE_CLW_RUNTIME_EXPRESSIONS",10},
-	{"SCE_CLW_STANDARD_EQUATE",14},
-	{"SCE_CLW_STRING",3},
-	{"SCE_CLW_STRUCTURE_DATA_TYPE",12},
-	{"SCE_CLW_USER_IDENTIFIER",4},
-	{"SCE_CMAKE_COMMANDS",5},
-	{"SCE_CMAKE_COMMENT",1},
-	{"SCE_CMAKE_DEFAULT",0},
-	{"SCE_CMAKE_FOREACHDEF",10},
-	{"SCE_CMAKE_IFDEFINEDEF",11},
-	{"SCE_CMAKE_MACRODEF",12},
-	{"SCE_CMAKE_NUMBER",14},
-	{"SCE_CMAKE_PARAMETERS",6},
-	{"SCE_CMAKE_STRINGDQ",2},
-	{"SCE_CMAKE_STRINGLQ",3},
-	{"SCE_CMAKE_STRINGRQ",4},
-	{"SCE_CMAKE_STRINGVAR",13},
-	{"SCE_CMAKE_USERDEFINED",8},
-	{"SCE_CMAKE_VARIABLE",7},
-	{"SCE_CMAKE_WHILEDEF",9},
-	{"SCE_CONF_COMMENT",1},
-	{"SCE_CONF_DEFAULT",0},
-	{"SCE_CONF_DIRECTIVE",9},
-	{"SCE_CONF_EXTENSION",4},
-	{"SCE_CONF_IDENTIFIER",3},
-	{"SCE_CONF_IP",8},
-	{"SCE_CONF_NUMBER",2},
-	{"SCE_CONF_OPERATOR",7},
-	{"SCE_CONF_PARAMETER",5},
-	{"SCE_CONF_STRING",6},
-	{"SCE_CSOUND_ARATE_VAR",11},
-	{"SCE_CSOUND_COMMENT",1},
-	{"SCE_CSOUND_COMMENTBLOCK",9},
-	{"SCE_CSOUND_DEFAULT",0},
-	{"SCE_CSOUND_GLOBAL_VAR",14},
-	{"SCE_CSOUND_HEADERSTMT",7},
-	{"SCE_CSOUND_IDENTIFIER",5},
-	{"SCE_CSOUND_INSTR",4},
-	{"SCE_CSOUND_IRATE_VAR",13},
-	{"SCE_CSOUND_KRATE_VAR",12},
-	{"SCE_CSOUND_NUMBER",2},
-	{"SCE_CSOUND_OPCODE",6},
-	{"SCE_CSOUND_OPERATOR",3},
-	{"SCE_CSOUND_PARAM",10},
-	{"SCE_CSOUND_STRINGEOL",15},
-	{"SCE_CSOUND_USERKEYWORD",8},
-	{"SCE_CSS_ATTRIBUTE",16},
-	{"SCE_CSS_CLASS",2},
-	{"SCE_CSS_COMMENT",9},
-	{"SCE_CSS_DEFAULT",0},
-	{"SCE_CSS_DIRECTIVE",12},
-	{"SCE_CSS_DOUBLESTRING",13},
-	{"SCE_CSS_EXTENDED_IDENTIFIER",19},
-	{"SCE_CSS_EXTENDED_PSEUDOCLASS",20},
-	{"SCE_CSS_EXTENDED_PSEUDOELEMENT",21},
-	{"SCE_CSS_ID",10},
-	{"SCE_CSS_IDENTIFIER",6},
-	{"SCE_CSS_IDENTIFIER2",15},
-	{"SCE_CSS_IDENTIFIER3",17},
-	{"SCE_CSS_IMPORTANT",11},
-	{"SCE_CSS_MEDIA",22},
-	{"SCE_CSS_OPERATOR",5},
-	{"SCE_CSS_PSEUDOCLASS",3},
-	{"SCE_CSS_PSEUDOELEMENT",18},
-	{"SCE_CSS_SINGLESTRING",14},
-	{"SCE_CSS_TAG",1},
-	{"SCE_CSS_UNKNOWN_IDENTIFIER",7},
-	{"SCE_CSS_UNKNOWN_PSEUDOCLASS",4},
-	{"SCE_CSS_VALUE",8},
-	{"SCE_C_CHARACTER",7},
-	{"SCE_C_COMMENT",1},
-	{"SCE_C_COMMENTDOC",3},
-	{"SCE_C_COMMENTDOCKEYWORD",17},
-	{"SCE_C_COMMENTDOCKEYWORDERROR",18},
-	{"SCE_C_COMMENTLINE",2},
-	{"SCE_C_COMMENTLINEDOC",15},
-	{"SCE_C_DEFAULT",0},
-	{"SCE_C_GLOBALCLASS",19},
-	{"SCE_C_IDENTIFIER",11},
-	{"SCE_C_NUMBER",4},
-	{"SCE_C_OPERATOR",10},
-	{"SCE_C_PREPROCESSOR",9},
-	{"SCE_C_REGEX",14},
-	{"SCE_C_STRING",6},
-	{"SCE_C_STRINGEOL",12},
-	{"SCE_C_UUID",8},
-	{"SCE_C_VERBATIM",13},
-	{"SCE_C_WORD",5},
-	{"SCE_C_WORD2",16},
-	{"SCE_DIFF_ADDED",6},
-	{"SCE_DIFF_CHANGED",7},
-	{"SCE_DIFF_COMMAND",2},
-	{"SCE_DIFF_COMMENT",1},
-	{"SCE_DIFF_DEFAULT",0},
-	{"SCE_DIFF_DELETED",5},
-	{"SCE_DIFF_HEADER",3},
-	{"SCE_DIFF_POSITION",4},
-	{"SCE_D_CHARACTER",12},
-	{"SCE_D_COMMENT",1},
-	{"SCE_D_COMMENTDOC",3},
-	{"SCE_D_COMMENTDOCKEYWORD",16},
-	{"SCE_D_COMMENTDOCKEYWORDERROR",17},
-	{"SCE_D_COMMENTLINE",2},
-	{"SCE_D_COMMENTLINEDOC",15},
-	{"SCE_D_COMMENTNESTED",4},
-	{"SCE_D_DEFAULT",0},
-	{"SCE_D_IDENTIFIER",14},
-	{"SCE_D_NUMBER",5},
-	{"SCE_D_OPERATOR",13},
-	{"SCE_D_STRING",10},
-	{"SCE_D_STRINGB",18},
-	{"SCE_D_STRINGEOL",11},
-	{"SCE_D_STRINGR",19},
-	{"SCE_D_TYPEDEF",9},
-	{"SCE_D_WORD",6},
-	{"SCE_D_WORD2",7},
-	{"SCE_D_WORD3",8},
-	{"SCE_D_WORD5",20},
-	{"SCE_D_WORD6",21},
-	{"SCE_D_WORD7",22},
-	{"SCE_EIFFEL_CHARACTER",5},
-	{"SCE_EIFFEL_COMMENTLINE",1},
-	{"SCE_EIFFEL_DEFAULT",0},
-	{"SCE_EIFFEL_IDENTIFIER",7},
-	{"SCE_EIFFEL_NUMBER",2},
-	{"SCE_EIFFEL_OPERATOR",6},
-	{"SCE_EIFFEL_STRING",4},
-	{"SCE_EIFFEL_STRINGEOL",8},
-	{"SCE_EIFFEL_WORD",3},
-	{"SCE_ERLANG_ATOM",7},
-	{"SCE_ERLANG_ATOM_QUOTED",18},
-	{"SCE_ERLANG_BIFS",22},
-	{"SCE_ERLANG_CHARACTER",9},
-	{"SCE_ERLANG_COMMENT",1},
-	{"SCE_ERLANG_COMMENT_DOC",16},
-	{"SCE_ERLANG_COMMENT_DOC_MACRO",17},
-	{"SCE_ERLANG_COMMENT_FUNCTION",14},
-	{"SCE_ERLANG_COMMENT_MODULE",15},
-	{"SCE_ERLANG_DEFAULT",0},
-	{"SCE_ERLANG_FUNCTION_NAME",8},
-	{"SCE_ERLANG_KEYWORD",4},
-	{"SCE_ERLANG_MACRO",10},
-	{"SCE_ERLANG_MACRO_QUOTED",19},
-	{"SCE_ERLANG_MODULES",23},
-	{"SCE_ERLANG_MODULES_ATT",24},
-	{"SCE_ERLANG_NODE_NAME",13},
-	{"SCE_ERLANG_NODE_NAME_QUOTED",21},
-	{"SCE_ERLANG_NUMBER",3},
-	{"SCE_ERLANG_OPERATOR",6},
-	{"SCE_ERLANG_PREPROC",12},
-	{"SCE_ERLANG_RECORD",11},
-	{"SCE_ERLANG_RECORD_QUOTED",20},
-	{"SCE_ERLANG_STRING",5},
-	{"SCE_ERLANG_UNKNOWN",31},
-	{"SCE_ERLANG_VARIABLE",2},
-	{"SCE_ERR_ABSF",18},
-	{"SCE_ERR_BORLAND",5},
-	{"SCE_ERR_CMD",4},
-	{"SCE_ERR_CTAG",9},
-	{"SCE_ERR_DEFAULT",0},
-	{"SCE_ERR_DIFF_ADDITION",11},
-	{"SCE_ERR_DIFF_CHANGED",10},
-	{"SCE_ERR_DIFF_DELETION",12},
-	{"SCE_ERR_DIFF_MESSAGE",13},
-	{"SCE_ERR_ELF",15},
-	{"SCE_ERR_GCC",2},
-	{"SCE_ERR_IFC",16},
-	{"SCE_ERR_IFORT",17},
-	{"SCE_ERR_JAVA_STACK",20},
-	{"SCE_ERR_LUA",8},
-	{"SCE_ERR_MS",3},
-	{"SCE_ERR_NET",7},
-	{"SCE_ERR_PERL",6},
-	{"SCE_ERR_PHP",14},
-	{"SCE_ERR_PYTHON",1},
-	{"SCE_ERR_TIDY",19},
-	{"SCE_ERR_VALUE",21},
-	{"SCE_ESCRIPT_BRACE",9},
-	{"SCE_ESCRIPT_COMMENT",1},
-	{"SCE_ESCRIPT_COMMENTDOC",3},
-	{"SCE_ESCRIPT_COMMENTLINE",2},
-	{"SCE_ESCRIPT_DEFAULT",0},
-	{"SCE_ESCRIPT_IDENTIFIER",8},
-	{"SCE_ESCRIPT_NUMBER",4},
-	{"SCE_ESCRIPT_OPERATOR",7},
-	{"SCE_ESCRIPT_STRING",6},
-	{"SCE_ESCRIPT_WORD",5},
-	{"SCE_ESCRIPT_WORD2",10},
-	{"SCE_ESCRIPT_WORD3",11},
-	{"SCE_FORTH_COMMENT",1},
-	{"SCE_FORTH_COMMENT_ML",2},
-	{"SCE_FORTH_CONTROL",4},
-	{"SCE_FORTH_DEFAULT",0},
-	{"SCE_FORTH_DEFWORD",6},
-	{"SCE_FORTH_IDENTIFIER",3},
-	{"SCE_FORTH_KEYWORD",5},
-	{"SCE_FORTH_LOCALE",11},
-	{"SCE_FORTH_NUMBER",9},
-	{"SCE_FORTH_PREWORD1",7},
-	{"SCE_FORTH_PREWORD2",8},
-	{"SCE_FORTH_STRING",10},
-	{"SCE_FS_COMMENT",1},
-	{"SCE_FS_COMMENTDOC",3},
-	{"SCE_FS_COMMENTDOCKEYWORD",5},
-	{"SCE_FS_COMMENTDOCKEYWORDERROR",6},
-	{"SCE_FS_COMMENTDOC_C",22},
-	{"SCE_FS_COMMENTLINE",2},
-	{"SCE_FS_COMMENTLINEDOC",4},
-	{"SCE_FS_COMMENTLINEDOC_C",23},
-	{"SCE_FS_CONSTANT",18},
-	{"SCE_FS_DATE",16},
-	{"SCE_FS_DEFAULT",0},
-	{"SCE_FS_DEFAULT_C",21},
-	{"SCE_FS_DISABLEDCODE",20},
-	{"SCE_FS_IDENTIFIER",15},
-	{"SCE_FS_IDENTIFIER_C",30},
-	{"SCE_FS_KEYWORD",7},
-	{"SCE_FS_KEYWORD2",8},
-	{"SCE_FS_KEYWORD2_C",25},
-	{"SCE_FS_KEYWORD3",9},
-	{"SCE_FS_KEYWORD4",10},
-	{"SCE_FS_KEYWORD_C",24},
-	{"SCE_FS_NUMBER",11},
-	{"SCE_FS_NUMBER_C",26},
-	{"SCE_FS_OPERATOR",14},
-	{"SCE_FS_OPERATOR_C",29},
-	{"SCE_FS_PREPROCESSOR",13},
-	{"SCE_FS_PREPROCESSOR_C",28},
-	{"SCE_FS_STRING",12},
-	{"SCE_FS_STRINGEOL",17},
-	{"SCE_FS_STRINGEOL_C",31},
-	{"SCE_FS_STRING_C",27},
-	{"SCE_FS_WORDOPERATOR",19},
-	{"SCE_F_COMMENT",1},
-	{"SCE_F_CONTINUATION",14},
-	{"SCE_F_DEFAULT",0},
-	{"SCE_F_IDENTIFIER",7},
-	{"SCE_F_LABEL",13},
-	{"SCE_F_NUMBER",2},
-	{"SCE_F_OPERATOR",6},
-	{"SCE_F_OPERATOR2",12},
-	{"SCE_F_PREPROCESSOR",11},
-	{"SCE_F_STRING1",3},
-	{"SCE_F_STRING2",4},
-	{"SCE_F_STRINGEOL",5},
-	{"SCE_F_WORD",8},
-	{"SCE_F_WORD2",9},
-	{"SCE_F_WORD3",10},
-	{"SCE_GAP_CHAR",7},
-	{"SCE_GAP_COMMENT",9},
-	{"SCE_GAP_DEFAULT",0},
-	{"SCE_GAP_IDENTIFIER",1},
-	{"SCE_GAP_KEYWORD",2},
-	{"SCE_GAP_KEYWORD2",3},
-	{"SCE_GAP_KEYWORD3",4},
-	{"SCE_GAP_KEYWORD4",5},
-	{"SCE_GAP_NUMBER",10},
-	{"SCE_GAP_OPERATOR",8},
-	{"SCE_GAP_STRING",6},
-	{"SCE_GAP_STRINGEOL",11},
-	{"SCE_GC_ATTRIBUTE",5},
-	{"SCE_GC_COMMAND",7},
-	{"SCE_GC_COMMENTBLOCK",2},
-	{"SCE_GC_COMMENTLINE",1},
-	{"SCE_GC_CONTROL",6},
-	{"SCE_GC_DEFAULT",0},
-	{"SCE_GC_EVENT",4},
-	{"SCE_GC_GLOBAL",3},
-	{"SCE_GC_OPERATOR",9},
-	{"SCE_GC_STRING",8},
-	{"SCE_HA_CAPITAL",8},
-	{"SCE_HA_CHARACTER",5},
-	{"SCE_HA_CLASS",6},
-	{"SCE_HA_COMMENTBLOCK",14},
-	{"SCE_HA_COMMENTBLOCK2",15},
-	{"SCE_HA_COMMENTBLOCK3",16},
-	{"SCE_HA_COMMENTLINE",13},
-	{"SCE_HA_DATA",9},
-	{"SCE_HA_DEFAULT",0},
-	{"SCE_HA_IDENTIFIER",1},
-	{"SCE_HA_IMPORT",10},
-	{"SCE_HA_INSTANCE",12},
-	{"SCE_HA_KEYWORD",2},
-	{"SCE_HA_MODULE",7},
-	{"SCE_HA_NUMBER",3},
-	{"SCE_HA_OPERATOR",11},
-	{"SCE_HA_STRING",4},
-	{"SCE_HBA_COMMENTLINE",82},
-	{"SCE_HBA_DEFAULT",81},
-	{"SCE_HBA_IDENTIFIER",86},
-	{"SCE_HBA_NUMBER",83},
-	{"SCE_HBA_START",80},
-	{"SCE_HBA_STRING",85},
-	{"SCE_HBA_STRINGEOL",87},
-	{"SCE_HBA_WORD",84},
-	{"SCE_HB_COMMENTLINE",72},
-	{"SCE_HB_DEFAULT",71},
-	{"SCE_HB_IDENTIFIER",76},
-	{"SCE_HB_NUMBER",73},
-	{"SCE_HB_START",70},
-	{"SCE_HB_STRING",75},
-	{"SCE_HB_STRINGEOL",77},
-	{"SCE_HB_WORD",74},
-	{"SCE_HJA_COMMENT",57},
-	{"SCE_HJA_COMMENTDOC",59},
-	{"SCE_HJA_COMMENTLINE",58},
-	{"SCE_HJA_DEFAULT",56},
-	{"SCE_HJA_DOUBLESTRING",63},
-	{"SCE_HJA_KEYWORD",62},
-	{"SCE_HJA_NUMBER",60},
-	{"SCE_HJA_REGEX",67},
-	{"SCE_HJA_SINGLESTRING",64},
-	{"SCE_HJA_START",55},
-	{"SCE_HJA_STRINGEOL",66},
-	{"SCE_HJA_SYMBOLS",65},
-	{"SCE_HJA_WORD",61},
-	{"SCE_HJ_COMMENT",42},
-	{"SCE_HJ_COMMENTDOC",44},
-	{"SCE_HJ_COMMENTLINE",43},
-	{"SCE_HJ_DEFAULT",41},
-	{"SCE_HJ_DOUBLESTRING",48},
-	{"SCE_HJ_KEYWORD",47},
-	{"SCE_HJ_NUMBER",45},
-	{"SCE_HJ_REGEX",52},
-	{"SCE_HJ_SINGLESTRING",49},
-	{"SCE_HJ_START",40},
-	{"SCE_HJ_STRINGEOL",51},
-	{"SCE_HJ_SYMBOLS",50},
-	{"SCE_HJ_WORD",46},
-	{"SCE_HPA_CHARACTER",110},
-	{"SCE_HPA_CLASSNAME",114},
-	{"SCE_HPA_COMMENTLINE",107},
-	{"SCE_HPA_DEFAULT",106},
-	{"SCE_HPA_DEFNAME",115},
-	{"SCE_HPA_IDENTIFIER",117},
-	{"SCE_HPA_NUMBER",108},
-	{"SCE_HPA_OPERATOR",116},
-	{"SCE_HPA_START",105},
-	{"SCE_HPA_STRING",109},
-	{"SCE_HPA_TRIPLE",112},
-	{"SCE_HPA_TRIPLEDOUBLE",113},
-	{"SCE_HPA_WORD",111},
-	{"SCE_HPHP_COMMENT",124},
-	{"SCE_HPHP_COMMENTLINE",125},
-	{"SCE_HPHP_COMPLEX_VARIABLE",104},
-	{"SCE_HPHP_DEFAULT",118},
-	{"SCE_HPHP_HSTRING",119},
-	{"SCE_HPHP_HSTRING_VARIABLE",126},
-	{"SCE_HPHP_NUMBER",122},
-	{"SCE_HPHP_OPERATOR",127},
-	{"SCE_HPHP_SIMPLESTRING",120},
-	{"SCE_HPHP_VARIABLE",123},
-	{"SCE_HPHP_WORD",121},
-	{"SCE_HP_CHARACTER",95},
-	{"SCE_HP_CLASSNAME",99},
-	{"SCE_HP_COMMENTLINE",92},
-	{"SCE_HP_DEFAULT",91},
-	{"SCE_HP_DEFNAME",100},
-	{"SCE_HP_IDENTIFIER",102},
-	{"SCE_HP_NUMBER",93},
-	{"SCE_HP_OPERATOR",101},
-	{"SCE_HP_START",90},
-	{"SCE_HP_STRING",94},
-	{"SCE_HP_TRIPLE",97},
-	{"SCE_HP_TRIPLEDOUBLE",98},
-	{"SCE_HP_WORD",96},
-	{"SCE_H_ASP",15},
-	{"SCE_H_ASPAT",16},
-	{"SCE_H_ATTRIBUTE",3},
-	{"SCE_H_ATTRIBUTEUNKNOWN",4},
-	{"SCE_H_CDATA",17},
-	{"SCE_H_COMMENT",9},
-	{"SCE_H_DEFAULT",0},
-	{"SCE_H_DOUBLESTRING",6},
-	{"SCE_H_ENTITY",10},
-	{"SCE_H_NUMBER",5},
-	{"SCE_H_OTHER",8},
-	{"SCE_H_QUESTION",18},
-	{"SCE_H_SCRIPT",14},
-	{"SCE_H_SGML_1ST_PARAM",23},
-	{"SCE_H_SGML_1ST_PARAM_COMMENT",30},
-	{"SCE_H_SGML_BLOCK_DEFAULT",31},
-	{"SCE_H_SGML_COMMAND",22},
-	{"SCE_H_SGML_COMMENT",29},
-	{"SCE_H_SGML_DEFAULT",21},
-	{"SCE_H_SGML_DOUBLESTRING",24},
-	{"SCE_H_SGML_ENTITY",28},
-	{"SCE_H_SGML_ERROR",26},
-	{"SCE_H_SGML_SIMPLESTRING",25},
-	{"SCE_H_SGML_SPECIAL",27},
-	{"SCE_H_SINGLESTRING",7},
-	{"SCE_H_TAG",1},
-	{"SCE_H_TAGEND",11},
-	{"SCE_H_TAGUNKNOWN",2},
-	{"SCE_H_VALUE",19},
-	{"SCE_H_XCCOMMENT",20},
-	{"SCE_H_XMLEND",13},
-	{"SCE_H_XMLSTART",12},
-	{"SCE_INNO_COMMENT",1},
-	{"SCE_INNO_COMMENT_PASCAL",7},
-	{"SCE_INNO_DEFAULT",0},
-	{"SCE_INNO_IDENTIFIER",12},
-	{"SCE_INNO_INLINE_EXPANSION",6},
-	{"SCE_INNO_KEYWORD",2},
-	{"SCE_INNO_KEYWORD_PASCAL",8},
-	{"SCE_INNO_KEYWORD_USER",9},
-	{"SCE_INNO_PARAMETER",3},
-	{"SCE_INNO_PREPROC",5},
-	{"SCE_INNO_SECTION",4},
-	{"SCE_INNO_STRING_DOUBLE",10},
-	{"SCE_INNO_STRING_SINGLE",11},
-	{"SCE_KIX_COMMENT",1},
-	{"SCE_KIX_DEFAULT",0},
-	{"SCE_KIX_FUNCTIONS",8},
-	{"SCE_KIX_IDENTIFIER",31},
-	{"SCE_KIX_KEYWORD",7},
-	{"SCE_KIX_MACRO",6},
-	{"SCE_KIX_NUMBER",4},
-	{"SCE_KIX_OPERATOR",9},
-	{"SCE_KIX_STRING1",2},
-	{"SCE_KIX_STRING2",3},
-	{"SCE_KIX_VAR",5},
-	{"SCE_LISP_COMMENT",1},
-	{"SCE_LISP_DEFAULT",0},
-	{"SCE_LISP_IDENTIFIER",9},
-	{"SCE_LISP_KEYWORD",3},
-	{"SCE_LISP_KEYWORD_KW",4},
-	{"SCE_LISP_MULTI_COMMENT",12},
-	{"SCE_LISP_NUMBER",2},
-	{"SCE_LISP_OPERATOR",10},
-	{"SCE_LISP_SPECIAL",11},
-	{"SCE_LISP_STRING",6},
-	{"SCE_LISP_STRINGEOL",8},
-	{"SCE_LISP_SYMBOL",5},
-	{"SCE_LOT_ABORT",6},
-	{"SCE_LOT_BREAK",2},
-	{"SCE_LOT_DEFAULT",0},
-	{"SCE_LOT_FAIL",5},
-	{"SCE_LOT_HEADER",1},
-	{"SCE_LOT_PASS",4},
-	{"SCE_LOT_SET",3},
-	{"SCE_LOUT_COMMENT",1},
-	{"SCE_LOUT_DEFAULT",0},
-	{"SCE_LOUT_IDENTIFIER",9},
-	{"SCE_LOUT_NUMBER",2},
-	{"SCE_LOUT_OPERATOR",8},
-	{"SCE_LOUT_STRING",7},
-	{"SCE_LOUT_STRINGEOL",10},
-	{"SCE_LOUT_WORD",3},
-	{"SCE_LOUT_WORD2",4},
-	{"SCE_LOUT_WORD3",5},
-	{"SCE_LOUT_WORD4",6},
-	{"SCE_LUA_CHARACTER",7},
-	{"SCE_LUA_COMMENT",1},
-	{"SCE_LUA_COMMENTDOC",3},
-	{"SCE_LUA_COMMENTLINE",2},
-	{"SCE_LUA_DEFAULT",0},
-	{"SCE_LUA_IDENTIFIER",11},
-	{"SCE_LUA_LITERALSTRING",8},
-	{"SCE_LUA_NUMBER",4},
-	{"SCE_LUA_OPERATOR",10},
-	{"SCE_LUA_PREPROCESSOR",9},
-	{"SCE_LUA_STRING",6},
-	{"SCE_LUA_STRINGEOL",12},
-	{"SCE_LUA_WORD",5},
-	{"SCE_LUA_WORD2",13},
-	{"SCE_LUA_WORD3",14},
-	{"SCE_LUA_WORD4",15},
-	{"SCE_LUA_WORD5",16},
-	{"SCE_LUA_WORD6",17},
-	{"SCE_LUA_WORD7",18},
-	{"SCE_LUA_WORD8",19},
-	{"SCE_L_COMMAND",1},
-	{"SCE_L_COMMENT",4},
-	{"SCE_L_DEFAULT",0},
-	{"SCE_L_MATH",3},
-	{"SCE_L_TAG",2},
-	{"SCE_MAGIK_BRACE_BLOCK",10},
-	{"SCE_MAGIK_BRACKET_BLOCK",9},
-	{"SCE_MAGIK_CHARACTER",3},
-	{"SCE_MAGIK_COMMENT",1},
-	{"SCE_MAGIK_CONTAINER",8},
-	{"SCE_MAGIK_DEFAULT",0},
-	{"SCE_MAGIK_FLOW",7},
-	{"SCE_MAGIK_HYPER_COMMENT",16},
-	{"SCE_MAGIK_IDENTIFIER",5},
-	{"SCE_MAGIK_KEYWORD",13},
-	{"SCE_MAGIK_NUMBER",4},
-	{"SCE_MAGIK_OPERATOR",6},
-	{"SCE_MAGIK_PRAGMA",14},
-	{"SCE_MAGIK_SQBRACKET_BLOCK",11},
-	{"SCE_MAGIK_STRING",2},
-	{"SCE_MAGIK_SYMBOL",15},
-	{"SCE_MAGIK_UNKNOWN_KEYWORD",12},
-	{"SCE_MAKE_COMMENT",1},
-	{"SCE_MAKE_DEFAULT",0},
-	{"SCE_MAKE_IDENTIFIER",3},
-	{"SCE_MAKE_IDEOL",9},
-	{"SCE_MAKE_OPERATOR",4},
-	{"SCE_MAKE_PREPROCESSOR",2},
-	{"SCE_MAKE_TARGET",5},
-	{"SCE_MARKDOWN_BLOCKQUOTE",15},
-	{"SCE_MARKDOWN_CODE",19},
-	{"SCE_MARKDOWN_CODE2",20},
-	{"SCE_MARKDOWN_CODEBK",21},
-	{"SCE_MARKDOWN_DEFAULT",0},
-	{"SCE_MARKDOWN_EM1",4},
-	{"SCE_MARKDOWN_EM2",5},
-	{"SCE_MARKDOWN_HEADER1",6},
-	{"SCE_MARKDOWN_HEADER2",7},
-	{"SCE_MARKDOWN_HEADER3",8},
-	{"SCE_MARKDOWN_HEADER4",9},
-	{"SCE_MARKDOWN_HEADER5",10},
-	{"SCE_MARKDOWN_HEADER6",11},
-	{"SCE_MARKDOWN_HRULE",17},
-	{"SCE_MARKDOWN_LINE_BEGIN",1},
-	{"SCE_MARKDOWN_LINK",18},
-	{"SCE_MARKDOWN_OLIST_ITEM",14},
-	{"SCE_MARKDOWN_PRECHAR",12},
-	{"SCE_MARKDOWN_STRIKEOUT",16},
-	{"SCE_MARKDOWN_STRONG1",2},
-	{"SCE_MARKDOWN_STRONG2",3},
-	{"SCE_MARKDOWN_ULIST_ITEM",13},
-	{"SCE_MATLAB_COMMAND",2},
-	{"SCE_MATLAB_COMMENT",1},
-	{"SCE_MATLAB_DEFAULT",0},
-	{"SCE_MATLAB_DOUBLEQUOTESTRING",8},
-	{"SCE_MATLAB_IDENTIFIER",7},
-	{"SCE_MATLAB_KEYWORD",4},
-	{"SCE_MATLAB_NUMBER",3},
-	{"SCE_MATLAB_OPERATOR",6},
-	{"SCE_MATLAB_STRING",5},
-	{"SCE_METAPOST_COMMAND",4},
-	{"SCE_METAPOST_DEFAULT",0},
-	{"SCE_METAPOST_EXTRA",6},
-	{"SCE_METAPOST_GROUP",2},
-	{"SCE_METAPOST_SPECIAL",1},
-	{"SCE_METAPOST_SYMBOL",3},
-	{"SCE_METAPOST_TEXT",5},
-	{"SCE_MMIXAL_CHAR",11},
-	{"SCE_MMIXAL_COMMENT",1},
-	{"SCE_MMIXAL_HEX",14},
-	{"SCE_MMIXAL_INCLUDE",17},
-	{"SCE_MMIXAL_LABEL",2},
-	{"SCE_MMIXAL_LEADWS",0},
-	{"SCE_MMIXAL_NUMBER",9},
-	{"SCE_MMIXAL_OPCODE",3},
-	{"SCE_MMIXAL_OPCODE_POST",7},
-	{"SCE_MMIXAL_OPCODE_PRE",4},
-	{"SCE_MMIXAL_OPCODE_UNKNOWN",6},
-	{"SCE_MMIXAL_OPCODE_VALID",5},
-	{"SCE_MMIXAL_OPERANDS",8},
-	{"SCE_MMIXAL_OPERATOR",15},
-	{"SCE_MMIXAL_REF",10},
-	{"SCE_MMIXAL_REGISTER",13},
-	{"SCE_MMIXAL_STRING",12},
-	{"SCE_MMIXAL_SYMBOL",16},
-	{"SCE_MSSQL_COLUMN_NAME",8},
-	{"SCE_MSSQL_COLUMN_NAME_2",16},
-	{"SCE_MSSQL_COMMENT",1},
-	{"SCE_MSSQL_DATATYPE",10},
-	{"SCE_MSSQL_DEFAULT",0},
-	{"SCE_MSSQL_DEFAULT_PREF_DATATYPE",15},
-	{"SCE_MSSQL_FUNCTION",13},
-	{"SCE_MSSQL_GLOBAL_VARIABLE",12},
-	{"SCE_MSSQL_IDENTIFIER",6},
-	{"SCE_MSSQL_LINE_COMMENT",2},
-	{"SCE_MSSQL_NUMBER",3},
-	{"SCE_MSSQL_OPERATOR",5},
-	{"SCE_MSSQL_STATEMENT",9},
-	{"SCE_MSSQL_STORED_PROCEDURE",14},
-	{"SCE_MSSQL_STRING",4},
-	{"SCE_MSSQL_SYSTABLE",11},
-	{"SCE_MSSQL_VARIABLE",7},
-	{"SCE_MYSQL_COMMENT",1},
-	{"SCE_MYSQL_COMMENTLINE",2},
-	{"SCE_MYSQL_DATABASEOBJECT",9},
-	{"SCE_MYSQL_DEFAULT",0},
-	{"SCE_MYSQL_DQSTRING",13},
-	{"SCE_MYSQL_FUNCTION",15},
-	{"SCE_MYSQL_HIDDENCOMMAND",21},
-	{"SCE_MYSQL_IDENTIFIER",16},
-	{"SCE_MYSQL_KEYWORD",8},
-	{"SCE_MYSQL_KNOWNSYSTEMVARIABLE",5},
-	{"SCE_MYSQL_MAJORKEYWORD",7},
-	{"SCE_MYSQL_NUMBER",6},
-	{"SCE_MYSQL_OPERATOR",14},
-	{"SCE_MYSQL_PROCEDUREKEYWORD",10},
-	{"SCE_MYSQL_QUOTEDIDENTIFIER",17},
-	{"SCE_MYSQL_SQSTRING",12},
-	{"SCE_MYSQL_STRING",11},
-	{"SCE_MYSQL_SYSTEMVARIABLE",4},
-	{"SCE_MYSQL_USER1",18},
-	{"SCE_MYSQL_USER2",19},
-	{"SCE_MYSQL_USER3",20},
-	{"SCE_MYSQL_VARIABLE",3},
-	{"SCE_NNCRONTAB_ASTERISK",6},
-	{"SCE_NNCRONTAB_COMMENT",1},
-	{"SCE_NNCRONTAB_DEFAULT",0},
-	{"SCE_NNCRONTAB_ENVIRONMENT",9},
-	{"SCE_NNCRONTAB_IDENTIFIER",10},
-	{"SCE_NNCRONTAB_KEYWORD",4},
-	{"SCE_NNCRONTAB_MODIFIER",5},
-	{"SCE_NNCRONTAB_NUMBER",7},
-	{"SCE_NNCRONTAB_SECTION",3},
-	{"SCE_NNCRONTAB_STRING",8},
-	{"SCE_NNCRONTAB_TASK",2},
-	{"SCE_NSIS_COMMENT",1},
-	{"SCE_NSIS_COMMENTBOX",18},
-	{"SCE_NSIS_DEFAULT",0},
-	{"SCE_NSIS_FUNCTION",5},
-	{"SCE_NSIS_FUNCTIONDEF",17},
-	{"SCE_NSIS_IFDEFINEDEF",11},
-	{"SCE_NSIS_LABEL",7},
-	{"SCE_NSIS_MACRODEF",12},
-	{"SCE_NSIS_NUMBER",14},
-	{"SCE_NSIS_PAGEEX",16},
-	{"SCE_NSIS_SECTIONDEF",9},
-	{"SCE_NSIS_SECTIONGROUP",15},
-	{"SCE_NSIS_STRINGDQ",2},
-	{"SCE_NSIS_STRINGLQ",3},
-	{"SCE_NSIS_STRINGRQ",4},
-	{"SCE_NSIS_STRINGVAR",13},
-	{"SCE_NSIS_SUBSECTIONDEF",10},
-	{"SCE_NSIS_USERDEFINED",8},
-	{"SCE_NSIS_VARIABLE",6},
-	{"SCE_OPAL_BOOL_CONST",8},
-	{"SCE_OPAL_COMMENT_BLOCK",1},
-	{"SCE_OPAL_COMMENT_LINE",2},
-	{"SCE_OPAL_DEFAULT",32},
-	{"SCE_OPAL_INTEGER",3},
-	{"SCE_OPAL_KEYWORD",4},
-	{"SCE_OPAL_PAR",7},
-	{"SCE_OPAL_SORT",5},
-	{"SCE_OPAL_SPACE",0},
-	{"SCE_OPAL_STRING",6},
-	{"SCE_PAS_ASM",14},
-	{"SCE_PAS_CHARACTER",12},
-	{"SCE_PAS_COMMENT",2},
-	{"SCE_PAS_COMMENT2",3},
-	{"SCE_PAS_COMMENTLINE",4},
-	{"SCE_PAS_DEFAULT",0},
-	{"SCE_PAS_HEXNUMBER",8},
-	{"SCE_PAS_IDENTIFIER",1},
-	{"SCE_PAS_NUMBER",7},
-	{"SCE_PAS_OPERATOR",13},
-	{"SCE_PAS_PREPROCESSOR",5},
-	{"SCE_PAS_PREPROCESSOR2",6},
-	{"SCE_PAS_STRING",10},
-	{"SCE_PAS_STRINGEOL",11},
-	{"SCE_PAS_WORD",9},
-	{"SCE_PLM_COMMENT",1},
-	{"SCE_PLM_CONTROL",6},
-	{"SCE_PLM_DEFAULT",0},
-	{"SCE_PLM_IDENTIFIER",4},
-	{"SCE_PLM_KEYWORD",7},
-	{"SCE_PLM_NUMBER",3},
-	{"SCE_PLM_OPERATOR",5},
-	{"SCE_PLM_STRING",2},
-	{"SCE_PL_ARRAY",13},
-	{"SCE_PL_BACKTICKS",20},
-	{"SCE_PL_CHARACTER",7},
-	{"SCE_PL_COMMENTLINE",2},
-	{"SCE_PL_DATASECTION",21},
-	{"SCE_PL_DEFAULT",0},
-	{"SCE_PL_ERROR",1},
-	{"SCE_PL_FORMAT",42},
-	{"SCE_PL_FORMAT_IDENT",41},
-	{"SCE_PL_HASH",14},
-	{"SCE_PL_HERE_DELIM",22},
-	{"SCE_PL_HERE_Q",23},
-	{"SCE_PL_HERE_QQ",24},
-	{"SCE_PL_HERE_QX",25},
-	{"SCE_PL_IDENTIFIER",11},
-	{"SCE_PL_LONGQUOTE",19},
-	{"SCE_PL_NUMBER",4},
-	{"SCE_PL_OPERATOR",10},
-	{"SCE_PL_POD",3},
-	{"SCE_PL_POD_VERB",31},
-	{"SCE_PL_PREPROCESSOR",9},
-	{"SCE_PL_PUNCTUATION",8},
-	{"SCE_PL_REGEX",17},
-	{"SCE_PL_REGSUBST",18},
-	{"SCE_PL_SCALAR",12},
-	{"SCE_PL_STRING",6},
-	{"SCE_PL_STRING_Q",26},
-	{"SCE_PL_STRING_QQ",27},
-	{"SCE_PL_STRING_QR",29},
-	{"SCE_PL_STRING_QW",30},
-	{"SCE_PL_STRING_QX",28},
-	{"SCE_PL_SUB_PROTOTYPE",40},
-	{"SCE_PL_SYMBOLTABLE",15},
-	{"SCE_PL_VARIABLE_INDEXER",16},
-	{"SCE_PL_WORD",5},
-	{"SCE_POV_BADDIRECTIVE",9},
-	{"SCE_POV_COMMENT",1},
-	{"SCE_POV_COMMENTLINE",2},
-	{"SCE_POV_DEFAULT",0},
-	{"SCE_POV_DIRECTIVE",8},
-	{"SCE_POV_IDENTIFIER",5},
-	{"SCE_POV_NUMBER",3},
-	{"SCE_POV_OPERATOR",4},
-	{"SCE_POV_STRING",6},
-	{"SCE_POV_STRINGEOL",7},
-	{"SCE_POV_WORD2",10},
-	{"SCE_POV_WORD3",11},
-	{"SCE_POV_WORD4",12},
-	{"SCE_POV_WORD5",13},
-	{"SCE_POV_WORD6",14},
-	{"SCE_POV_WORD7",15},
-	{"SCE_POV_WORD8",16},
-	{"SCE_POWERPRO_ALTQUOTE",15},
-	{"SCE_POWERPRO_COMMENTBLOCK",1},
-	{"SCE_POWERPRO_COMMENTLINE",2},
-	{"SCE_POWERPRO_DEFAULT",0},
-	{"SCE_POWERPRO_DOUBLEQUOTEDSTRING",8},
-	{"SCE_POWERPRO_FUNCTION",16},
-	{"SCE_POWERPRO_IDENTIFIER",12},
-	{"SCE_POWERPRO_LINECONTINUE",10},
-	{"SCE_POWERPRO_NUMBER",3},
-	{"SCE_POWERPRO_OPERATOR",11},
-	{"SCE_POWERPRO_SINGLEQUOTEDSTRING",9},
-	{"SCE_POWERPRO_STRINGEOL",13},
-	{"SCE_POWERPRO_VERBATIM",14},
-	{"SCE_POWERPRO_WORD",4},
-	{"SCE_POWERPRO_WORD2",5},
-	{"SCE_POWERPRO_WORD3",6},
-	{"SCE_POWERPRO_WORD4",7},
-	{"SCE_POWERSHELL_ALIAS",10},
-	{"SCE_POWERSHELL_CHARACTER",3},
-	{"SCE_POWERSHELL_CMDLET",9},
-	{"SCE_POWERSHELL_COMMENT",1},
-	{"SCE_POWERSHELL_COMMENTSTREAM",13},
-	{"SCE_POWERSHELL_DEFAULT",0},
-	{"SCE_POWERSHELL_FUNCTION",11},
-	{"SCE_POWERSHELL_IDENTIFIER",7},
-	{"SCE_POWERSHELL_KEYWORD",8},
-	{"SCE_POWERSHELL_NUMBER",4},
-	{"SCE_POWERSHELL_OPERATOR",6},
-	{"SCE_POWERSHELL_STRING",2},
-	{"SCE_POWERSHELL_USER1",12},
-	{"SCE_POWERSHELL_VARIABLE",5},
-	{"SCE_PO_COMMENT",1},
-	{"SCE_PO_DEFAULT",0},
-	{"SCE_PO_FUZZY",8},
-	{"SCE_PO_MSGCTXT",6},
-	{"SCE_PO_MSGCTXT_TEXT",7},
-	{"SCE_PO_MSGID",2},
-	{"SCE_PO_MSGID_TEXT",3},
-	{"SCE_PO_MSGSTR",4},
-	{"SCE_PO_MSGSTR_TEXT",5},
-	{"SCE_PROPS_ASSIGNMENT",3},
-	{"SCE_PROPS_COMMENT",1},
-	{"SCE_PROPS_DEFAULT",0},
-	{"SCE_PROPS_DEFVAL",4},
-	{"SCE_PROPS_KEY",5},
-	{"SCE_PROPS_SECTION",2},
-	{"SCE_PS_BADSTRINGCHAR",15},
-	{"SCE_PS_BASE85STRING",14},
-	{"SCE_PS_COMMENT",1},
-	{"SCE_PS_DEFAULT",0},
-	{"SCE_PS_DSC_COMMENT",2},
-	{"SCE_PS_DSC_VALUE",3},
-	{"SCE_PS_HEXSTRING",13},
-	{"SCE_PS_IMMEVAL",8},
-	{"SCE_PS_KEYWORD",6},
-	{"SCE_PS_LITERAL",7},
-	{"SCE_PS_NAME",5},
-	{"SCE_PS_NUMBER",4},
-	{"SCE_PS_PAREN_ARRAY",9},
-	{"SCE_PS_PAREN_DICT",10},
-	{"SCE_PS_PAREN_PROC",11},
-	{"SCE_PS_TEXT",12},
-	{"SCE_P_CHARACTER",4},
-	{"SCE_P_CLASSNAME",8},
-	{"SCE_P_COMMENTBLOCK",12},
-	{"SCE_P_COMMENTLINE",1},
-	{"SCE_P_DECORATOR",15},
-	{"SCE_P_DEFAULT",0},
-	{"SCE_P_DEFNAME",9},
-	{"SCE_P_IDENTIFIER",11},
-	{"SCE_P_NUMBER",2},
-	{"SCE_P_OPERATOR",10},
-	{"SCE_P_STRING",3},
-	{"SCE_P_STRINGEOL",13},
-	{"SCE_P_TRIPLE",6},
-	{"SCE_P_TRIPLEDOUBLE",7},
-	{"SCE_P_WORD",5},
-	{"SCE_P_WORD2",14},
-	{"SCE_RB_BACKTICKS",18},
-	{"SCE_RB_CHARACTER",7},
-	{"SCE_RB_CLASSNAME",8},
-	{"SCE_RB_CLASS_VAR",17},
-	{"SCE_RB_COMMENTLINE",2},
-	{"SCE_RB_DATASECTION",19},
-	{"SCE_RB_DEFAULT",0},
-	{"SCE_RB_DEFNAME",9},
-	{"SCE_RB_ERROR",1},
-	{"SCE_RB_GLOBAL",13},
-	{"SCE_RB_HERE_DELIM",20},
-	{"SCE_RB_HERE_Q",21},
-	{"SCE_RB_HERE_QQ",22},
-	{"SCE_RB_HERE_QX",23},
-	{"SCE_RB_IDENTIFIER",11},
-	{"SCE_RB_INSTANCE_VAR",16},
-	{"SCE_RB_MODULE_NAME",15},
-	{"SCE_RB_NUMBER",4},
-	{"SCE_RB_OPERATOR",10},
-	{"SCE_RB_POD",3},
-	{"SCE_RB_REGEX",12},
-	{"SCE_RB_STDERR",40},
-	{"SCE_RB_STDIN",30},
-	{"SCE_RB_STDOUT",31},
-	{"SCE_RB_STRING",6},
-	{"SCE_RB_STRING_Q",24},
-	{"SCE_RB_STRING_QQ",25},
-	{"SCE_RB_STRING_QR",27},
-	{"SCE_RB_STRING_QW",28},
-	{"SCE_RB_STRING_QX",26},
-	{"SCE_RB_SYMBOL",14},
-	{"SCE_RB_UPPER_BOUND",41},
-	{"SCE_RB_WORD",5},
-	{"SCE_RB_WORD_DEMOTED",29},
-	{"SCE_REBOL_BINARY",11},
-	{"SCE_REBOL_BRACEDSTRING",7},
-	{"SCE_REBOL_CHARACTER",5},
-	{"SCE_REBOL_COMMENTBLOCK",2},
-	{"SCE_REBOL_COMMENTLINE",1},
-	{"SCE_REBOL_DATE",18},
-	{"SCE_REBOL_DEFAULT",0},
-	{"SCE_REBOL_EMAIL",16},
-	{"SCE_REBOL_FILE",15},
-	{"SCE_REBOL_IDENTIFIER",20},
-	{"SCE_REBOL_ISSUE",13},
-	{"SCE_REBOL_MONEY",12},
-	{"SCE_REBOL_NUMBER",8},
-	{"SCE_REBOL_OPERATOR",4},
-	{"SCE_REBOL_PAIR",9},
-	{"SCE_REBOL_PREFACE",3},
-	{"SCE_REBOL_QUOTEDSTRING",6},
-	{"SCE_REBOL_TAG",14},
-	{"SCE_REBOL_TIME",19},
-	{"SCE_REBOL_TUPLE",10},
-	{"SCE_REBOL_URL",17},
-	{"SCE_REBOL_WORD",21},
-	{"SCE_REBOL_WORD2",22},
-	{"SCE_REBOL_WORD3",23},
-	{"SCE_REBOL_WORD4",24},
-	{"SCE_REBOL_WORD5",25},
-	{"SCE_REBOL_WORD6",26},
-	{"SCE_REBOL_WORD7",27},
-	{"SCE_REBOL_WORD8",28},
-	{"SCE_R_BASEKWORD",3},
-	{"SCE_R_COMMENT",1},
-	{"SCE_R_DEFAULT",0},
-	{"SCE_R_IDENTIFIER",9},
-	{"SCE_R_INFIX",10},
-	{"SCE_R_INFIXEOL",11},
-	{"SCE_R_KWORD",2},
-	{"SCE_R_NUMBER",5},
-	{"SCE_R_OPERATOR",8},
-	{"SCE_R_OTHERKWORD",4},
-	{"SCE_R_STRING",6},
-	{"SCE_R_STRING2",7},
-	{"SCE_SCRIPTOL_CHARACTER",8},
-	{"SCE_SCRIPTOL_CLASSNAME",14},
-	{"SCE_SCRIPTOL_COMMENTBLOCK",5},
-	{"SCE_SCRIPTOL_COMMENTLINE",2},
-	{"SCE_SCRIPTOL_CSTYLE",4},
-	{"SCE_SCRIPTOL_DEFAULT",0},
-	{"SCE_SCRIPTOL_IDENTIFIER",12},
-	{"SCE_SCRIPTOL_KEYWORD",10},
-	{"SCE_SCRIPTOL_NUMBER",6},
-	{"SCE_SCRIPTOL_OPERATOR",11},
-	{"SCE_SCRIPTOL_PERSISTENT",3},
-	{"SCE_SCRIPTOL_PREPROCESSOR",15},
-	{"SCE_SCRIPTOL_STRING",7},
-	{"SCE_SCRIPTOL_STRINGEOL",9},
-	{"SCE_SCRIPTOL_TRIPLE",13},
-	{"SCE_SCRIPTOL_WHITE",1},
-	{"SCE_SH_BACKTICKS",11},
-	{"SCE_SH_CHARACTER",6},
-	{"SCE_SH_COMMENTLINE",2},
-	{"SCE_SH_DEFAULT",0},
-	{"SCE_SH_ERROR",1},
-	{"SCE_SH_HERE_DELIM",12},
-	{"SCE_SH_HERE_Q",13},
-	{"SCE_SH_IDENTIFIER",8},
-	{"SCE_SH_NUMBER",3},
-	{"SCE_SH_OPERATOR",7},
-	{"SCE_SH_PARAM",10},
-	{"SCE_SH_SCALAR",9},
-	{"SCE_SH_STRING",5},
-	{"SCE_SH_WORD",4},
-	{"SCE_SML_CHAR",9},
-	{"SCE_SML_COMMENT",12},
-	{"SCE_SML_COMMENT1",13},
-	{"SCE_SML_COMMENT2",14},
-	{"SCE_SML_COMMENT3",15},
-	{"SCE_SML_DEFAULT",0},
-	{"SCE_SML_IDENTIFIER",1},
-	{"SCE_SML_KEYWORD",3},
-	{"SCE_SML_KEYWORD2",4},
-	{"SCE_SML_KEYWORD3",5},
-	{"SCE_SML_LINENUM",6},
-	{"SCE_SML_NUMBER",8},
-	{"SCE_SML_OPERATOR",7},
-	{"SCE_SML_STRING",11},
-	{"SCE_SML_TAGNAME",2},
-	{"SCE_SN_CODE",1},
-	{"SCE_SN_COMMENTLINE",2},
-	{"SCE_SN_COMMENTLINEBANG",3},
-	{"SCE_SN_DEFAULT",0},
-	{"SCE_SN_IDENTIFIER",11},
-	{"SCE_SN_NUMBER",4},
-	{"SCE_SN_OPERATOR",10},
-	{"SCE_SN_PREPROCESSOR",9},
-	{"SCE_SN_REGEXTAG",13},
-	{"SCE_SN_SIGNAL",14},
-	{"SCE_SN_STRING",6},
-	{"SCE_SN_STRINGEOL",12},
-	{"SCE_SN_USER",19},
-	{"SCE_SN_WORD",5},
-	{"SCE_SN_WORD2",7},
-	{"SCE_SN_WORD3",8},
-	{"SCE_SORCUS_COMMAND",1},
-	{"SCE_SORCUS_COMMENTLINE",3},
-	{"SCE_SORCUS_CONSTANT",9},
-	{"SCE_SORCUS_DEFAULT",0},
-	{"SCE_SORCUS_IDENTIFIER",6},
-	{"SCE_SORCUS_NUMBER",8},
-	{"SCE_SORCUS_OPERATOR",7},
-	{"SCE_SORCUS_PARAMETER",2},
-	{"SCE_SORCUS_STRING",4},
-	{"SCE_SORCUS_STRINGEOL",5},
-	{"SCE_SPICE_COMMENTLINE",8},
-	{"SCE_SPICE_DEFAULT",0},
-	{"SCE_SPICE_DELIMITER",6},
-	{"SCE_SPICE_IDENTIFIER",1},
-	{"SCE_SPICE_KEYWORD",2},
-	{"SCE_SPICE_KEYWORD2",3},
-	{"SCE_SPICE_KEYWORD3",4},
-	{"SCE_SPICE_NUMBER",5},
-	{"SCE_SPICE_VALUE",7},
-	{"SCE_SQL_CHARACTER",7},
-	{"SCE_SQL_COMMENT",1},
-	{"SCE_SQL_COMMENTDOC",3},
-	{"SCE_SQL_COMMENTDOCKEYWORD",17},
-	{"SCE_SQL_COMMENTDOCKEYWORDERROR",18},
-	{"SCE_SQL_COMMENTLINE",2},
-	{"SCE_SQL_COMMENTLINEDOC",15},
-	{"SCE_SQL_DEFAULT",0},
-	{"SCE_SQL_IDENTIFIER",11},
-	{"SCE_SQL_NUMBER",4},
-	{"SCE_SQL_OPERATOR",10},
-	{"SCE_SQL_QUOTEDIDENTIFIER",23},
-	{"SCE_SQL_SQLPLUS",8},
-	{"SCE_SQL_SQLPLUS_COMMENT",13},
-	{"SCE_SQL_SQLPLUS_PROMPT",9},
-	{"SCE_SQL_STRING",6},
-	{"SCE_SQL_USER1",19},
-	{"SCE_SQL_USER2",20},
-	{"SCE_SQL_USER3",21},
-	{"SCE_SQL_USER4",22},
-	{"SCE_SQL_WORD",5},
-	{"SCE_SQL_WORD2",16},
-	{"SCE_ST_ASSIGN",14},
-	{"SCE_ST_BINARY",5},
-	{"SCE_ST_BOOL",6},
-	{"SCE_ST_CHARACTER",15},
-	{"SCE_ST_COMMENT",3},
-	{"SCE_ST_DEFAULT",0},
-	{"SCE_ST_GLOBAL",10},
-	{"SCE_ST_KWSEND",13},
-	{"SCE_ST_NIL",9},
-	{"SCE_ST_NUMBER",2},
-	{"SCE_ST_RETURN",11},
-	{"SCE_ST_SELF",7},
-	{"SCE_ST_SPECIAL",12},
-	{"SCE_ST_SPEC_SEL",16},
-	{"SCE_ST_STRING",1},
-	{"SCE_ST_SUPER",8},
-	{"SCE_ST_SYMBOL",4},
-	{"SCE_T3_BLOCK_COMMENT",3},
-	{"SCE_T3_BRACE",20},
-	{"SCE_T3_DEFAULT",0},
-	{"SCE_T3_D_STRING",10},
-	{"SCE_T3_HTML_DEFAULT",15},
-	{"SCE_T3_HTML_STRING",16},
-	{"SCE_T3_HTML_TAG",14},
-	{"SCE_T3_IDENTIFIER",8},
-	{"SCE_T3_KEYWORD",6},
-	{"SCE_T3_LIB_DIRECTIVE",12},
-	{"SCE_T3_LINE_COMMENT",4},
-	{"SCE_T3_MSG_PARAM",13},
-	{"SCE_T3_NUMBER",7},
-	{"SCE_T3_OPERATOR",5},
-	{"SCE_T3_PREPROCESSOR",2},
-	{"SCE_T3_S_STRING",9},
-	{"SCE_T3_USER1",17},
-	{"SCE_T3_USER2",18},
-	{"SCE_T3_USER3",19},
-	{"SCE_T3_X_DEFAULT",1},
-	{"SCE_T3_X_STRING",11},
-	{"SCE_TCL_BLOCK_COMMENT",21},
-	{"SCE_TCL_COMMENT",1},
-	{"SCE_TCL_COMMENTLINE",2},
-	{"SCE_TCL_COMMENT_BOX",20},
-	{"SCE_TCL_DEFAULT",0},
-	{"SCE_TCL_EXPAND",11},
-	{"SCE_TCL_IDENTIFIER",7},
-	{"SCE_TCL_IN_QUOTE",5},
-	{"SCE_TCL_MODIFIER",10},
-	{"SCE_TCL_NUMBER",3},
-	{"SCE_TCL_OPERATOR",6},
-	{"SCE_TCL_SUBSTITUTION",8},
-	{"SCE_TCL_SUB_BRACE",9},
-	{"SCE_TCL_WORD",12},
-	{"SCE_TCL_WORD2",13},
-	{"SCE_TCL_WORD3",14},
-	{"SCE_TCL_WORD4",15},
-	{"SCE_TCL_WORD5",16},
-	{"SCE_TCL_WORD6",17},
-	{"SCE_TCL_WORD7",18},
-	{"SCE_TCL_WORD8",19},
-	{"SCE_TCL_WORD_IN_QUOTE",4},
-	{"SCE_TEX_COMMAND",4},
-	{"SCE_TEX_DEFAULT",0},
-	{"SCE_TEX_GROUP",2},
-	{"SCE_TEX_SPECIAL",1},
-	{"SCE_TEX_SYMBOL",3},
-	{"SCE_TEX_TEXT",5},
-	{"SCE_TXT2TAGS_BLOCKQUOTE",15},
-	{"SCE_TXT2TAGS_CODE",19},
-	{"SCE_TXT2TAGS_CODE2",20},
-	{"SCE_TXT2TAGS_CODEBK",21},
-	{"SCE_TXT2TAGS_COMMENT",22},
-	{"SCE_TXT2TAGS_DEFAULT",0},
-	{"SCE_TXT2TAGS_EM1",4},
-	{"SCE_TXT2TAGS_EM2",5},
-	{"SCE_TXT2TAGS_HEADER1",6},
-	{"SCE_TXT2TAGS_HEADER2",7},
-	{"SCE_TXT2TAGS_HEADER3",8},
-	{"SCE_TXT2TAGS_HEADER4",9},
-	{"SCE_TXT2TAGS_HEADER5",10},
-	{"SCE_TXT2TAGS_HEADER6",11},
-	{"SCE_TXT2TAGS_HRULE",17},
-	{"SCE_TXT2TAGS_LINE_BEGIN",1},
-	{"SCE_TXT2TAGS_LINK",18},
-	{"SCE_TXT2TAGS_OLIST_ITEM",14},
-	{"SCE_TXT2TAGS_OPTION",23},
-	{"SCE_TXT2TAGS_POSTPROC",25},
-	{"SCE_TXT2TAGS_PRECHAR",12},
-	{"SCE_TXT2TAGS_PREPROC",24},
-	{"SCE_TXT2TAGS_STRIKEOUT",16},
-	{"SCE_TXT2TAGS_STRONG1",2},
-	{"SCE_TXT2TAGS_STRONG2",3},
-	{"SCE_TXT2TAGS_ULIST_ITEM",13},
-	{"SCE_VHDL_ATTRIBUTE",10},
-	{"SCE_VHDL_COMMENT",1},
-	{"SCE_VHDL_COMMENTLINEBANG",2},
-	{"SCE_VHDL_DEFAULT",0},
-	{"SCE_VHDL_IDENTIFIER",6},
-	{"SCE_VHDL_KEYWORD",8},
-	{"SCE_VHDL_NUMBER",3},
-	{"SCE_VHDL_OPERATOR",5},
-	{"SCE_VHDL_STDFUNCTION",11},
-	{"SCE_VHDL_STDOPERATOR",9},
-	{"SCE_VHDL_STDPACKAGE",12},
-	{"SCE_VHDL_STDTYPE",13},
-	{"SCE_VHDL_STRING",4},
-	{"SCE_VHDL_STRINGEOL",7},
-	{"SCE_VHDL_USERWORD",14},
-	{"SCE_V_COMMENT",1},
-	{"SCE_V_COMMENTLINE",2},
-	{"SCE_V_COMMENTLINEBANG",3},
-	{"SCE_V_DEFAULT",0},
-	{"SCE_V_IDENTIFIER",11},
-	{"SCE_V_NUMBER",4},
-	{"SCE_V_OPERATOR",10},
-	{"SCE_V_PREPROCESSOR",9},
-	{"SCE_V_STRING",6},
-	{"SCE_V_STRINGEOL",12},
-	{"SCE_V_USER",19},
-	{"SCE_V_WORD",5},
-	{"SCE_V_WORD2",7},
-	{"SCE_V_WORD3",8},
-	{"SCE_YAML_COMMENT",1},
-	{"SCE_YAML_DEFAULT",0},
-	{"SCE_YAML_DOCUMENT",6},
-	{"SCE_YAML_ERROR",8},
-	{"SCE_YAML_IDENTIFIER",2},
-	{"SCE_YAML_KEYWORD",3},
-	{"SCE_YAML_NUMBER",4},
-	{"SCE_YAML_OPERATOR",9},
-	{"SCE_YAML_REFERENCE",5},
-	{"SCE_YAML_TEXT",7},
 	{"SCFIND_MATCHCASE",4},
 	{"SCFIND_POSIX",0x00400000},
 	{"SCFIND_REGEXP",0x00200000},
@@ -1947,105 +645,10 @@
 	{"SCK_TAB",9},
 	{"SCK_UP",301},
 	{"SCK_WIN",313},
-	{"SCLEX_ABAQUS",84},
-	{"SCLEX_ADA",20},
-	{"SCLEX_APDL",61},
-	{"SCLEX_ASM",34},
-	{"SCLEX_ASN1",63},
-	{"SCLEX_ASYMPTOTE",85},
-	{"SCLEX_AU3",60},
 	{"SCLEX_AUTOMATIC",1000},
-	{"SCLEX_AVE",19},
-	{"SCLEX_BAAN",31},
-	{"SCLEX_BASH",62},
-	{"SCLEX_BATCH",12},
-	{"SCLEX_BLITZBASIC",66},
-	{"SCLEX_BULLANT",27},
-	{"SCLEX_CAML",65},
-	{"SCLEX_CLW",45},
-	{"SCLEX_CLWNOCASE",46},
-	{"SCLEX_CMAKE",80},
-	{"SCLEX_COBOL",92},
-	{"SCLEX_CONF",17},
 	{"SCLEX_CONTAINER",0},
-	{"SCLEX_CPP",3},
-	{"SCLEX_CPPNOCASE",35},
-	{"SCLEX_CSOUND",74},
-	{"SCLEX_CSS",38},
-	{"SCLEX_D",79},
-	{"SCLEX_DIFF",16},
-	{"SCLEX_EIFFEL",23},
-	{"SCLEX_EIFFELKW",24},
-	{"SCLEX_ERLANG",53},
-	{"SCLEX_ERRORLIST",10},
-	{"SCLEX_ESCRIPT",41},
-	{"SCLEX_F77",37},
-	{"SCLEX_FLAGSHIP",73},
-	{"SCLEX_FORTH",52},
-	{"SCLEX_FORTRAN",36},
-	{"SCLEX_FREEBASIC",75},
-	{"SCLEX_GAP",81},
-	{"SCLEX_GUI4CLI",58},
-	{"SCLEX_HASKELL",68},
-	{"SCLEX_HTML",4},
-	{"SCLEX_INNOSETUP",76},
-	{"SCLEX_KIX",57},
-	{"SCLEX_LATEX",14},
-	{"SCLEX_LISP",21},
-	{"SCLEX_LOT",47},
-	{"SCLEX_LOUT",40},
-	{"SCLEX_LUA",15},
-	{"SCLEX_MAGIK",87},
-	{"SCLEX_MAKEFILE",11},
-	{"SCLEX_MARKDOWN",98},
-	{"SCLEX_MATLAB",32},
-	{"SCLEX_METAPOST",50},
-	{"SCLEX_MMIXAL",44},
-	{"SCLEX_MSSQL",55},
-	{"SCLEX_MYSQL",89},
-	{"SCLEX_NIMROD",96},
-	{"SCLEX_NNCRONTAB",26},
-	{"SCLEX_NSIS",43},
+	{"SCLEX_LPEG",2},
 	{"SCLEX_NULL",1},
-	{"SCLEX_OCTAVE",54},
-	{"SCLEX_OPAL",77},
-	{"SCLEX_PASCAL",18},
-	{"SCLEX_PERL",6},
-	{"SCLEX_PHPSCRIPT",69},
-	{"SCLEX_PLM",82},
-	{"SCLEX_PO",90},
-	{"SCLEX_POV",39},
-	{"SCLEX_POWERBASIC",51},
-	{"SCLEX_POWERPRO",95},
-	{"SCLEX_POWERSHELL",88},
-	{"SCLEX_PROGRESS",83},
-	{"SCLEX_PROPERTIES",9},
-	{"SCLEX_PS",42},
-	{"SCLEX_PUREBASIC",67},
-	{"SCLEX_PYTHON",2},
-	{"SCLEX_R",86},
-	{"SCLEX_REBOL",71},
-	{"SCLEX_RUBY",22},
-	{"SCLEX_SCRIPTOL",33},
-	{"SCLEX_SMALLTALK",72},
-	{"SCLEX_SML",97},
-	{"SCLEX_SORCUS",94},
-	{"SCLEX_SPECMAN",59},
-	{"SCLEX_SPICE",78},
-	{"SCLEX_SQL",7},
-	{"SCLEX_TACL",93},
-	{"SCLEX_TADS3",70},
-	{"SCLEX_TAL",91},
-	{"SCLEX_TCL",25},
-	{"SCLEX_TEX",49},
-	{"SCLEX_TXT2TAGS",99},
-	{"SCLEX_VB",8},
-	{"SCLEX_VBSCRIPT",28},
-	{"SCLEX_VERILOG",56},
-	{"SCLEX_VHDL",64},
-	{"SCLEX_XCODE",13},
-	{"SCLEX_XML",5},
-	{"SCLEX_YAML",48},
 	{"SCMOD_ALT",4},
 	{"SCMOD_CTRL",2},
 	{"SCMOD_NORM",0},
@@ -2414,7 +1017,7 @@
 	{"PositionFromLine", 2167, iface_position, {iface_int, iface_void}},
 	{"PositionFromPoint", 2022, iface_position, {iface_int, iface_int}},
 	{"PositionFromPointClose", 2023, iface_position, {iface_int, iface_int}},
-	{"PrivateLexerCall", 4013, iface_int, {iface_int, iface_int}},
+	{"PrivateLexerCall", 4013, iface_int, {iface_int, iface_stringresult}},
 	{"PropertyNames", 4014, iface_int, {iface_void, iface_stringresult}},
 	{"PropertyType", 4015, iface_int, {iface_string, iface_void}},
 	{"Redo", 2011, iface_void, {iface_void, iface_void}},
@@ -2675,7 +1278,7 @@
 
 enum {
 	ifaceFunctionCount = 271,
-	ifaceConstantCount = 2094,
+	ifaceConstantCount = 697,
 	ifacePropertyCount = 170
 };
 
diff -r 77399602f8dc src/SciTEBase.cxx
--- scite/src/SciTEBase.cxx	Wed Jul 28 10:38:18 2010 +1000
+++ scite/src/SciTEBase.cxx	Tue Aug 17 00:13:24 2010 -0400
@@ -350,8 +350,8 @@
 SciTEBase::SciTEBase(Extension *ext) : apis(true), extender(ext) {
 	codePage = 0;
 	characterSet = 0;
-	language = "java";
-	lexLanguage = SCLEX_CPP;
+	language = "container"; // modified by Mitchell
+	lexLanguage = SCLEX_LPEG; // modified by Mitchell
 	functionDefinition = 0;
 	indentOpening = true;
 	indentClosing = true;
@@ -840,11 +840,13 @@
 		braceAtCaret = caretPos - 1;
 	}
 	bool colonMode = false;
+#if 0 // added by Mitchell
 	if ((lexLanguage == SCLEX_PYTHON) &&
 	        (':' == charBefore) && (SCE_P_OPERATOR == styleBefore)) {
 		braceAtCaret = caretPos - 1;
 		colonMode = true;
 	}
+#endif // added by Mitchell
 	bool isAfter = true;
 	if (lengthDoc > 0 && sloppy && (braceAtCaret < 0) && (caretPos < lengthDoc)) {
 		// No brace found so check other side
@@ -856,11 +858,13 @@
 				braceAtCaret = caretPos;
 				isAfter = false;
 			}
+#if 0 // added by Mitchell
 			if ((lexLanguage == SCLEX_PYTHON) &&
 			        (':' == charAfter) && (SCE_P_OPERATOR == styleAfter)) {
 				braceAtCaret = caretPos;
 				colonMode = true;
 			}
+#endif // added by Mitchell
 		}
 	}
 	if (braceAtCaret >= 0) {
@@ -3115,10 +3119,16 @@
 		return false;
 	}
 
+#if 0 // added by Mitchell
 	// This may make sense only in certain languages
 	if (lexLanguage != SCLEX_HTML && lexLanguage != SCLEX_XML) {
 		return false;
 	}
+// added by Mitchell
+#else
+	return false; // don't bother with completion
+#endif
+// end added by Mitchell
 
 	// If the user has turned us off, quit now.
 	// Default is off
diff -r 77399602f8dc src/SciTEBuffers.cxx
--- scite/src/SciTEBuffers.cxx	Wed Jul 28 10:38:18 2010 +1000
+++ scite/src/SciTEBuffers.cxx	Tue Aug 17 00:13:24 2010 -0400
@@ -67,6 +67,14 @@
 #include "JobQueue.h"
 #include "SciTEBase.h"
 
+// added by Mitchell
+extern "C" {
+#include <lua.h>
+#include <lualib.h>
+#include <lauxlib.h>
+}
+// end added by Mitchell
+
 const GUI::gui_char defaultSessionFileName[] = GUI_TEXT("SciTE.session");
 
 BufferList::BufferList() : current(0), stackcurrent(0), stack(0), buffers(0), size(0), length(0), initialised(false) {}
@@ -1350,9 +1358,54 @@
 	return (ch >= '0') && (ch <= '9');
 }
 
-int DecodeMessage(const char *cdoc, char *sourcePath, int format, int &column) {
+int DecodeMessage(const char *cdoc, char *sourcePath, int format, int &column, PropSetFile &props) { // modified by Mitchell
 	sourcePath[0] = '\0';
+	int sourceNumber = -1; // added by Mitchell
 	column = -1; // default to not detected
+
+	// added by Mitchell
+	SString decoderScript = props.GetExpanded("decoder.lua.script");
+	lua_State *luaState = lua_open();
+	if (!luaState) {
+		return sourceNumber;
+	}
+
+	// load base and string libraries
+	lua_pushcfunction(luaState, luaopen_base);
+	lua_pushstring(luaState, "");
+	lua_call(luaState, 1, 0);
+	lua_pushcfunction(luaState, luaopen_string);
+	lua_pushstring(luaState, LUA_STRLIBNAME);
+	lua_call(luaState, 1, 0);
+
+	// read script and call DecodeMessage
+	if (luaL_loadfile(luaState, decoderScript.c_str()) == 0) {
+		if (lua_pcall(luaState, 0, 0, 0) == 0) {
+			lua_getglobal(luaState, "DecodeMessage");
+			if (lua_isfunction(luaState, -1)) {
+				lua_pushstring(luaState, cdoc);
+				lua_pushinteger(luaState, format);
+				if (lua_pcall(luaState, 2, LUA_MULTRET, 0) == 0) { // returns sourcePath, linenum, and column
+					if (lua_gettop(luaState) == 3) {
+						const char *returnedPath = lua_tostring(luaState, -3);
+						int length = strlen(returnedPath);
+						if (length > 0) {
+							strncpy(sourcePath, returnedPath, length);
+							sourcePath[length] = 0;
+						}
+						sourceNumber = (int) lua_tointeger(luaState, -2);
+						column = (int) lua_tointeger(luaState, -1);
+					}
+				}
+			}
+		}
+	}
+
+	lua_close(luaState);
+	return sourceNumber;
+	// end added by Mitchell
+
+#if 0 // added by Mitchell
 	switch (format) {
 	case SCE_ERR_PYTHON: {
 			// Python
@@ -1685,6 +1738,7 @@
 			break;
 		}
 	}	// switch
+#endif // added by Mitchell
 	return -1;
 }
 
@@ -1705,11 +1759,7 @@
 		int startPosLine = wOutput.Call(SCI_POSITIONFROMLINE, lookLine, 0);
 		int lineLength = wOutput.Call(SCI_LINELENGTH, lookLine, 0);
 		char style = acc.StyleAt(startPosLine);
-		if (style != SCE_ERR_DEFAULT &&
-		        style != SCE_ERR_CMD &&
-		        style != SCE_ERR_DIFF_ADDITION &&
-		        style != SCE_ERR_DIFF_CHANGED &&
-		        style != SCE_ERR_DIFF_DELETION) {
+		if (style > 10) { // modified by Mitchell (error styles start at 11 via errorlist.lua)
 			wOutput.Call(SCI_MARKERDELETEALL, static_cast<uptr_t>(-1));
 			wOutput.Call(SCI_MARKERDEFINE, 0, SC_MARK_SMALLRECT);
 			wOutput.Call(SCI_MARKERSETFORE, 0, ColourOfProperty(props,
@@ -1721,7 +1771,7 @@
 			SString message = GetRange(wOutput, startPosLine, startPosLine + lineLength);
 			char source[MAX_PATH];
 			int column;
-			int sourceLine = DecodeMessage(message.c_str(), source, style, column);
+			int sourceLine = DecodeMessage(message.c_str(), source, style, column, props); // modified by Mitchell
 			if (sourceLine >= 0) {
 				GUI::gui_string sourceString = GUI::StringFromUTF8(source);
 				FilePath sourcePath(sourceString);
@@ -1753,6 +1803,7 @@
 					}
 				}
 
+#if 0 // added by Mitchell
 				// If ctag then get line number after search tag or use ctag line number
 				if (style == SCE_ERR_CTAG) {
 					char cTag[200];
@@ -1771,6 +1822,7 @@
 						}
 					}
 				}
+#endif // added by Mitchell
 
 				wEditor.Call(SCI_MARKERDELETEALL, 0);
 				wEditor.Call(SCI_MARKERDEFINE, 0, SC_MARK_CIRCLE);
diff -r 77399602f8dc src/SciTEGlobal.properties
--- scite/src/SciTEGlobal.properties	Wed Jul 28 10:38:18 2010 +1000
+++ scite/src/SciTEGlobal.properties	Tue Aug 17 00:13:24 2010 -0400
@@ -5,6 +5,13 @@
 
 # Globals
 
+# scintillua properties by Mitchell
+lexer.lua.home=$(SciteDefaultHome)/lexers
+lexer.lua.script=$(SciteDefaultHome)/lexers/lexer.lua
+lexer.lua.color.theme=scite
+fold.by.indentation=0
+#decoder.lua.script=
+
 # Window sizes and visibility
 if PLAT_WIN
 	position.left=0
diff -r 77399602f8dc src/SciTEProps.cxx
--- scite/src/SciTEProps.cxx	Wed Jul 28 10:38:18 2010 +1000
+++ scite/src/SciTEProps.cxx	Tue Aug 17 00:13:24 2010 -0400
@@ -528,58 +528,12 @@
 static const char *propertiesToForward[] = {
 //++Autogenerated -- run src/LexGen.py to regenerate
 //**\(\t"\*",\n\)
-	"asp.default.language",
 	"fold",
-	"fold.at.else",
-	"fold.comment",
-	"fold.comment.nimrod",
-	"fold.comment.yaml",
-	"fold.compact",
-	"fold.cpp.comment.explicit",
-	"fold.directive",
-	"fold.html",
-	"fold.html.preprocessor",
-	"fold.hypertext.comment",
-	"fold.hypertext.heredoc",
-	"fold.perl.package",
-	"fold.perl.pod",
-	"fold.preprocessor",
-	"fold.quotes.nimrod",
-	"fold.quotes.python",
-	"fold.sql.exists",
-	"fold.sql.only.begin",
-	"fold.verilog.flags",
-	"html.tags.case.sensitive",
-	"lexer.caml.magic",
-	"lexer.cpp.allow.dollars",
-	"lexer.cpp.track.preprocessor",
-	"lexer.cpp.update.preprocessor",
-	"lexer.d.fold.at.else",
-	"lexer.errorlist.value.separate",
-	"lexer.flagship.styling.within.preprocessor",
-	"lexer.html.django",
-	"lexer.html.mako",
-	"lexer.metapost.comment.process",
-	"lexer.metapost.interface.default",
-	"lexer.pascal.smart.highlighting",
-	"lexer.props.allow.initial.spaces",
-	"lexer.python.literals.binary",
-	"lexer.python.strings.b",
-	"lexer.python.strings.over.newline",
-	"lexer.python.strings.u",
-	"lexer.sql.backticks.identifier",
-	"lexer.tex.auto.if",
-	"lexer.tex.comment.process",
-	"lexer.tex.interface.default",
-	"lexer.tex.use.keywords",
-	"lexer.xml.allow.scripts",
-	"nsis.ignorecase",
-	"nsis.uservars",
-	"ps.level",
-	"ps.tokenize",
-	"sql.backslash.escapes",
-	"styling.within.preprocessor",
-	"tab.timmy.whinge.level",
+	"fold.by.indentation", // added by Mitchell
+	"lexer.lua.script", // added by Mitchell
+	"lexer.lua.home", // added by Mitchell
+	"lexer.lua.color.theme", // added by Mitchell
+	"SciteDefaultHome", // added by Mitchell
 
 //--Autogenerated -- end of automatically generated section
 
@@ -698,12 +652,12 @@
 	language = props.GetNewExpand("lexer.", fileNameForExtension.c_str());
 	if (language.length()) {
 		if (language.startswith("script_")) {
-			wEditor.Call(SCI_SETLEXER, SCLEX_CONTAINER);
+			wEditor.CallString(SCI_SETLEXERLANGUAGE, 0, "container"); // modified by Mitchell
 		} else {
 			wEditor.CallString(SCI_SETLEXERLANGUAGE, 0, language.c_str());
 		}
 	} else {
-		wEditor.Call(SCI_SETLEXER, SCLEX_NULL);
+		wEditor.CallString(SCI_SETLEXERLANGUAGE, 0, "null"); // modified by Mitchell
 	}
 
 	props.Set("Language", language.c_str());
@@ -712,7 +666,7 @@
 
 	wEditor.Call(SCI_SETSTYLEBITS, wEditor.Call(SCI_GETSTYLEBITSNEEDED));
 
-	wOutput.Call(SCI_SETLEXER, SCLEX_ERRORLIST);
+	wOutput.CallString(SCI_SETLEXERLANGUAGE, 0, "errorlist"); // modified by Mitchell
 
 	SString kw0 = props.GetNewExpand("keywords.", fileNameForExtension.c_str());
 	wEditor.CallString(SCI_SETKEYWORDS, 0, kw0.c_str());
@@ -1208,12 +1162,13 @@
 }
 
 void SciTEBase::ReadFontProperties() {
-	char key[200];
+	// char key[200]; modified by Mitchell
 	SString sval;
 
 	// Set styles
 	// For each window set the global default style, then the language default style, then the other global styles, then the other language styles
 
+#if 0 // added by Mitchell
 	wEditor.Call(SCI_STYLERESETDEFAULT, 0, 0);
 	wOutput.Call(SCI_STYLERESETDEFAULT, 0, 0);
 
@@ -1241,6 +1196,7 @@
 
 	SetStyleFor(wOutput, "*");
 	SetStyleFor(wOutput, "errorlist");
+#endif // added by Mitchell
 
 	if (CurrentBuffer()->useMonoFont) {
 		sval = props.GetExpanded("font.monospace");
diff -r 77399602f8dc win32/makefile
--- scite/win32/makefile	Wed Jul 28 10:38:18 2010 +1000
+++ scite/win32/makefile	Tue Aug 17 00:13:24 2010 -0400
@@ -5,7 +5,22 @@
 # be needed to use other compilers.
 
 .SUFFIXES: .cxx .properties
+# added by Mitchell
+ifdef LINUX
+CC = i486-mingw32-g++ -mms-bitfields
+DLLWRAP = dllwrap
+GCC = i486-mingw32-gcc
+WINDRES = i486-mingw32-windres
+DEL = rm
+COPY = cp
+else
+# end added by Mitchell
 CC = g++
+# added by Mitchell
+DLLWRAP = dllwrap
+GCC = gcc
+WINDRES = windres
+# end added by Mitchell
 ifndef CYGWIN
 DEL = del /q
 COPY = copy
@@ -13,6 +28,7 @@
 DEL = rm
 COPY = cp
 endif
+endif # added by Mitchell
 
 PROG	= ../bin/SciTE.exe
 PROGSTATIC = ../bin/Sc1.exe
@@ -23,7 +39,7 @@
 vpath %.o ../../scintilla/win32
 vpath %.a ../../scintilla/win32
 
-ifndef NO_LUA
+# ifndef NO_LUA modified by Mitchell
 LUA_CORE_OBJS = lapi.o lcode.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o \
 		lmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o \
 		ltable.o ltm.o lundump.o lvm.o lzio.o
@@ -31,18 +47,23 @@
 LUA_LIB_OBJS =	lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o ltablib.o \
 		lstrlib.o loadlib.o loslib.o linit.o
 
-LUA_OBJS = LuaExtension.o SingleThreadExtension.o $(LUA_CORE_OBJS) $(LUA_LIB_OBJS)
+LUA_OBJS = LuaExtension.o SingleThreadExtension.o # modified by Mitchell
+#added by Mitchell
+LUA_LDFLAGS = -L ../../scintilla/bin -lSciLexer --export-all-symbols
+#end added by Mitchell
 
 vpath %.c ../lua/src ../lua/src/lib
 
 LUA_INCLUDES = -I ../lua/include
 #LUA_SCRIPTS = ..\bin\SciTEExtension.lua ..\bin\SciTEStartup.lua
 LUA_DEFINES = -DLUA_USER_H=\"scite_lua_win.h\"
-else
-LUA_DEFINES = -DNO_LUA
-endif
+# modified by Mitchell
+#else
+#LUA_DEFINES = -DNO_LUA
+#endif
+# end modified by Mitchell
 
-INCLUDEDIRS=-I ../../scintilla/include -I ../../scintilla/win32 -I ../src $(LUA_INCLUDES)
+INCLUDEDIRS=-I ../../scintilla/include -I ../../scintilla/lexers -I ../../scintilla/win32 -I ../src $(LUA_INCLUDES) # modified by Mitchell
 RCINCLUDEDIRS=--include-dir ../../scintilla/win32 --include-dir ../src
 
 CBASEFLAGS = -W -Wall $(INCLUDEDIRS) $(LUA_DEFINES) $(WIDEFLAGS) -mno-cygwin
@@ -62,7 +83,7 @@
 	$(CC) $(CXXFLAGS) -c $< -o $@
 
 .c.o:
-	gcc $(CFLAGS) -c $< -o $@
+	$(GCC) $(CFLAGS) -c $< -o $@ # modified by Mitchell
 
 OTHER_OBJS	= FilePath.o SciTEBuffers.o SciTEIO.o Exporters.o PropSetFile.o StringList.o \
 SciTEProps.o SciTEWin.o SciTEWinBar.o SciTEWinDlg.o MultiplexExtension.o \
@@ -72,7 +93,7 @@
 
 OBJS = SciTEBase.o $(OTHER_OBJS)
 
-DLLS=..\bin\Scintilla.dll ..\bin\SciLexer.dll
+DLLS=../bin/Scintilla.dll ../bin/SciLexer.dll
 
 #++Autogenerated -- run scintilla/src/LexGen.py to regenerate
 #**1:LEXPROPS=\\\n\(../bin/\* \)
@@ -104,7 +125,7 @@
 
 PROPS=../bin/SciTEGlobal.properties ../bin/abbrev.properties $(LEXPROPS)
 
-ALL:	$(PROG) $(PROGSTATIC) $(DLLS) $(PROPS) $(LUA_SCRIPTS)
+ALL:	$(PROG) $(DLLS) $(PROPS) $(LUA_SCRIPTS) # modified by Mitchell
 
 clean:
 	$(DEL) *.exe *.o *.obj *.dll *.res *.map
@@ -112,20 +133,20 @@
 deps:
 	$(CC) -MM $(CXXFLAGS) *.cxx ../src/*.cxx ../lua/src/*.c ../lua/src/lib/*.c >deps.mak
 
-..\bin\Scintilla.dll:	..\..\scintilla\bin\Scintilla.dll
-	$(COPY) ..\..\scintilla\bin\Scintilla.dll $@
+../bin/Scintilla.dll:	../../scintilla/bin/Scintilla.dll
+	$(COPY) ../../scintilla/bin/Scintilla.dll $@
 
-..\bin\SciLexer.dll:	..\..\scintilla\bin\SciLexer.dll
-	$(COPY) ..\..\scintilla\bin\SciLexer.dll $@
+../bin/SciLexer.dll:	../../scintilla/bin/SciLexer.dll
+	$(COPY) ../../scintilla/bin/SciLexer.dll $@
 
 # Using '/' rather than '\' as that allows make to match the next rule
 ../bin/%.properties:	../src/%.properties
-	$(COPY) $(subst /,\,$^) $(subst /,\,$@)
+	$(COPY) $(subst /,/,$^) $(subst /,/,$@)
 
 # Normally distributed rather than built as may not have grep on all machines
 # Copy all non-comment lines from all the properties files into one combined file
-..\src\Embedded.properties: $(PROPS)
-	grep -v -h "^[#]" $(PROPS) >..\src\Embedded.properties
+../src/Embedded.properties: $(PROPS)
+	grep -v -h "^[#]" $(PROPS) >../src/Embedded.properties
 
 $(PROG): $(OBJS)
 	$(CC) $(STRIPFLAG) -Xlinker --subsystem -Xlinker windows -o  $@ $^ $(LDFLAGS)
@@ -152,12 +173,12 @@
 	$(CC) $(CXXFLAGS) -D STATIC_BUILD -c $< -o $@
 
 SciTERes.o:	SciTERes.rc SciTE.h PlatformRes.h SciTE.exe.manifest
-	windres $(RCINCLUDEDIRS) SciTERes.rc $@
+	$(WINDRES) $(RCINCLUDEDIRS) SciTERes.rc $@ # modified by Mitchell
 
 # Also depends on ../src/Embedded.properties but may not want to build everywhere
 # so must explicitly ask to build it.
 Sc1Res.o:	SciTERes.rc SciTE.h PlatformRes.h SciTE.exe.manifest
-	windres $(RCINCLUDEDIRS) SciTERes.rc --define STATIC_BUILD $@
+	$(WINDRES) $(RCINCLUDEDIRS) SciTERes.rc --define STATIC_BUILD $@ # modified by Mitchell
 
 # Make sure SciTEBase gets rebuilt (so its about box gets a new
 # date stamp) when any of the other objects are updated.
diff -r 77399602f8dc win32/scite.mak
--- scite/win32/scite.mak	Wed Jul 28 10:38:18 2010 +1000
+++ scite/win32/scite.mak	Tue Aug 17 00:13:24 2010 -0400
@@ -110,90 +110,14 @@
 	UniqueInstance.obj \
 	WinMutex.obj
 
+# modified by Mitchell
 #++Autogenerated -- run src/LexGen.py to regenerate
 #**LEXOBJS=\\\n\(\t..\\..\\scintilla\\win32\\\*.obj \\\n\)
 LEXOBJS=\
-	..\..\scintilla\win32\LexAbaqus.obj \
-	..\..\scintilla\win32\LexAda.obj \
-	..\..\scintilla\win32\LexAPDL.obj \
-	..\..\scintilla\win32\LexAsm.obj \
-	..\..\scintilla\win32\LexAsn1.obj \
-	..\..\scintilla\win32\LexASY.obj \
-	..\..\scintilla\win32\LexAU3.obj \
-	..\..\scintilla\win32\LexAVE.obj \
-	..\..\scintilla\win32\LexBaan.obj \
-	..\..\scintilla\win32\LexBash.obj \
-	..\..\scintilla\win32\LexBasic.obj \
-	..\..\scintilla\win32\LexBullant.obj \
-	..\..\scintilla\win32\LexCaml.obj \
-	..\..\scintilla\win32\LexCLW.obj \
-	..\..\scintilla\win32\LexCmake.obj \
-	..\..\scintilla\win32\LexCOBOL.obj \
-	..\..\scintilla\win32\LexConf.obj \
-	..\..\scintilla\win32\LexCPP.obj \
-	..\..\scintilla\win32\LexCrontab.obj \
-	..\..\scintilla\win32\LexCsound.obj \
-	..\..\scintilla\win32\LexCSS.obj \
-	..\..\scintilla\win32\LexD.obj \
-	..\..\scintilla\win32\LexEiffel.obj \
-	..\..\scintilla\win32\LexErlang.obj \
-	..\..\scintilla\win32\LexEScript.obj \
-	..\..\scintilla\win32\LexFlagship.obj \
-	..\..\scintilla\win32\LexForth.obj \
-	..\..\scintilla\win32\LexFortran.obj \
-	..\..\scintilla\win32\LexGAP.obj \
-	..\..\scintilla\win32\LexGui4Cli.obj \
-	..\..\scintilla\win32\LexHaskell.obj \
-	..\..\scintilla\win32\LexHTML.obj \
-	..\..\scintilla\win32\LexInno.obj \
-	..\..\scintilla\win32\LexKix.obj \
-	..\..\scintilla\win32\LexLisp.obj \
-	..\..\scintilla\win32\LexLout.obj \
-	..\..\scintilla\win32\LexLua.obj \
-	..\..\scintilla\win32\LexMagik.obj \
-	..\..\scintilla\win32\LexMarkdown.obj \
-	..\..\scintilla\win32\LexMatlab.obj \
-	..\..\scintilla\win32\LexMetapost.obj \
-	..\..\scintilla\win32\LexMMIXAL.obj \
-	..\..\scintilla\win32\LexMPT.obj \
-	..\..\scintilla\win32\LexMSSQL.obj \
-	..\..\scintilla\win32\LexMySQL.obj \
-	..\..\scintilla\win32\LexNimrod.obj \
-	..\..\scintilla\win32\LexNsis.obj \
-	..\..\scintilla\win32\LexOpal.obj \
-	..\..\scintilla\win32\LexOthers.obj \
-	..\..\scintilla\win32\LexPascal.obj \
-	..\..\scintilla\win32\LexPB.obj \
-	..\..\scintilla\win32\LexPerl.obj \
-	..\..\scintilla\win32\LexPLM.obj \
-	..\..\scintilla\win32\LexPOV.obj \
-	..\..\scintilla\win32\LexPowerPro.obj \
-	..\..\scintilla\win32\LexPowerShell.obj \
-	..\..\scintilla\win32\LexProgress.obj \
-	..\..\scintilla\win32\LexPS.obj \
-	..\..\scintilla\win32\LexPython.obj \
-	..\..\scintilla\win32\LexR.obj \
-	..\..\scintilla\win32\LexRebol.obj \
-	..\..\scintilla\win32\LexRuby.obj \
-	..\..\scintilla\win32\LexScriptol.obj \
-	..\..\scintilla\win32\LexSmalltalk.obj \
-	..\..\scintilla\win32\LexSML.obj \
-	..\..\scintilla\win32\LexSorcus.obj \
-	..\..\scintilla\win32\LexSpecman.obj \
-	..\..\scintilla\win32\LexSpice.obj \
-	..\..\scintilla\win32\LexSQL.obj \
-	..\..\scintilla\win32\LexTACL.obj \
-	..\..\scintilla\win32\LexTADS3.obj \
-	..\..\scintilla\win32\LexTAL.obj \
-	..\..\scintilla\win32\LexTCL.obj \
-	..\..\scintilla\win32\LexTeX.obj \
-	..\..\scintilla\win32\LexTxt2tags.obj \
-	..\..\scintilla\win32\LexVB.obj \
-	..\..\scintilla\win32\LexVerilog.obj \
-	..\..\scintilla\win32\LexVHDL.obj \
-	..\..\scintilla\win32\LexYAML.obj \
+	..\..\scintilla\win32\LexLPeg.obj
 
 #--Autogenerated -- end of automatically generated section
+# end modified by Mitchell
 
 OBJSSTATIC=\
 	SciTEBase.obj \
